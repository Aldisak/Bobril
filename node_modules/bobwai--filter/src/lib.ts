import * as b from "bobril";
import * as Textbox from "bobwai--textbox";
import * as Icon from "bobwai--icon";
import * as Color from "bobwai--color";
import * as FormElements from "bobwai--form-elements";
import * as rtlTextHelper from "helpers--rtl-text";
import * as Constants from "./publicConstants";
import { IWebContentAccessibility } from "helpers--web-content-accessibility";
import { t } from "bobril-g11n";

export { Autocomplete } from "bobwai--textbox";

const escapeCode = 27;
const filterIcon = Icon.create({ sprite: b.sprite(Icon.filter_small_png, Color.Grey500) });
const closeIcon = Icon.create({ sprite: b.sprite(Icon.close_small_png, Color.Basic) });
const hoverCloseIcon = Icon.create({ sprite: b.sprite(Icon.close_small_png, Color.Error) });

export let create = b.createComponent<IData>({
    id: "bobwai--filter",
    render(ctx: IContext, me: b.IBobrilNode): void {
        me.children = [createFilterTextbox(ctx)];
        b.style(me, baseStyle);
    },
    onKeyDown(ctx: IContext, event: b.IKeyDownUpEvent): boolean {
        if (ctx.data.clearTextOnEscape) {
            if (event.which === escapeCode) {
                ctx.data.onTextClear();
            }
        }
        return false;
    },
});

export type WebContentAccessibility = Required<Pick<IWebContentAccessibility, "ariaLabel">>;

export interface IData {
    value?: string;
    filterIcon?: b.IBobrilNode;
    clearIconTooltip?: FormElements.ITooltipData;
    filterIconTooltip?: FormElements.ITooltipData;
    forceFocus?: boolean;
    forceBlur?: boolean;
    clearTextOnEscape?: boolean;
    size?: Size;
    placeholder?: string;
    isOnChangeWithDelay?: boolean;
    isDisabled?: boolean;
    onChange(value: string): void;
    onTextClear(): void;
    onFocusIn?(ctx: IContext): void;
    onFocusOut?(ctx: IContext): void;
    autocomplete?: Textbox.Autocomplete;
    customFocusBorderColor?: string;
    webContentAccessibility?: WebContentAccessibility;
}

export enum Size {
    Default,
    Small,
}

export interface IContext extends b.IBobrilCtx {
    data: IData;
}

export * from "./publicConstants";

namespace localVariables {
    export const iconSize = 20;
    export const iconPaddingTop = 6;
    export const iconPaddingBottom = 6;
    export const iconPaddingLeftRight = 7;
    export const iconPaddingTopSmall = 0;
    export const iconPaddingBottomSmall = 0;
}

function createFilterTextbox(ctx: IContext): b.IBobrilNode {
    let inputNode = b.style(
        Textbox.create({
            placeholder: ctx.data.placeholder,
            size: ctx.data.size === Size.Small ? Textbox.Size.Small : Textbox.Size.Default,
            onChange: ctx.data.onChange,
            value: ctx.data.value,
            onFocusIn: () => {
                ctx.data.onFocusIn && ctx.data.onFocusIn(ctx);
                b.invalidate(ctx);
            },
            onFocusOut: () => {
                ctx.data.onFocusOut && ctx.data.onFocusOut(ctx);
                b.invalidate(ctx);
            },
            forceFocus: ctx.data.forceFocus,
            forceBlur: ctx.data.forceBlur,
            isOnChangeWithDelay: ctx.data.isOnChangeWithDelay,
            isDisabled: ctx.data.isDisabled,
            autocomplete: ctx.data.autocomplete,
            customFocusBorderColor: ctx.data.customFocusBorderColor,
            webContentAccessibility: ctx.data.webContentAccessibility,
            rightIcon: createFilterIcon(ctx),
        }),
        filterTextboxStyle,
        rtlTextHelper.getRtlTextStyles({
            enableRTL: Constants.EnableRTL,
            text: ctx.data.value,
        })
    );

    return inputNode;
}

function createFilterIcon(ctx: IContext): Textbox.IRightIcon {
    const isEmpty = !ctx.data.value || ctx.data.value === "";

    return {
        icon: isEmpty ? ctx.data.filterIcon || filterIcon : closeIcon,
        iconHover: isEmpty ? ctx.data.filterIcon || filterIcon : hoverCloseIcon,
        tooltip: isEmpty ? ctx.data.filterIconTooltip : ctx.data.clearIconTooltip || { tooltipHeader: t("Clear") },
        onClick: isEmpty
            ? undefined
            : () => {
                  ctx.data.onTextClear();
                  b.focus(ctx.me);
              },
    };
}

const baseStyle = b.styleDef(
    {
        position: "relative",
    },
    {},
    "filter-base"
);

const filterTextboxStyle = b.styleDef(
    {
        paddingRight: `${localVariables.iconSize + localVariables.iconPaddingLeftRight * 2}px !important`,
        color: Color.Basic,
    },
    {},
    "filter-textbox"
);

// added by script - BEGIN
export const Filter = create;
// added by script - END
