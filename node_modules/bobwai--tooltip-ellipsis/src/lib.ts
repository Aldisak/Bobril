import * as b from "bobril";
import * as TooltipEmplacer from "bobwai--tooltip-emplacer";
import * as FormElements from "bobwai--form-elements";

export let create = b.createVirtualComponent<IData>({
    id: "bobwai--tooltip-ellipsis",
    init(ctx: IContext): void {
        ctx.showTooltip = false;
        ctx.minScrollWidth = 0;
        ctx.currentDisplayStyle = "";
    },
    render(ctx: IContext, me: b.IBobrilNode): void {
        me.children = ctx.showTooltip
            ? TooltipEmplacer.create({
                  content: ctx.data.content,
                  preferedPlacement: ctx.data.preferedPlacement,
                  secondaryPreferedPlacement: ctx.data.secondaryPreferedPlacement,
                  tooltipMessage: ctx.data.permanentTooltipMessage,
                  tooltipHeader: getCombinedTooltip(ctx.data.tooltipMessage, ctx.data.permanentTooltipHeader),
                  validationState: ctx.data.validationState
              })
            : hasPermanentTooltip(ctx.data)
                ? TooltipEmplacer.create({
                      content: ctx.data.content,
                      preferedPlacement: ctx.data.preferedPlacement,
                      secondaryPreferedPlacement: ctx.data.secondaryPreferedPlacement,
                      tooltipMessage: ctx.data.permanentTooltipMessage,
                      tooltipHeader: ctx.data.permanentTooltipHeader,
                      validationState: ctx.data.validationState
                  })
                : ctx.data.content;
    },
    onMouseEnter(ctx: IContext): void {
        getMinScrollWidth(ctx, ctx.me);
        checkEllipsis(ctx, ctx.me);
    },
    onMouseLeave(ctx: IContext): void {
        ctx.showTooltip = false;
        b.invalidate(ctx);
    }
});

export { Placement } from "bobwai--tooltip-emplacer";

export interface IData {
    content: b.IBobrilNode;
    /**  Appears only if ellipsis is applied */
    tooltipMessage: string;
    /** Appears always */
    permanentTooltipMessage?: string | string[];
    /** Appears always */
    permanentTooltipHeader?: string;
    preferedPlacement?: TooltipEmplacer.Placement;
    secondaryPreferedPlacement?: TooltipEmplacer.Placement;
    /**e.g. when content is 90deg rotated */
    useContentHeightInsteadOfWidth?: boolean;
    validationState?: FormElements.ValidationState;
}

interface IContext extends b.IBobrilCtx {
    data: IData;
    showTooltip: boolean;
    minScrollWidth: number;
    currentDisplayStyle: string | null;
}

function getCombinedTooltip(simpleTooltip: string, permanentTooltip: string | string[] | undefined): string[] {
    let result = [simpleTooltip];
    if (Array.isArray(permanentTooltip)) {
        result = result.concat(permanentTooltip);
    } else if (permanentTooltip) {
        result.push(permanentTooltip);
    }
    return b.flatten(result);
}

function hasPermanentTooltip(data: IData): boolean {
    return hasTooltip(data.permanentTooltipMessage, data.permanentTooltipHeader);
}

function hasTooltip(tooltipMessage: string | string[] | undefined, tooltipHeader?: string): boolean {
    if (Array.isArray(tooltipMessage)) {
        if (tooltipMessage.length > 0) {
            return true;
        }
    } else {
        if (tooltipMessage !== undefined && tooltipMessage !== null && (<string>tooltipMessage).length > 0) {
            return true;
        }
    }
    if (tooltipHeader !== undefined && tooltipHeader !== null && (<string>tooltipHeader).length > 0) {
        return true;
    }
    return false;
}

function checkEllipsis(ctx: IContext, cacheNode: b.IBobrilCacheNode): void {
    let shouldShowTooltip = false;
    let elem = b.getDomNode(cacheNode);
    if (elem) {
        shouldShowTooltip = isEllipsisActive(ctx, <HTMLElement>elem);
        if (shouldShowTooltip !== ctx.showTooltip) {
            ctx.showTooltip = shouldShowTooltip;
            b.invalidate(ctx);
        }
    }
}

function isEllipsisActive(ctx: IContext, element: HTMLElement): boolean {
    let isEllipsisActive = false;
    if (element && element.getBoundingClientRect) {
        // rounding is necessary because in table it is sometime 0.1px larger than scrollheight
        // which makes unwanted displaying of tooltip
        let width =
            ctx.data.useContentHeightInsteadOfWidth === true
                ? element.getBoundingClientRect().height
                : element.getBoundingClientRect().width;
        let scrollWidth = element.scrollWidth;
        let isEdgeBrowser = /Edge/i.test(navigator.userAgent);

        if (b.ieVersion() === 9) {
            isEllipsisActive = scrollWidth - width > 1;
        }
        if (b.ieVersion() === 10 || isEdgeBrowser) {
            isEllipsisActive = scrollWidth - width >= 1;
        }
        if (b.ieVersion() === 11) {
            isEllipsisActive = scrollWidth - width > 1.3; // this number was found experimentally
        }
        if (scrollWidth > Math.ceil(width)) {
            isEllipsisActive = true;
        }
        if (!isEllipsisActive) {
            isEllipsisActive = ctx.minScrollWidth > Math.ceil(width);
        }
    }
    return isEllipsisActive;
}

function getMinScrollWidth(ctx: IContext, me: b.IBobrilCacheNode) {
    let elem = b.getDomNode(me);
    let scrollDiv = <HTMLElement>elem;

    ctx.currentDisplayStyle = scrollDiv.style.display;
    scrollDiv.style.display = "inline-block";

    let scrollWidth = scrollDiv.getBoundingClientRect().width;
    if (scrollWidth !== ctx.minScrollWidth) {
        ctx.minScrollWidth = scrollWidth;
    }

    scrollDiv.style.display = ctx.currentDisplayStyle;
}

// added by script - BEGIN
export const TooltipEllipsis = create;
// added by script - END