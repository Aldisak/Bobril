import * as b from "bobril";
import * as FormElements from "bobwai--form-elements";
import * as TooltipMessage from "bobwai--tooltip-message";
import * as Equal from "helpers--equal";

const defaultOpenDelayTimeOut = 500;

export { Placement, EllipsisWidth, ITooltipTheme } from "bobwai--tooltip-message";
export { ValidationState } from "bobwai--form-elements";

export interface IData {
    content: b.IBobrilNode;
    tooltipHeader?: string | string[];
    tooltipMessage?: string | string[];
    customTheme?: TooltipMessage.ITooltipTheme;
    preferedPlacement?: TooltipMessage.Placement;
    secondaryPreferedPlacement?: TooltipMessage.Placement;
    validationState?: FormElements.ValidationState;
    hideOnClick?: boolean;
    openDelay?: number;
    /**
     * Using for case when some of parent elements contain scroll and can cover part of content.
     */
    computePositionFromVisibleContent?: boolean;
    isHiddenForPartiallyVisibleContent?: boolean;
    hasBorder?: boolean;
    zoomRatio?: number;
    /**
     * undefined (default) = controlled by mouse,
     * true = visible,
     * false = hidden
     */
    isVisibilityForced?: boolean;
    ellipsisWidth?: TooltipMessage.EllipsisWidth;
}

interface IContext extends b.IBobrilCtx {
    data: IData;
    rootId: string | null;
    needUpdatePosition: boolean;
    isTooltipVisible: boolean;
    tooltipPosition: { left: number; top: number } | null;
    windowSizePosition: { width: number; height: number };
    tooltipCurrentPlacement?: TooltipMessage.Placement;
    tooltipPreferedPlacement?: TooltipMessage.Placement;
    lastContentRect: IRect;
    lastMessageRect: IRect;
    tooltipMessage?: string | string[] | null;
    tooltipHeader?: string | string[] | null;
    isDragOver?: boolean;
    isMouseOver?: boolean;
    isRootInvalidated: boolean;
    isHiddenBecauseOfContentPosition: boolean;
    lastZoomRatio?: number;
    lastEllipsisWidth?: TooltipMessage.EllipsisWidth;
}

interface IRect {
    left: number;
    top: number;
    width: number;
    height: number;
}

export let create = b.createVirtualComponent<IData>({
    id: "bobwai--tooltip-emplacer",
    init(ctx: IContext): void {
        rememberLastMessageProperties(ctx);
        ctx.isTooltipVisible = false;
        ctx.needUpdatePosition = false;
        ctx.tooltipPosition = null;
        ctx.windowSizePosition = { width: 0, height: 0 };
        const onScroll = () => {
            if (ctx.tooltipPosition) {
                ctx.tooltipPosition = null;
            }
            if (ctx.data.isHiddenForPartiallyVisibleContent || ctx.data.isVisibilityForced) {
                resolveMessageVisibility(ctx);
            }
            removeTooltip(ctx);
        };
        b.addOnScroll(onScroll);
        b.addDisposable(ctx, () => b.removeOnScroll(onScroll));

        ctx.tooltipPreferedPlacement = getPreferedPlacement(ctx);
        ctx.tooltipCurrentPlacement = getPreferedPlacement(ctx);
    },
    render(ctx: IContext, me: b.IBobrilNode): void {
        me.children = ctx.data.content;
        if (isEmptyTooltip(ctx)) {
            if (ctx.rootId) {
                b.removeRoot(ctx.rootId);
            }
            ctx.tooltipMessage = null;
            ctx.tooltipHeader = null;
            return;
        }
        checkIfMessageWasChanged(ctx);
        checkIfPlacementWasChanged(ctx);

        if (ctx.isTooltipVisible && ctx.needUpdatePosition && !ctx.isDragOver) {
            if (ctx.rootId) {
                b.removeRoot(ctx.rootId);
            }

            ctx.isRootInvalidated = false;

            ctx.rootId = b.addRoot(() => {
                let msg = getTooltipMessage(ctx);
                if (!ctx.isRootInvalidated) {
                    b.invalidate(ctx); // necessary for flux.routeComponents
                    ctx.isRootInvalidated = true;
                }
                return msg;
            });

            ctx.needUpdatePosition = false;
        }

        if (ctx.data.isVisibilityForced && !ctx.isHiddenBecauseOfContentPosition) {
            if (!ctx.isTooltipVisible) {
                ctx.isMouseOver = true;
                showTooltip(ctx);
            }
        } else if (ctx.data.isVisibilityForced === false || ctx.isHiddenBecauseOfContentPosition) {
            if (ctx.isTooltipVisible) {
                ctx.isMouseOver = false;
                removeTooltip(ctx);
            }
        }
    },
    onDragOver(ctx: IContext): boolean {
        if (ctx.isDragOver || ctx.data.isVisibilityForced !== undefined || ctx.isHiddenBecauseOfContentPosition) {
            return false;
        }
        ctx.isDragOver = true;
        b.invalidate(ctx);
        return false;
    },
    onMouseEnter(ctx: IContext): void {
        if (ctx.data.isVisibilityForced !== undefined || ctx.isHiddenBecauseOfContentPosition) {
            return;
        }
        ctx.isMouseOver = true;
        if (isEmptyTooltip(ctx)) {
            return;
        }
        let delayTimeOut = ctx.data.openDelay !== undefined && ctx.data.openDelay >= 0 ? ctx.data.openDelay : defaultOpenDelayTimeOut;
        setTimeout(() => showTooltip(ctx), delayTimeOut);
    },
    onMouseUp(ctx: IContext): boolean {
        if (ctx.data.isVisibilityForced !== undefined || ctx.isHiddenBecauseOfContentPosition) {
            return false;
        }
        if (ctx.data.hideOnClick) {
            removeTooltip(ctx);
        }
        return false;
    },
    onMouseLeave(ctx: IContext): void {
        if (ctx.data.isVisibilityForced !== undefined || ctx.isHiddenBecauseOfContentPosition) {
            return;
        }
        ctx.isDragOver = false;
        ctx.isMouseOver = false;
        removeTooltip(ctx);
    },
    postUpdateDom(ctx: IContext, me: b.IBobrilCacheNode): void {
        if (me && ctx.isTooltipVisible && (ctx.data.isVisibilityForced || ctx.data.isHiddenForPartiallyVisibleContent)) {
            resolveMessageVisibility(ctx, me);
        }
        if (me && ctx.isTooltipVisible && ctx.refs && ctx.refs["tooltip-message"] && !ctx.isHiddenBecauseOfContentPosition) {
            checkWindowSize(ctx);
            let contentElement = <HTMLElement>b.getDomNode(me);
            let messageElement = <HTMLElement>b.getDomNode(<b.IBobrilCacheNode>ctx.refs["tooltip-message"]);

            if (contentElement && messageElement) {
                let contentRect = getContentRect(contentElement);

                // solves BOB-545 (it is needed to compare also tooltip element size)
                let currentMessageRect = getRect(messageElement.getBoundingClientRect());

                if (ctx.data.computePositionFromVisibleContent === true) {
                    let parentWithScroll = findFirstParentWithScroll(contentElement);
                    if (parentWithScroll !== undefined) {
                        let visibleContentRect = getVisibleRect(contentRect, parentWithScroll);
                        contentRect = visibleContentRect;
                    }
                }

                if (
                    !ctx.tooltipPosition ||
                    !Equal.deepEqual(ctx.lastContentRect, contentRect) ||
                    !Equal.deepEqual(ctx.lastMessageRect, currentMessageRect)
                ) {
                    ctx.lastContentRect = contentRect;
                    ctx.lastMessageRect = currentMessageRect;
                    setTooltipPosition(messageElement, currentMessageRect, contentRect, ctx);
                }
            }
        }
    },
    destroy(ctx: IContext): void {
        if (ctx.rootId) {
            b.removeRoot(ctx.rootId);
        }
    }
});

function showTooltip(ctx: IContext): void {
    if (!ctx.isMouseOver) {
        return;
    }
    ctx.isTooltipVisible = true;
    ctx.needUpdatePosition = true;
    b.invalidate(ctx);
}

function isEmptyTooltip(ctx: IContext): boolean {
    return isEmpty(ctx.data.tooltipMessage) && isEmpty(ctx.data.tooltipHeader);
}

function isEmpty(item: string | string[] | undefined): boolean {
    if (item && b.isArray(item)) {
        if (item.length === 0) {
            return true;
        }

        let allValuesAreEmpty: boolean = true;
        (item as string[]).forEach(value => {
            if (value && value !== "") {
                allValuesAreEmpty = false;
                return;
            }
        });
        return allValuesAreEmpty;
    }

    return !!(!item || (item && item.length === 0));
}

function getRect(rectangle: ClientRect): IRect {
    return (
        rectangle && {
            top: rectangle.top,
            left: rectangle.left,
            height: rectangle.height,
            width: rectangle.width
        }
    );
}

function removeTooltip(ctx: IContext): void {
    if (ctx.isTooltipVisible) {
        if (ctx.rootId) {
            b.removeRoot(ctx.rootId);
        }
        ctx.rootId = null;
        ctx.isTooltipVisible = false;
        ctx.needUpdatePosition = false;
        b.invalidate(ctx);
    }
}

function checkWindowSize(ctx: IContext): void {
    let currentWindowWidth = window.innerWidth;
    let currentWindowHeight = window.innerHeight;
    if (ctx.windowSizePosition.width !== currentWindowWidth || ctx.windowSizePosition.height !== currentWindowHeight) {
        ctx.tooltipPosition = null;
        ctx.windowSizePosition = {
            width: currentWindowWidth,
            height: currentWindowHeight
        };
    }
}

function getPreferedPlacement(ctx: IContext) {
    return ctx.data.preferedPlacement === undefined ? TooltipMessage.Placement.topCenter : ctx.data.preferedPlacement;
}

function checkIfMessageWasChanged(ctx: IContext): void {
    if (
        !Equal.deepEqual(ctx.tooltipMessage, ctx.data.tooltipMessage) ||
        !Equal.deepEqual(ctx.tooltipHeader, ctx.data.tooltipHeader) ||
        ctx.lastZoomRatio !== ctx.data.zoomRatio ||
        ctx.lastEllipsisWidth !== ctx.data.ellipsisWidth
    ) {
        rememberLastMessageProperties(ctx);
        ctx.needUpdatePosition = true;
        ctx.tooltipPosition = null;
        ctx.tooltipCurrentPlacement = undefined;
    }
}

function rememberLastMessageProperties(ctx: IContext) {
    ctx.tooltipMessage = ctx.data.tooltipMessage;
    ctx.tooltipHeader = ctx.data.tooltipHeader;
    ctx.lastZoomRatio = ctx.data.zoomRatio;
    ctx.lastEllipsisWidth = ctx.data.ellipsisWidth;
}

function checkIfPlacementWasChanged(ctx: IContext): void {
    let preferedPlacement = getPreferedPlacement(ctx);
    if (ctx.tooltipPreferedPlacement !== preferedPlacement) {
        ctx.needUpdatePosition = true;
        ctx.tooltipPosition = null;
        ctx.tooltipCurrentPlacement = undefined;
        ctx.tooltipPreferedPlacement = preferedPlacement;
    }
}

function getTooltipMessage(ctx: IContext): b.IBobrilNode {
    let tooltip = TooltipMessage.create({
        header: ctx.data.tooltipHeader,
        message: ctx.data.tooltipMessage,
        placement: ctx.tooltipCurrentPlacement !== undefined ? ctx.tooltipCurrentPlacement : getPreferedPlacement(ctx),
        validationState: ctx.data.validationState,
        customTheme: ctx.data.customTheme,
        hasBorder: ctx.data.hasBorder,
        zoomRatio: ctx.data.zoomRatio,
        ellipsisWidth: ctx.data.ellipsisWidth
    });
    tooltip = b.style(tooltip, {
        position: "fixed",
        visibility: ctx.tooltipPosition ? "visible" : "hidden",
        left: ctx.tooltipPosition && ctx.tooltipPosition.left ? ctx.tooltipPosition.left : 0,
        top: ctx.tooltipPosition && ctx.tooltipPosition.top ? ctx.tooltipPosition.top : 0
    });
    tooltip.ref = [ctx, "tooltip-message"];
    return tooltip;
}

interface IWriteableIRect extends IRect {
    bottom: number;
    right: number;
}

function getContentRect(content: HTMLElement): IWriteableIRect {
    let rect = content.getBoundingClientRect();
    let contentRect: IWriteableIRect = {
        height: rect.height,
        width: rect.width,
        bottom: rect.bottom,
        top: rect.top,
        left: rect.left,
        right: rect.right
    };
    return contentRect;
}

function resolveMessageVisibility(ctx: IContext, me?: b.IBobrilCacheNode) {
    if (!me) {
        me = ctx.me;
    }
    if (me) {
        let contentElement = <HTMLElement>b.getDomNode(me);
        if (contentElement) {
            let shouldBeHidden = false;

            let contentRect: IWriteableIRect = getContentRect(contentElement);

            let parentWithScroll = findFirstParentWithScroll(contentElement);
            if (parentWithScroll !== undefined) {
                let visibleContentRect = getVisibleRect(contentRect, parentWithScroll);

                shouldBeHidden =
                    // hide tooltip for fully hidden content
                    visibleContentRect.height < 1 ||
                    visibleContentRect.width < 1 ||
                    // hide tooltip for partially hidden content if isTooltipHiddenForPartiallyInvisibleContent is set
                    (!!ctx.data.isHiddenForPartiallyVisibleContent &&
                        (visibleContentRect.height !== contentRect.height || visibleContentRect.width !== contentRect.width));
            }

            if (ctx.isHiddenBecauseOfContentPosition !== shouldBeHidden) {
                ctx.isHiddenBecauseOfContentPosition = shouldBeHidden;
                let messageElement =
                    ctx.refs && ctx.refs["tooltip-message"] && <HTMLElement>b.getDomNode(<b.IBobrilCacheNode>ctx.refs["tooltip-message"]);
                if (messageElement) {
                    messageElement.style.display = shouldBeHidden ? "none" : "";
                }
                b.invalidate(ctx);
            }
        }
    }
}

function setTooltipPosition(messageElement: HTMLElement, messageRect: IRect, contentRect: IWriteableIRect, ctx: IContext): void {
    let possiblePlaces = getPlacementAsArray();
    let isCheckedPreferedPlacement = false;
    let preferedPlacement = getPreferedPlacement(ctx);
    let currentIndex = preferedPlacement !== undefined ? possiblePlaces.indexOf(preferedPlacement) : -1;
    if (currentIndex > -1) {
        let placesTried = 0;

        while (placesTried < possiblePlaces.length) {
            // if prefered placement was already checked then skip checking this placement
            if (isCheckedPreferedPlacement && preferedPlacement === currentIndex) {
                currentIndex += 1;
                if (currentIndex === possiblePlaces.length) {
                    currentIndex = 0;
                }
            }

            let position = tryToCountPosition(messageRect, contentRect, possiblePlaces[currentIndex], ctx.data.zoomRatio);

            if (position && position.left && position.top && position.placement !== undefined) {
                if (preferedPlacement !== position.placement || ctx.tooltipCurrentPlacement !== position.placement) {
                    ctx.needUpdatePosition = true;
                    b.invalidate(ctx);
                } else {
                    messageElement.style.visibility = "visible";
                    messageElement.style.left = position.left.toString() + "px";
                    messageElement.style.top = position.top.toString() + "px";
                }
                ctx.tooltipCurrentPlacement = position.placement;
                ctx.tooltipPosition = { left: position.left, top: position.top };
                break;
            } else {
                // if there is no free space for the first prefered placement then jump
                // directly to the secondary prefered placement (if definated)
                // else continue by increasing the index by one as well as there is no free place for secondary placement
                if (
                    ctx.data.secondaryPreferedPlacement !== undefined &&
                    !isCheckedPreferedPlacement &&
                    preferedPlacement === currentIndex
                ) {
                    currentIndex = ctx.data.secondaryPreferedPlacement;
                    isCheckedPreferedPlacement = true;
                } else {
                    currentIndex += 1;
                }

                placesTried += 1;
                if (currentIndex === possiblePlaces.length) {
                    currentIndex = 0;
                }
            }
        }
    }
}

function getVisibleRect(contentRect: IWriteableIRect, parentWithScroll: HTMLElement): IWriteableIRect {
    let parentRect = parentWithScroll.getBoundingClientRect();
    let newContentRect = JSON.parse(JSON.stringify(contentRect));
    if (contentRect.bottom > parentRect.bottom) {
        newContentRect.height -= contentRect.bottom - parentRect.bottom;
        newContentRect.bottom = parentRect.bottom;
    }
    if (contentRect.top < parentRect.top) {
        newContentRect.height -= parentRect.top - contentRect.top;
        newContentRect.top = parentRect.top;
    }
    if (contentRect.right > parentRect.right) {
        newContentRect.width -= contentRect.right - parentRect.right;
        newContentRect.right = parentRect.right;
    }

    if (contentRect.left < parentRect.left) {
        newContentRect.width -= parentRect.left - contentRect.left;
        newContentRect.left = parentRect.left;
    }

    return newContentRect;
}

function findFirstParentWithScroll(tooltipChild: HTMLElement): HTMLElement | undefined {
    let parentWithScroll: HTMLElement | undefined = undefined;
    let parent = tooltipChild.parentElement;
    while (parentWithScroll === undefined) {
        if (parent) {
            // has overflow Y or X
            if (b.isScrollable(parent).indexOf(true) !== -1) {
                parentWithScroll = parent;
            } else {
                parent = parent.parentElement;
            }
        } else {
            break;
        }
    }
    return parentWithScroll;
}

function tryToCountPosition(
    messageRect: IRect,
    contentRect: IRect,
    requestedPlacement: TooltipMessage.Placement,
    zoomRatio: number | undefined
): { top: number; left: number; placement: TooltipMessage.Placement } | undefined {
    let zoomRatioResolved = zoomRatio || 1;

    let tooltipArrowOffset = 20;
    let tooltipArrowSize = 10;
    let availablelLeftSpace = contentRect.left;
    let availablelRightSpace = window.innerWidth - (contentRect.left + contentRect.width);
    let availableTopSpace = contentRect.top;
    let availableBottomSpace = window.innerHeight - (contentRect.top + contentRect.height);
    let tooltipChildHorizontalCenterPoint = contentRect.left + contentRect.width / 2;
    let tooltipChildVerticalCenterPoint = contentRect.top + contentRect.height / 2;
    let tooltipMessageHalfWidthSize = messageRect.width / 2;
    let tooltipMessageHalfHeightSize = messageRect.height / 2;

    let isPlacementTopAvailable = availableTopSpace - messageRect.height > 0;
    let isPlacementBottomAvailable = availableBottomSpace - messageRect.height > 0;
    let isPlacementCenterAvailable =
        tooltipChildHorizontalCenterPoint + tooltipMessageHalfWidthSize < window.innerWidth &&
        tooltipChildHorizontalCenterPoint - tooltipMessageHalfWidthSize > 0;
    let isPlacementOffsetLeftAvailable = tooltipChildHorizontalCenterPoint - messageRect.width + tooltipArrowOffset > 0;
    let isPlacementOffsetRightAvailable = tooltipChildHorizontalCenterPoint + messageRect.width - tooltipArrowOffset < window.innerWidth;

    let isPlacementVerticaliCentered =
        tooltipChildVerticalCenterPoint - tooltipMessageHalfHeightSize > 0 &&
        tooltipChildVerticalCenterPoint + tooltipMessageHalfHeightSize < window.innerHeight;
    let isPlacementLeftCenterAvailable = availablelLeftSpace - messageRect.width > 0 && isPlacementVerticaliCentered;
    let isPlacementRightCenterAvailable = availablelRightSpace - messageRect.width > 0 && isPlacementVerticaliCentered;

    let isPlacementTopLeftAvailable = isPlacementTopAvailable && isPlacementOffsetLeftAvailable;
    let isPlacementTopRightAvailable = isPlacementTopAvailable && isPlacementOffsetRightAvailable;
    let isPlacementTopCenterAvailable = isPlacementTopAvailable && isPlacementCenterAvailable;

    let isPlacementBottomLeftAvailable = isPlacementBottomAvailable && isPlacementOffsetLeftAvailable;
    let isPlacementBottomRightAvailable = isPlacementBottomAvailable && isPlacementOffsetRightAvailable;
    let isPlacementBottomCenterAvailable = isPlacementBottomAvailable && isPlacementCenterAvailable;

    let left: number | null = null;
    let top: number | null = null;

    if (requestedPlacement === TooltipMessage.Placement.left) {
        if (isPlacementLeftCenterAvailable) {
            left = contentRect.left - messageRect.width / zoomRatioResolved - tooltipArrowSize;
            top = tooltipChildVerticalCenterPoint - tooltipMessageHalfHeightSize / zoomRatioResolved;
        }
    }
    if (requestedPlacement === TooltipMessage.Placement.right) {
        if (isPlacementRightCenterAvailable) {
            left = contentRect.left + contentRect.width + tooltipArrowSize;
            top = tooltipChildVerticalCenterPoint - tooltipMessageHalfHeightSize / zoomRatioResolved;
        }
    }
    if (requestedPlacement === TooltipMessage.Placement.topCenter) {
        if (isPlacementTopCenterAvailable) {
            left = tooltipChildHorizontalCenterPoint - tooltipMessageHalfWidthSize / zoomRatioResolved;
            top = contentRect.top - messageRect.height / zoomRatioResolved - tooltipArrowSize;
        }
    }
    if (requestedPlacement === TooltipMessage.Placement.topLeft) {
        if (isPlacementTopLeftAvailable) {
            left = tooltipChildHorizontalCenterPoint - messageRect.width / zoomRatioResolved + tooltipArrowOffset;
            top = contentRect.top - messageRect.height / zoomRatioResolved - tooltipArrowSize;
        }
    }
    if (requestedPlacement === TooltipMessage.Placement.topRight) {
        if (isPlacementTopRightAvailable) {
            left = tooltipChildHorizontalCenterPoint - tooltipArrowOffset;
            top = contentRect.top - messageRect.height / zoomRatioResolved - tooltipArrowSize;
        }
    }
    if (requestedPlacement === TooltipMessage.Placement.bottomCenter) {
        if (isPlacementBottomCenterAvailable) {
            left = tooltipChildHorizontalCenterPoint - tooltipMessageHalfWidthSize / zoomRatioResolved;
            top = contentRect.top + contentRect.height + tooltipArrowSize;
        }
    }
    if (requestedPlacement === TooltipMessage.Placement.bottomLeft) {
        if (isPlacementBottomLeftAvailable) {
            left = tooltipChildHorizontalCenterPoint - messageRect.width / zoomRatioResolved + tooltipArrowOffset;
            top = contentRect.top + contentRect.height + tooltipArrowSize;
        }
    }
    if (requestedPlacement === TooltipMessage.Placement.bottomRight) {
        if (isPlacementBottomRightAvailable) {
            left = tooltipChildHorizontalCenterPoint - tooltipArrowOffset;
            top = contentRect.top + contentRect.height + tooltipArrowSize;
        }
    }
    if (left !== null && top !== null) {
        return {
            top: Math.round(top),
            left: Math.round(left),
            placement: requestedPlacement
        };
    }
    return undefined;
}

function getPlacementAsArray(): number[] {
    return Object.keys(TooltipMessage.Placement)
        .map(v => parseInt(v, 10))
        .filter(v => !isNaN(v));
}

// added by script - BEGIN
export const TooltipEmplacer = create;
// added by script - END
