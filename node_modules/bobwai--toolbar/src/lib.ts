import * as b from "bobril";
import * as styles from "./styles";
import * as ActionWithWindow from "bobwai--action-with-window";
export * from "./publicConstants";
import * as Color from "bobwai--color";
import * as Icon from "bobwai--icon";

const hideIcon = Icon.create({ sprite: b.sprite(Icon.move_right_all_small_png, Color.Basic) });
const hideIconHovered = Icon.create({ sprite: b.sprite(Icon.move_right_all_small_png, Color.Application) });

const leftContentKey = "toolbar-left-content";
const rightContentKey = "toolbar-right-content";

export let create = b.createComponent<IData>({
    id: "bobwai--toolbar",
    init(ctx: IContext): void {
        ctx.leftContentWidth = 0;
        ctx.rightContentWidth = 0;
        ctx.shouldHideRightContent = false;
        ctx.isExpandContentOpened = false;
    },
    render(ctx: IContext, me: b.IBobrilNode): void {
        me.children = [
            createLeftContent(ctx),
            ctx.shouldHideRightContent && ctx.data.itemsRight ? createExpandableRightContent(ctx) : createRightContent(ctx),
            createCenterContent(ctx)
        ];
        b.style(me, styles.toolbarStyle, ctx.data.size === Size.Small && styles.toolbarSmallStyle);
    },
    postInitDom(ctx: IContext, _me: b.IBobrilCacheNode): void {
        if (ctx.refs) {
            if (ctx.refs[leftContentKey]) ctx.leftContentWidth = getElementWidthFromRef(ctx, leftContentKey);
            if (ctx.refs[rightContentKey]) ctx.rightContentWidth = getElementWidthFromRef(ctx, rightContentKey);
        }
        if (b.ieVersion()) {
            b.invalidate(ctx);
        }
    },
    postUpdateDom(ctx: IContext, _me: b.IBobrilCacheNode, toolbarElement: HTMLElement): void {
        if (ctx.refs) {
            let leftContentWidth = ctx.leftContentWidth;
            let rightContentWidth = ctx.rightContentWidth;
            const hasRightContent = !!ctx.data.itemsRight && ctx.data.itemsRight.length > 0;

            if (ctx.refs[leftContentKey]) {
                leftContentWidth = getElementWidthFromRef(ctx, leftContentKey);
            }

            if (!ctx.shouldHideRightContent && ctx.refs[rightContentKey]) {
                rightContentWidth = getElementWidthFromRef(ctx, rightContentKey);
            } else if (!hasRightContent) {
                rightContentWidth = 0;
            }

            const toolbarWidth = toolbarElement.clientWidth;

            const sumToolbarContentWidth =
                leftContentWidth +
                rightContentWidth +
                (ctx.data.centerContent ? styles.centerContentMinWidth : 0) +
                2 * styles.bothSidePadding;

            const shouldHideRightContent = hasRightContent && Math.round(sumToolbarContentWidth) > Math.round(toolbarWidth);

            const isRightContentExpandingUpdated = ctx.shouldHideRightContent !== shouldHideRightContent;
            if (isRightContentExpandingUpdated) ctx.shouldHideRightContent = shouldHideRightContent;

            const isLeftContentUpdated = ctx.leftContentWidth !== leftContentWidth;
            const isRightContentUpdated = ctx.rightContentWidth !== rightContentWidth;
            if (isLeftContentUpdated) ctx.leftContentWidth = leftContentWidth;
            if (isRightContentUpdated) ctx.rightContentWidth = rightContentWidth;

            const leftOrRightContentUpdated = isLeftContentUpdated || isRightContentUpdated;
            if ((ctx.data.centerContent && leftOrRightContentUpdated) || isRightContentExpandingUpdated) b.invalidate(ctx);
        }
    }
});

export interface IData {
    items?: b.IBobrilNode[];
    itemsRight?: b.IBobrilNode[];
    centerContent?: b.IBobrilChildren;
    size?: Size;
}

export enum Size {
    Default,
    Small
}

interface IContext extends b.IBobrilCtx {
    data: IData;
    shouldHideRightContent: boolean;
    leftContentWidth: number;
    rightContentWidth: number;
    isExpandContentOpened: boolean;
}

function getElementWidthFromRef(ctx: IContext, key: string): number {
    return (<HTMLElement>b.getDomNode(<b.IBobrilCacheNode>ctx!.refs![key])).scrollWidth;
}

function createLeftContent(ctx: IContext): b.IBobrilNode | undefined {
    let leftContent = ctx.data.items && b.styledDiv(ctx.data.items.map(i => b.styledDiv(i, styles.toolbarItem)), styles.itemsLeftDivStyle);
    if (leftContent) leftContent.ref = [ctx, leftContentKey];
    return leftContent;
}

function createRightContent(ctx: IContext): b.IBobrilNode | undefined {
    let rightContent =
        ctx.data.itemsRight &&
        b.withKey(
            b.styledDiv(ctx.data.itemsRight.map(i => b.styledDiv(i, styles.toolbarItem)), styles.itemsRightDivStyle),
            "toolbar-right-content"
        );
    if (rightContent) rightContent.ref = [ctx, rightContentKey];
    return rightContent;
}

function createCenterContent(ctx: IContext): b.IBobrilNode | undefined {
    let center = ctx.data.centerContent
        ? b.withKey(
              b.styledDiv(ctx.data.centerContent, styles.centerContentStyle, {
                  left: ctx.leftContentWidth + styles.bothSidePadding,
                  right: ctx.shouldHideRightContent ? styles.expandButtonWidth : ctx.rightContentWidth + styles.bothSidePadding
              }),
              "toolbar-center-content"
          )
        : undefined;

    return center;
}

function createExpandableRightContent(ctx: IContext): b.IBobrilNode {
    return b.withKey(
        b.styledDiv(
            ActionWithWindow.create({
                actionContent: createExpandButton({
                    isSelected: ctx.isExpandContentOpened
                }),
                windowContent: b.styledDiv(
                    ctx.data.itemsRight!.map(i => b.styledDiv(i, styles.rightExpandItem)),
                    styles.rightExpandContent
                ),
                isOverflowVisible: true,
                onOpenWindow: () => {
                    ctx.isExpandContentOpened = true;
                    b.invalidate(ctx);
                },
                onCloseWindow: () => {
                    ctx.isExpandContentOpened = false;
                    b.invalidate(ctx);
                },
                isWindowVisible: ctx.isExpandContentOpened
            }),
            styles.rightExpandButton
        ),
        "toolbar-expandable-right-content"
    );
}

interface IExpandButtonData {
    isSelected: boolean;
}

interface IExpandButtonCtx extends b.IBobrilCtx {
    data: IExpandButtonData;
    isHover: boolean;
}

const createExpandButton = b.createComponent<IExpandButtonData>({
    render(ctx: IExpandButtonCtx, me: b.IBobrilNode) {
        me.tag = "div";
        me.children = ctx.isHover || ctx.data.isSelected ? hideIconHovered : hideIcon;
        b.style(me, styles.rightExpandIcon);
    },
    onMouseEnter(ctx: IExpandButtonCtx) {
        ctx.isHover = true;
        b.invalidate(ctx);
    },
    onMouseLeave(ctx: IExpandButtonCtx) {
        ctx.isHover = false;
        b.invalidate(ctx);
    }
});

// added by script - BEGIN
export const Toolbar = create;
// added by script - END