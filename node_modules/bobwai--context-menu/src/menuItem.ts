import * as b from "bobril";
import * as styles from "./styles";
import * as Icon from "bobwai--icon";
import * as Color from "bobwai--color";
import * as WebAccessibility from "helpers--web-content-accessibility";
import * as ContextMenu from "./lib";
import * as Menu from "./menu";

export let create = b.createComponent<IData>({
    init(ctx: IItemContext): void {
        ctx.data.internalData && (ctx.data.internalData.isContextMenuOpen = false);
        ctx.timeoutHandler = 0;
    },
    render(ctx: IItemContext, me: b.IBobrilNode): void {
        b.style(me, getStyles(ctx));
        me.attrs = {
            tabindex: -1
        };

        WebAccessibility.setWebContentAccessibilityAttributes(me, {
            isSelected: ctx.data.externalData.isSelected,
            ariaLabel: getItemAriaLabel(ctx.data),
            popup: ctx.data.externalData &&
                ctx.data.externalData.contextMenu && {
                    isExpanded: !!(ctx.data.internalData && ctx.data.internalData.isContextMenuOpen)
                },
            role: getRole(ctx.data)
        });
        me.children = getChildren(ctx);
        resetTriggerClickIfNeeded(ctx);
    },
    onClick(ctx: IItemContext, event: b.IBobrilMouseEvent): boolean {
        if (ctx.data.externalData.wrapper) {
            return false;
        }
        if (ctx.data.internalData && ctx.data.internalData.isContextMenuOpen) {
            return false;
        }
        if (ctx.data.externalData.isDisabled || ctx.data.externalData.contextMenu) {
            return true;
        }
        ctx.data.externalData.onClick && ctx.data.externalData.onClick(ctx.data.externalData.id, event);
        ctx.data.externalData.closeMenuOnClick &&
            ctx.data.internalData &&
            ctx.data.internalData.onContextMenuClose &&
            ctx.data.internalData.onContextMenuClose();
        return true;
    },
    onMouseEnter(ctx: IItemContext): void {
        const internalData = ctx.data.internalData;
        if (internalData && internalData.onMenuItemMouseEnter) {
            if (ctx.data.externalData.contextMenu) {
                setDelayOpeningMenu(ctx, () => {
                    internalData && internalData.onSubContextMenuOpenByMouseEnter && internalData.onSubContextMenuOpenByMouseEnter();
                });
            }
            internalData.onMenuItemMouseEnter();
        }
    },
    onMouseLeave(ctx: IItemContext): void {
        if (ctx.timeoutHandler) {
            window.clearTimeout(ctx.timeoutHandler);
        }
    },
    postInitDom(ctx: IItemContext, _me: b.IBobrilCacheNode, element: HTMLElement): void {
        if (ctx.data.externalData.contextMenu) {
            saveElementRect(ctx, element);
            b.invalidate(ctx);
        }
    },
    postUpdateDom(ctx: IItemContext, _me: b.IBobrilCacheNode, element: HTMLElement): void {
        if (ctx.data.externalData.contextMenu) {
            saveElementRect(ctx, element);
        }
        if (ctx.data.externalData.wrapper) {
            processTriggerClickForWrapper(ctx, element);
        }
        setFocusIfNeeded(ctx);
    }
});

export * from "./publicConstants";

export interface IInnerData {
    isTitle?: boolean;
    isTitleWithoutPadding?: boolean;
    hasEmptyIcon?: boolean;
    isContextMenuOpen?: boolean;
    hasHover?: boolean;
    /**
     * if sub context menu is opened via keyboard the first item in sub context menu is automatically selected
     * if it is opened via mouse, no pre-selection is needed
     */
    isSubContextMenuOpenedViaMouse?: boolean;
    /**
     * for special case if there is item wrapper -
     * e.g. link or upload component,
     * on enter we have to trigger click directly on item to simulate the same click target as normal mouse click
     */
    triggerClickForWrapper?: ITriggerClickForWrapper;
    // on close whole context menu
    onContextMenuClose?: () => void;
    // on close only actual sub context menu
    onSubContextMenuClose?: () => void;
    onMenuItemMouseEnter?: () => void;
    // opening sub context menu via mouse with some delay
    onSubContextMenuOpenByMouseEnter?: () => void;
}

export interface IData {
    externalData: ContextMenu.IItem;
    internalData?: IInnerData;
}

interface IItemContext extends b.IBobrilCtx {
    data: IData;
    timeoutHandler: number;
    rectangle: ContextMenu.IRect;
    wasTriggerClickForWrapperFinished?: boolean;
    isFocused?: boolean;
}

export interface ITriggerClickForWrapper {
    isTriggeringClick: boolean;
    onTriggerClickFinished: () => void;
}
namespace localVariables {
    export const timeoutInMilliseconds = 500;
}
function getItemAriaLabel(data: IData): string | undefined {
    if (data.externalData && data.externalData.content && b.isString(data.externalData.content)) {
        data.externalData.content;
    }
    return undefined;
}

function getRole(data: IData): WebAccessibility.ContentAccessibilityRole | undefined {
    if (data.externalData && (data.externalData.onClick || data.externalData.contextMenu) && !data.externalData.isDisabled) {
        return WebAccessibility.ContentAccessibilityRole.MenuItem;
    }

    return undefined;
}

function setFocusIfNeeded(ctx: IItemContext): void {
    if (ctx.data.internalData && ctx.data.internalData.hasHover && !ctx.isFocused && !ctx.data.internalData.isContextMenuOpen) {
        ctx.isFocused = true;
        b.focus(ctx.me);
    }
    if (ctx.data.internalData && (!ctx.data.internalData.hasHover || ctx.data.internalData.isContextMenuOpen) && ctx.isFocused) {
        ctx.isFocused = false;
    }
}

const setDelayOpeningMenu = (ctx: IItemContext, callback: () => void): void => {
    ctx.timeoutHandler = window.setTimeout(() => {
        callback();
    }, localVariables.timeoutInMilliseconds);
};

function processTriggerClickForWrapper(ctx: IItemContext, element: HTMLElement) {
    if (ctx.data.internalData && ctx.data.internalData.triggerClickForWrapper && !ctx.wasTriggerClickForWrapperFinished) {
        if (ctx.data.internalData.triggerClickForWrapper.isTriggeringClick) {
            element.click();
            ctx.wasTriggerClickForWrapperFinished = true;
            ctx.data.internalData.triggerClickForWrapper.onTriggerClickFinished();
        }
    }
}

function resetTriggerClickIfNeeded(ctx: IItemContext): void {
    if (ctx.data.internalData && ctx.data.internalData.triggerClickForWrapper) {
        if (!ctx.data.internalData.triggerClickForWrapper.isTriggeringClick && ctx.wasTriggerClickForWrapperFinished === true) {
            ctx.wasTriggerClickForWrapperFinished = undefined;
        }
    }
}

const getStyles = (ctx: IItemContext): b.IBobrilStyles => {
    return [
        styles.itemStyle,
        ctx.data.internalData && ctx.data.internalData.hasHover && styles.itemHoverStyle,
        ctx.data.externalData.isDisabled && styles.disabledStyle,
        ctx.data.externalData.iconContent && styles.itemWithIconStyle,
        ctx.data.externalData.contextMenu && styles.itemWithSubMenuStyle,
        ctx.data.externalData.hasSeparator && styles.itemWithSeparatorStyle,
        ctx.data.externalData.isSelected && styles.itemSelectedStyle,
        ctx.data.internalData && ctx.data.internalData.isTitle && styles.itemTitleStyle,
        ctx.data.internalData && ctx.data.internalData.hasEmptyIcon && styles.itemWithEmptyIconStyle,
        ctx.data.internalData && ctx.data.internalData.isTitleWithoutPadding && styles.titleWithoutPaddingStyle,
        ctx.data.internalData && ctx.data.internalData.isContextMenuOpen && styles.itemHoverStyle
    ];
};

const getChildren = (ctx: IItemContext): b.IBobrilChildren => {
    const children = [
        ctx.data.externalData.iconContent &&
            b.styledDiv(ctx.data.externalData.iconContent, [
                styles.iconContentStyle,
                ctx.data.externalData.isDisabled && styles.itemIconDisabledStyle
            ]),
        b.styledDiv(ctx.data.externalData.content, styles.itemContentStyle),
        ctx.data.externalData.contextMenu &&
            (!ctx.data.externalData.isDisabled
                ? b.styledDiv(Icon.create({ sprite: b.sprite(Icon.sort_right_small_png, Color.Basic) }), styles.subMenuIconStyle)
                : b.styledDiv(Icon.create({ sprite: b.sprite(Icon.sort_right_small_png, Color.Grey500) }), styles.subMenuIconStyle)),
        ctx.data.externalData.contextMenu && ctx.data.internalData && ctx.data.internalData.isContextMenuOpen && getContextMenu(ctx),
        ctx.data.externalData.shortcutContent && getShortcutContent(ctx.data.externalData.shortcutContent)
    ];

    return children;
};

const getShortcutContent = (shortcutContent: b.IBobrilChildren): b.IBobrilNode => {
    return b.styledDiv(shortcutContent, styles.shortcutStyle);
};

const getContextMenu = (ctx: IItemContext): b.IBobrilNode => {
    return Menu.create({
        items: ctx.data.externalData.contextMenu ? ctx.data.externalData.contextMenu.items : [],
        title: ctx.data.externalData.contextMenu && ctx.data.externalData.contextMenu.title,
        isTitleWithoutPadding: ctx.data.externalData.contextMenu && ctx.data.externalData.contextMenu.isTitleWithoutPadding,
        parentMenuItemRect: ctx.rectangle,
        onContextMenuClose: ctx.data.internalData && ctx.data.internalData.onContextMenuClose,
        isClipboardMenuDisabled: true,
        onClose: ctx.data.internalData && ctx.data.internalData.onSubContextMenuClose,
        isOpenedViaMouse: ctx.data.internalData && ctx.data.internalData.isSubContextMenuOpenedViaMouse,
        id: ctx.data.externalData.contextMenu && ctx.data.externalData.contextMenu.id
    });
};

const saveElementRect = (ctx: IItemContext, element: HTMLElement): void => {
    ctx.rectangle = new ContextMenu.IRect(element.getBoundingClientRect());
};
