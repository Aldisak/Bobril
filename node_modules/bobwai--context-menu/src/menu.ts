import * as b from "bobril";
import { t } from "bobril-g11n";
import * as d from "./data";
import * as styles from "./styles";
import * as MenuItem from "./menuItem";
import * as Constants from "./publicConstants";
import * as WebAccessibility from "helpers--web-content-accessibility";
import { getSelectedText, copyToClipboard, getShortcutKey } from "helpers--clipboard";
import { KeyCode } from "helpers--key-codes";
import { TooltipEmplacer, Placement } from "bobwai--tooltip-emplacer";
import { getNextItemIndex, Direction } from "./utils";

interface IData extends d.IContextMenuContent {
    onClose?: () => void;
    isOpenedViaMouse?: boolean;
}

export let create = b.createVirtualComponent<IData>({
    id: "bobwai--context-menu-content-wrapper",
    init(ctx: IContext): void {
        ctx.selectedMenuItemIndex = undefined;
        if (ctx.data.parentMenuItemRect && !ctx.data.isOpenedViaMouse) {
            // select the first selectable item in case menu was opened via keyboard from parent item
            ctx.selectedMenuItemIndex = getNextItemIndex({ items: ctx.data.items, direction: Direction.Down });
            // needs to be here to item set focus in item post update dom
            b.invalidate(ctx);
        }
    },
    render(ctx: IContext, me: b.IBobrilNode): void {
        const contextMenu = getContextMenu(ctx);
        me.children = contextMenu;
    },
    onKeyDown(ctx: IContext, e: b.IKeyDownUpEvent): boolean {
        return processKeyDown(ctx, e);
    },
    postInitDom(ctx: IContext, _me: b.IBobrilCacheNode, _element: HTMLElement) {
        b.focus(ctx.me);
    }
});

export interface IContext extends b.IBobrilCtx {
    data: IData;
    selectedMenuItemIndex?: number;
    itemWithOpenedSubContextMenuIndex?: number;
    triggerClickEventItemIndex?: number;
    wasSubContextMenuOpenedViaMouse?: boolean;
}

namespace localVariables {
    export const itemContentWithShortcutPaddingRight = 20;
    export const subMenuOffset = -4;
}

function getItems(ctx: IContext): d.IItem[] {
    const selectedText = getSelectedText();
    if (selectedText && ctx.data.isClipboardMenuDisabled === false) {
        const itemsCopy = ctx.data.items;
        itemsCopy[itemsCopy.length - 1].hasSeparator = true;
        return [...itemsCopy, getCopyMenuItem(selectedText)];
    } else {
        return ctx.data.items;
    }
}

export let getContextMenu = (context: IContext): b.IBobrilNode => {
    let atLeastOneItemWithIcon = false;
    let atLeastOneItemWithShortcut: boolean = false;
    const items: d.IItem[] = getItems(context);

    items.forEach(item => {
        if (item.iconContent) {
            atLeastOneItemWithIcon = true;
            return;
        }
        if (item.shortcutContent) {
            atLeastOneItemWithShortcut = true;
            return;
        }
    });

    const menuContent = b.style(
        {
            tag: "div",
            attrs: {
                tabindex: 0
            },
            children: [
                context.data.title &&
                    MenuItem.create({
                        externalData: {
                            content: context.data.title,
                            hasSeparator: true
                        },
                        internalData: {
                            isTitle: true,
                            isTitleWithoutPadding: context.data.isTitleWithoutPadding,
                            hasEmptyIcon: atLeastOneItemWithIcon
                        }
                    }),
                items.map((item: d.IItem, index: number) => {
                    let itemContent = createNewMenuItem(item, index, context, atLeastOneItemWithIcon);

                    if (item.wrapper) {
                        item.onClick = undefined;
                        itemContent = item.wrapper(itemContent);
                    }

                    const tt = item.tooltip;
                    if (tt && (tt.tooltipHeader || tt.tooltipMessage)) {
                        itemContent = TooltipEmplacer({
                            content: b.styledDiv(itemContent),
                            tooltipHeader: tt.tooltipHeader,
                            tooltipMessage: tt.tooltipMessage,
                            preferedPlacement: Placement.right,
                            secondaryPreferedPlacement: Placement.left
                        });
                    }

                    return b.withKey(itemContent, item.id ? `context-menu-item-${item.id}` : `context-menu-item-no-${index}`);
                })
            ],
            component: {
                id: "bobwai--context-menu-content",
                postInitDom(_ctx: b.IBobrilCtx, _me: b.IBobrilCacheNode, element: HTMLElement): void {
                    atLeastOneItemWithShortcut && setMenuItemHasShortcutWidth(element);
                    setInitialPosition(element, context.data.mouseEvent, context.data.parentMenuItemRect);
                },
                postUpdateDom(_ctx: b.IBobrilCtx, _me: b.IBobrilCacheNode, element: HTMLElement): void {
                    atLeastOneItemWithShortcut && setMenuItemHasShortcutWidth(element);
                    setInitialPosition(element, context.data.mouseEvent, context.data.parentMenuItemRect);
                }
            }
        },
        styles.contextMenuStyle,
        context.data.hasStaticPosition && styles.contextMenuStaticStyle
    );
    if (context.data.id) {
        return b.withKey(menuContent, `bobwai--context-menu-content-${context.data.id}`);
    }
    WebAccessibility.setWebContentAccessibilityAttributes(menuContent, {
        role: WebAccessibility.ContentAccessibilityRole.Menu,
        ariaLabel: context.data.title
    });
    return menuContent;
};

function processKeyDown(ctx: IContext, e: b.IKeyDownUpEvent): boolean {
    if (e.which === KeyCode.ArrowDown) {
        tryToSelectNextItem(ctx, ctx.selectedMenuItemIndex, Direction.Down);
    }
    if (e.which === KeyCode.ArrowUp) {
        tryToSelectNextItem(ctx, ctx.selectedMenuItemIndex, Direction.Up);
    }
    if (e.which === KeyCode.Escape) {
        if (ctx.data.parentMenuItemRect) {
            tryToCloseSubContextMenu(ctx);
        } else {
            ctx.data.onContextMenuClose && ctx.data.onContextMenuClose();
        }
    }
    if (e.which === KeyCode.End) {
        tryToSelectNextItem(ctx, ctx.data.items.length, Direction.Up);
    }
    if (e.which === KeyCode.Home) {
        tryToSelectNextItem(ctx, -1, Direction.Down);
    }
    if (e.which === KeyCode.ArrowLeft) {
        tryToCloseSubContextMenu(ctx);
    }
    if (e.which === KeyCode.ArrowRight) {
        if (ctx.data.items.length && ctx.selectedMenuItemIndex !== undefined) {
            const item = getItems(ctx)[ctx.selectedMenuItemIndex];
            if (item.contextMenu) {
                openSubContextMenu(ctx);
            }
        }
    }
    if (e.which === KeyCode.Enter) {
        if (ctx.selectedMenuItemIndex !== undefined && ctx.data.items) {
            const item = getItems(ctx)[ctx.selectedMenuItemIndex];
            if (item.contextMenu) {
                openSubContextMenu(ctx);
            }
            if (item.onClick && !item.contextMenu) {
                item.onClick(item.id);
            }
            if (item.wrapper) {
                ctx.triggerClickEventItemIndex = ctx.selectedMenuItemIndex;
                b.invalidate(ctx);
            }
            if (item.closeMenuOnClick && ctx.data.onContextMenuClose && !item.contextMenu && !item.wrapper) {
                ctx.data.onContextMenuClose();
            }
        }
    }
    return true;
}

function openSubContextMenu(ctx: IContext, openedViaMouse?: boolean): void {
    ctx.itemWithOpenedSubContextMenuIndex = ctx.selectedMenuItemIndex;
    ctx.wasSubContextMenuOpenedViaMouse = openedViaMouse;
    b.invalidate(ctx);
}

function tryToCloseSubContextMenu(ctx: IContext): void {
    if (ctx.data.parentMenuItemRect && ctx.data.onClose) {
        ctx.data.onClose();
    }
}

function tryToSelectNextItem(ctx: IContext, currentIndex?: number, direction = Direction.Down): void {
    if (currentIndex === undefined && ctx.data.items && ctx.data.items.length) {
        const firstSelectedItemIndex = tryToGetFirstSelectedItemIndex(ctx.data.items);
        if (firstSelectedItemIndex !== undefined) {
            currentIndex = firstSelectedItemIndex;
        }
    }
    const indexToHover = getNextItemIndex({
        items: getItems(ctx),
        currentIndex,
        direction
    });
    if (indexToHover !== undefined) {
        ctx.selectedMenuItemIndex = indexToHover;
        b.invalidate(ctx);
    }
}

function tryToGetFirstSelectedItemIndex(items: d.IItem[]): number | undefined {
    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        if (item.isSelected && !item.isDisabled) {
            return i;
            break;
        }
    }
    return undefined;
}

function createNewMenuItem(item: d.IItem, index: number, context: IContext, atLeastOneItemWithIcon: boolean): b.IBobrilChild {
    return MenuItem.create({
        externalData: item,
        internalData: {
            hasHover: context.selectedMenuItemIndex === index,
            onContextMenuClose: context.data.onContextMenuClose,
            hasEmptyIcon: atLeastOneItemWithIcon && !item.iconContent,
            isContextMenuOpen: item.contextMenu && !item.isDisabled ? index === context.itemWithOpenedSubContextMenuIndex : false,
            isSubContextMenuOpenedViaMouse: context.wasSubContextMenuOpenedViaMouse,
            triggerClickForWrapper: item.wrapper && {
                isTriggeringClick: index === context.triggerClickEventItemIndex,
                onTriggerClickFinished: () => {
                    context.triggerClickEventItemIndex = undefined;
                    b.invalidate(context);
                }
            },
            onSubContextMenuOpenByMouseEnter: () => {
                openSubContextMenu(context, true);
                b.invalidate(context);
            },
            onMenuItemMouseEnter: () => {
                context.selectedMenuItemIndex = index;
                b.invalidate(context);
            },
            onSubContextMenuClose: () => {
                context.itemWithOpenedSubContextMenuIndex = undefined;
                context.wasSubContextMenuOpenedViaMouse = undefined;
                b.focus(context.me);
                b.invalidate(context);
            }
        }
    });
}

let setMenuItemHasShortcutWidth = (element: HTMLElement): void => {
    let shortcutElements = element.getElementsByClassName(styles.shortcutStyle);
    let itemContentElements = element.getElementsByClassName(styles.itemContentStyle);
    let maxItemContentWidth = 0;
    let maxShortcutWidth = 0;
    for (let i = 0; i < itemContentElements.length; i++) {
        let itemContent: HTMLElement = <HTMLElement>itemContentElements[i];
        maxItemContentWidth = itemContent.clientWidth > maxItemContentWidth ? itemContent.clientWidth : maxItemContentWidth;
        if (shortcutElements[i]) {
            let shortcutContent: HTMLElement = <HTMLElement>shortcutElements[i];
            let shortcutContentWidth = shortcutContent.getBoundingClientRect().width;
            maxShortcutWidth = shortcutContentWidth > maxShortcutWidth ? shortcutContentWidth : maxShortcutWidth;
        }
    }
    let additionalWidth = Constants.ItemPaddingLeft + styles.shortcutRight + localVariables.itemContentWithShortcutPaddingRight;
    element.style.width = `${maxItemContentWidth + maxShortcutWidth + additionalWidth}px`;
};

let setInitialPosition = (contextMenuElement: HTMLElement, event?: d.ContextMenuMousePosition, parentMenuItemRect?: d.IRect): void => {
    if (contextMenuElement && event) {
        setOptimalPosition(event.y, event.x, contextMenuElement);
    } else if (contextMenuElement && parentMenuItemRect) {
        setOptimalPosition(
            parentMenuItemRect.top,
            parentMenuItemRect.left + parentMenuItemRect.width,
            contextMenuElement,
            parentMenuItemRect
        );
    }
};

let setOptimalPosition = (top: number, left: number, contextMenu: HTMLElement, parentMenuItemRect?: d.IRect): void => {
    let newLeft: number | undefined;
    let newTop: number | undefined;
    let restRightSpace: number;
    let restLeftSpace: number;
    let restTopSpace: number;
    let restBottomSpace: number;
    let contextMenuRect = contextMenu.getBoundingClientRect();
    // if contextMenu is submenu
    if (parentMenuItemRect) {
        restRightSpace = window.innerWidth - left - contextMenuRect.width;
        restLeftSpace = left - parentMenuItemRect.width;
        restTopSpace = parentMenuItemRect.top + parentMenuItemRect.height - contextMenuRect.height;
        restBottomSpace = window.innerHeight - parentMenuItemRect.top - contextMenuRect.height;
    } else {
        restRightSpace = window.innerWidth - left - contextMenuRect.width;
        restLeftSpace = left;
        restTopSpace = top - contextMenuRect.height;
        restBottomSpace = window.innerHeight - top - contextMenuRect.height;
    }
    // right
    if (restRightSpace > 0) {
        newLeft = left;
        if (parentMenuItemRect) {
            newLeft += localVariables.subMenuOffset;
        }
    } else if (restLeftSpace > 0) {
        // left
        newLeft = left - contextMenuRect.width;
        if (parentMenuItemRect) {
            newLeft -= parentMenuItemRect.width + localVariables.subMenuOffset;
        }
    }
    // bottom
    if (restBottomSpace > 0) {
        newTop = top;
    } else if (restTopSpace > 0) {
        // top
        newTop = top - contextMenuRect.height;
        if (parentMenuItemRect) {
            newTop += parentMenuItemRect.height;
        }
    }

    if (!newTop) {
        newTop = 0;
        contextMenu.style.overflow = "auto";
        contextMenu.style.maxHeight = `${window.innerHeight}px`;
    }
    if (!newLeft) {
        newLeft = 0;
    }

    contextMenu.style.left = `${newLeft}px`;
    contextMenu.style.top = `${newTop}px`;
};

function getCopyMenuItem(selectedText: string): d.IItem {
    return {
        content: t("Copy", undefined, "verb - clicking element with this label will initiate copy action"),
        shortcutContent: `${getShortcutKey()}-C`,
        closeMenuOnClick: true,
        onClick: () => {
            copyToClipboard(selectedText);
        }
    };
}
