import * as b from "bobril";
import * as Animation from "bobwai--animation";

export interface IData {
    /**
     * content which should be animated
     * */
    content: b.IBobrilChildren;
    /**
     * Animation definition from bobwai--animation component
     */
    showHideAnimation: Animation.IShowHideAnimation;
    /**
     * true: hide animation starts to run
     * false: show animation starts to run
     * undefined: content is shown and has no animation
     */
    isHiding?: boolean;
    /**
     * has 100% height of parent component
     */
    isFullSize?: boolean;
    onHideAnimationFinished?: () => void;
    onShowAnimationFinished?: () => void;
    /**
     * false: if it is first rendered in DOM show animation is not started
     * default value - true
     */
    startShowAnimationOnInit?: boolean;

    /**
     * useful e.g. to cover box shadow in hidden state -
     * in some animation types, part of content's box-shadow can be still visible even in hidden state of animation frame
     */
    hasOverflowHidden?: boolean;
}

interface IContext extends b.IBobrilCtx {
    data: IData;
    isClosing: boolean | undefined;
    isShowing: boolean | undefined;
    timeout: any;
}

export let create = b.createComponent<IData>({
    id: "bobwai--animation-frame",
    init(ctx: IContext, _me: b.IBobrilNode) {
        ctx.isClosing = ctx.data.isHiding;
        ctx.isShowing = false;
    },
    render(ctx: IContext, me: b.IBobrilNode) {
        me.children = [ctx.data.content];
        if (ctx.data.isHiding === true && !ctx.isClosing) {
            startCloseAnimation(ctx);
        }

        // break hide animation
        if (ctx.data.isHiding === false && ctx.isClosing) {
            startShowAnimation(ctx);
        }

        // start show animation
        if (ctx.data.isHiding === false && !ctx.isShowing) {
            startShowAnimation(ctx);
        }

        b.style(me, [
            ctx.data.isHiding && animationFrameRelativePosition,
            ctx.data.isFullSize && animationFrameFullSize,
            ctx.data.showHideAnimation.baseStyle,
            ctx.isShowing && ctx.data.showHideAnimation.showStyle,
            ctx.isClosing && ctx.data.showHideAnimation.hideStyle,
            ctx.data.hasOverflowHidden && animationFrameOverflowHidden
        ]);
    },
    postInitDom(ctx: IContext, _me: b.IBobrilCacheNode, _element: HTMLElement) {
        if (ctx.data.startShowAnimationOnInit !== false) {
            startShowAnimation(ctx);
            b.invalidate(ctx);
        }
    },
    destroy(ctx: IContext) {
        if (ctx.timeout) {
            clearTimeout(ctx.timeout);
        }
    }
});

function startShowAnimation(ctx: IContext) {
    ctx.isClosing = undefined;
    ctx.isShowing = true;
    clearTimeout(ctx.timeout);
    if (ctx.data.onShowAnimationFinished) {
        ctx.timeout = setTimeout(() => {
            ctx.data.onShowAnimationFinished && ctx.data.onShowAnimationFinished();
        }, getShowAnimationTime(ctx.data));
    }
}

function startCloseAnimation(ctx: IContext) {
    ctx.isClosing = true;
    if (ctx.data.onHideAnimationFinished !== undefined) {
        clearTimeout(ctx.timeout);
        ctx.timeout = setTimeout(() => {
            ctx.isClosing = undefined;
            ctx.isShowing = undefined;
            if (ctx.data.onHideAnimationFinished) {
                ctx.data.onHideAnimationFinished();
            }
        }, getCloseAnimationTime(ctx.data));
    }
}

function getCloseAnimationTime(data: IData): number {
    // close callback have to be longer that animation duration
    return Math.round(data.showHideAnimation.hideStyleDuration * 1.2);
}

function getShowAnimationTime(data: IData): number {
    // close callback have to be longer that animation duration
    return Math.round(data.showHideAnimation.showStyleDuration * 1.2);
}

const animationFrameFullSize = b.styleDef({
    height: "100%"
});

const animationFrameRelativePosition = b.styleDef({
    position: "relative"
});

const animationFrameOverflowHidden = b.styleDef({
    overflow: "hidden"
});

// added by script - BEGIN
export const AnimationFrame = create;
// added by script - END