import { IValidationRuleDto, IValidationMessageParameterDto, IValidationTypeEnum } from "./validationObjects";

/* tslint:disable */
const emailValidationRegex = /^[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?$/;
const hexaColorValidationRegex = "^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$";
const indexInRuleRegex = "[[0-9]+]";
/* tslint:enable */

export interface IValidationResult {
    message: string;
    parameters?: IValidationMessageParameterDto[];
}

export declare type ValueType = number | string | Date | boolean | void;

export function getPropertyResults<TValue extends ValueType>(
    value: TValue,
    validationRules: { [key: string]: IValidationRuleDto[] },
    propertyName: string,
    validationTypeEnum: IValidationTypeEnum
): IValidationResult[] {
    const results = new Array<IValidationResult>();

    if (!propertyName) {
        return results;
    }

    const propertyRuleName: string = propertyName.replace(RegExp(indexInRuleRegex, "g"), "");

    if (!propertyRuleName || !validationRules || !validationRules) {
        return results;
    }
    const rules = validationRules[propertyRuleName];
    if (!rules) {
        return results;
    }

    for (let i = 0; i < rules.length; i++) {
        const rule = rules[i];
        switch (rule.type) {
            case validationTypeEnum.Required:
                if (isEmpty(value, rule.allowValueForNullable)) {
                    results.push(getValidationResult(rule, validationTypeEnum));
                }
                break;

            case validationTypeEnum.DoubleRange:
                if (!rangeMatches(<number>value, rule.minDouble || -Infinity, rule.maxDouble || Infinity)) {
                    results.push(getValidationResult(rule, validationTypeEnum));
                }
                break;

            case validationTypeEnum.IntRange:
                if (!!value && <number>value % 1 !== 0) {
                    results.push(getValidationResult(rule, validationTypeEnum));
                    break;
                }
                if (!rangeMatches(<number>value, rule.minInt || -Infinity, rule.maxInt || Infinity)) {
                    results.push(getValidationResult(rule, validationTypeEnum));
                }
                break;
            case validationTypeEnum.DateRange:
                {
                    const castedValue = <Date>value;
                    if (
                        Object.prototype.toString.call(value) === "[object Date]" &&
                        ((rule.minDate && castedValue < rule.minDate) || (rule.maxDate && castedValue > rule.maxDate))
                    ) {
                        results.push(getValidationResult(rule, validationTypeEnum));
                    }
                }
                break;
            case validationTypeEnum.StringLength:
                if (!lengthMatches(<string>value, rule.minLength || -Infinity, rule.maxLength || Infinity)) {
                    results.push(getValidationResult(rule, validationTypeEnum));
                }
                break;

            case validationTypeEnum.StringPattern:
                if (rule.pattern) {
                    const patt = new RegExp(rule.pattern);
                    if (!!value && !patt.test(<string>value)) {
                        results.push(getValidationResult(rule, validationTypeEnum));
                    }
                }
                break;

            case validationTypeEnum.EmailFormat:
                if (!!value && !validEmailAddress(<string>value)) {
                    results.push(getValidationResult(rule, validationTypeEnum));
                }
                break;

            case validationTypeEnum.HexaColorFormat:
                if (!!value && !validHexaColor(<string>value)) {
                    results.push(getValidationResult(rule, validationTypeEnum));
                }
                break;
            case validationTypeEnum.LongRange:
                if (
                    !rangeMatches(<number>value, rule.minLong || -Infinity, rule.maxLong || Infinity) ||
                    !rangeMatches(<number>value, rule.minUlong || -Infinity, rule.maxUlong || Infinity)
                ) {
                    results.push(getValidationResult(rule, validationTypeEnum));
                }
                break;
        }
    }
    return results;
}

export function validHexaColor(color: string): boolean {
    const reg = new RegExp(hexaColorValidationRegex);
    return reg.test(color);
}

function validEmailAddress(emails: string): boolean {
    if (!emails || emails.trim().length === 0) {
        return true;
    }

    const values = splitEmailAddresses(emails);
    return !values.some((value: string) => value.length < 6 || !value.match(emailValidationRegex));
}

function splitEmailAddresses(emails: string): string[] {
    return emails
        .split(";")
        .map((value: string) => value.trim())
        .filter((e) => e.length > 0);
}

function isEmpty<TValue>(value: TValue, allowNullableValue?: boolean): boolean {
    if (allowNullableValue) {
        return value === null || value === undefined;
    }

    if (typeof value === "string") {
        return !value || (<string>value).trim().length <= 0;
    }

    return !value;
}

function rangeMatches(value: number, min: number, max: number): boolean {
    if (!value) {
        return true;
    }
    return value >= min && value <= max;
}

function lengthMatches(value: string, min: number, max: number): boolean {
    if (isEmpty(value)) {
        return true;
    }
    const length = isEmpty(value) ? 0 : value.length;
    return length >= min && length <= max;
}

function getValidationResult(rule: IValidationRuleDto, validationTypeEnum: IValidationTypeEnum): IValidationResult {
    const result = <IValidationResult>{};
    result.parameters = rule.parameters;

    if (rule.message && rule.message.length > 0) {
        result.message = rule.message;
        result.parameters = rule.parameters;
        return result;
    }

    if (rule.type === validationTypeEnum.Required) {
        result.message = "{0} is mandatory.";
        return result;
    }

    if (rule.type === validationTypeEnum.DoubleRange) {
        result.message = "Invalid {0} value. Value must be numerical in the range from {1} to {2}.";
        return result;
    }

    if (rule.type === validationTypeEnum.IntRange) {
        result.message = "Invalid {0} value. Value must be numerical in the range from {1} to {2}.";
        return result;
    }

    if (rule.type === validationTypeEnum.LongRange) {
        result.message = "Invalid {0} value. Value must be numerical in the range from {1} to {2}.";
        return result;
    }

    if (rule.type === validationTypeEnum.StringLength) {
        result.message = "Invalid {0} value. The number of characters must be in the range from {1} to {2}.";
        return result;
    }

    if (rule.type === validationTypeEnum.StringPattern) {
        result.message = "{0} value cannot contain any of the following characters: {2}.";
        return result;
    }

    if (rule.type === validationTypeEnum.EmailFormat) {
        result.message = "Value '{0}' is not valid e-mail.";
        return result;
    }

    if (rule.type === validationTypeEnum.HexaColorFormat) {
        result.message = "HEX code is invalid. Possible character values: [#], [0-9], [A-F]. Examples: #72bf44, #40484b, #ccc";
        return result;
    }

    return result;
}
