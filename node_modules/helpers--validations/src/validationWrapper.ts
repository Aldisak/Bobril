import * as b from "bobril";
import * as flux from "bobflux";
import * as ToolTip from "bobwai--tooltip-emplacer";
import * as FormElements from "bobwai--form-elements";
import * as Validator from "./validation";
import { setValidations } from "./actions/setValidations";
import { IErrorInfo, IValidationRulesDto } from "./validationObjects";
import { shallowCopy } from "bobflux";
import { isInValidableState, addErrorIfNotExists, getErrorInfoOrDefault, deepErrorCopy, isPropertyInvalid } from "./helpers";
import { IData, IFormElementData, ValidationTrigger, BobrilCtxAsArgType, TValueAsArgType, isIBobrilCtx } from "./data";

export function validationComponent<TComponentData extends IFormElementData<TValue, TParam>, TValue extends Validator.ValueType, TParam>(
    params: IData<TComponentData, TValue, TParam>
): b.IBobrilNode {
    const messages: string[] = [];
    const componentData = shallowCopy(params.componentData, (dataCopy: TComponentData) => dataCopy);

    if (isInValidableState(params)) {
        prepareMessages<TComponentData, TValue, TParam>(params, componentData, messages);
    }

    assignValidationCallbacks(params, componentData);

    return ToolTip.create({
        content: params.builder(componentData),
        tooltipMessage: messages,
        preferedPlacement: !params.placement ? ToolTip.Placement.bottomCenter : params.placement,
        validationState: ToolTip.ValidationState.Error,
    });
}

function validateValue<TComponentData extends IFormElementData<TValue, TParam>, TValue extends Validator.ValueType, TParam>(
    params: IData<TComponentData, TValue, TParam>,
    value?: TValue
): void {
    performErrorChanged(params, (errorInfoCopy: IErrorInfo | null | undefined) => {
        if (errorInfoCopy && errorInfoCopy.propertyErrors && errorInfoCopy.propertyErrors[params.propertyName]) {
            delete errorInfoCopy.propertyErrors[params.propertyName];
        }
        if (isInValidableState(params)) {
            const validationRules = getValidationRules(params);
            errorInfoCopy = getErrorInfoOrDefault(errorInfoCopy);
            if (validationRules && validationRules.rules) {
                const results = Validator.getPropertyResults(value, validationRules.rules, params.propertyName, params.validationTypeEnum);
                if (results.length) {
                    results.forEach((result: Validator.IValidationResult) => {
                        errorInfoCopy = addErrorIfNotExists(
                            <IErrorInfo>errorInfoCopy,
                            result.message,
                            result.parameters,
                            params.propertyName
                        );
                    });
                }
            }
        }
        return <IErrorInfo>errorInfoCopy;
    });
}

function prepareMessages<TComponentData extends IFormElementData<TValue, TParam>, TValue extends Validator.ValueType, TParam>(
    params: IData<TComponentData, TValue, TParam>,
    componentData: {} & TComponentData,
    messages: string[]
): void {
    const errorInfo = getErrorInfo(params);
    if (errorInfo && errorInfo.propertyErrors && errorInfo.propertyErrors[params.propertyName]) {
        componentData.validationState = FormElements.ValidationState.Error;

        if (!params.preventTooltip) {
            messages.push(...errorInfo.propertyErrors[params.propertyName].map(params.localizeErrorMessage));
        }
    }
}

function getValidationTriggers<TComponentData extends IFormElementData<TValue, TParam>, TValue extends Validator.ValueType, TParam>(
    params: IData<TComponentData, TValue, TParam>
): ValidationTrigger[] {
    let triggers = b.isArray(params.triggerValidationOn)
        ? params.triggerValidationOn
        : [params.triggerValidationOn || ValidationTrigger.OnChange];
    triggers = getRequiredTriggers<TComponentData, TValue, TParam>(params, triggers);
    return triggers;
}

function getRequiredTriggers<TComponentData extends IFormElementData<TValue, TParam>, TValue extends Validator.ValueType, TParam>(
    params: IData<TComponentData, TValue, TParam>,
    triggers: ValidationTrigger[]
): ValidationTrigger[] {
    const errorInfo = getErrorInfo(params);
    const hasOnChangeTrigger = triggers.some((trigger) => trigger === ValidationTrigger.OnChange);
    if (isPropertyInvalid(params.propertyName, errorInfo) && !hasOnChangeTrigger) {
        triggers = triggers.slice();
        triggers.push(ValidationTrigger.OnChange);
    }
    return triggers;
}

function assignValidationCallbacks<TComponentData extends IFormElementData<TValue, TParam>, TValue extends Validator.ValueType, TParam>(
    params: IData<TComponentData, TValue, TParam>,
    componentData: {} & TComponentData
): void {
    const validationTriggers = getValidationTriggers(params);

    validationTriggers.forEach((trigger) => {
        switch (trigger) {
            case ValidationTrigger.OnFocusOut:
                assignOnFocusOut(componentData, params);
                break;
            case ValidationTrigger.OnChange:
                assignOnChange(componentData, params);
                break;
            default:
                break;
        }
    });
}

function performErrorChanged<TComponentData extends IFormElementData<TValue, TParam>, TValue extends Validator.ValueType, TParam>(
    params: IData<TComponentData, TValue, TParam>,
    change: (changeErrorInfo: IErrorInfo | null | undefined) => IErrorInfo
): void {
    let errorInfo = getErrorInfo(params);
    if (errorInfo) {
        errorInfo = deepErrorCopy(errorInfo);
    }

    errorInfo = change(errorInfo);

    if (params.validationsCursor) {
        setValidations({
            cursor: params.validationsCursor,
            errorInfo: errorInfo,
        });
    } else if (params.errorChanged) {
        params.errorChanged(errorInfo);
    }
}

function assignOnFocusOut<TComponentData extends IFormElementData<TValue, TParam>, TValue extends Validator.ValueType, TParam>(
    componentData: {} & TComponentData,
    params: IData<TComponentData, TValue, TParam>
): void {
    const originalOnFocusOut = componentData.onFocusOut;

    componentData.onFocusOut = <BobrilCtxAsArgType<TValue, TParam> | TValueAsArgType<TValue>>((
        valueOrContext: TValue & b.IBobrilCtx<IFormElementData<TValue, TParam>>
    ) => {
        const value = isIBobrilCtx(valueOrContext) ? valueOrContext.data.value : valueOrContext;
        validateValue<TComponentData, TValue, TParam>(params, value);

        if (originalOnFocusOut !== undefined) {
            originalOnFocusOut(valueOrContext);
        }
    });
}

function assignOnChange<TComponentData extends IFormElementData<TValue, TParam>, TValue extends Validator.ValueType, TParam>(
    componentData: {} & TComponentData,
    params: IData<TComponentData, TValue, TParam>
): void {
    const originalOnchange = componentData.onChange;
    componentData.onChange = (value: TValue, ...p: TParam[]) => {
        validateValue<TComponentData, TValue, TParam>(params, value);

        if (originalOnchange) {
            originalOnchange(value, ...p);
        }
    };
}

function getErrorInfo<TComponentData extends IFormElementData<TValue, TParam>, TValue extends Validator.ValueType, TParam>(
    params: IData<TComponentData, TValue, TParam>
): IErrorInfo | null | undefined {
    return params.validationsCursor ? flux.getState(params.validationsCursor).errorInfo : params.errorInfo;
}

function getValidationRules<TComponentData extends IFormElementData<TValue, TParam>, TValue extends Validator.ValueType, TParam>(
    params: IData<TComponentData, TValue, TParam>
): IValidationRulesDto | null | undefined {
    return params.validationsCursor !== undefined ? flux.getState(params.validationsCursor).validationRules : params.validations;
}
