import { IErrorInfo, IErrorInfoBase, IValidationMessageParameterDto, IValidationTypeEnum } from "./validationObjects";
import { IValidationsState } from "./state";
import { IData, IFormElementData } from "./data";
import { setValidations, setValidationsHandler } from "./actions/setValidations";
import * as Validator from "./validation";
import * as flux from "bobflux";
import { IValidationCursorFactoryParams, dynamicValidationsCursorFactory } from "./cursor";

export function deepErrorCopy(errorInfo: IErrorInfo | IErrorInfoBase): IErrorInfo {
    const error = <IErrorInfo>errorInfo;
    return flux.shallowCopy(error, (errorCopy) => {
        if (areDefinedPropertyErrors(errorCopy.propertyErrors)) {
            errorCopy.propertyErrors = flux.shallowCopy(error.propertyErrors, (propertyErrorsCopy) => {
                Object.keys(error.propertyErrors!).forEach((propertyName) => {
                    // cannot be undefined
                    if (propertyErrorsCopy && error.propertyErrors) {
                        propertyErrorsCopy[propertyName] = error.propertyErrors[propertyName].map(deepErrorCopy);
                    }
                });
                return propertyErrorsCopy;
            });
        }

        if (error.errorParameters) {
            errorCopy.errorParameters = error.errorParameters.slice();
        }

        if (error.localizableParametersIds) {
            errorCopy.localizableParametersIds = error.localizableParametersIds.slice();
        }
    });
}

interface IPropertyErrors {
    [key: string]: IErrorInfoBase[];
}

// type guard
function areDefinedPropertyErrors(propertyErrors: IPropertyErrors | undefined): propertyErrors is IPropertyErrors {
    return propertyErrors !== undefined;
}

export function addErrorIfNotExists(
    errorInfo: IErrorInfo,
    error: string,
    errorParams: IValidationMessageParameterDto[] | undefined,
    propertyName: string
): IErrorInfo {
    if (errorInfo && errorInfo.propertyErrors) {
        if (!errorInfo.propertyErrors[propertyName]) {
            errorInfo.propertyErrors[propertyName] = [];
        } else if (errorInfo.propertyErrors[propertyName].some((propertyError) => propertyError.error === error)) {
            return errorInfo;
        }
    }

    const params = (errorParams || []).map((p) => p.value as string);
    const lIds: number[] = [];
    (errorParams || []).forEach((p, i) => {
        if (p.isLocalizable) {
            lIds.push(i);
        }
    });

    const newError: IErrorInfo = {
        error: error,
        errorParameters: params,
        propertyErrors: {},
        localizableParametersIds: lIds,
        parametersLocalizations: {},
        errorType: "General",
    };

    if (errorInfo && errorInfo.propertyErrors) {
        errorInfo.propertyErrors[propertyName].push(newError);
    }

    return errorInfo;
}

export function isInValidableState<TComponentData extends IFormElementData<TValue, TParam>, TValue extends Validator.ValueType, TParam>(
    data: IData<TComponentData, TValue, TParam>
): boolean {
    if (data.validationDisabled) {
        return false;
    }
    return !data.preventDisabled || !data.componentData.isDisabled;
}

export function isPropertyInvalid(propertyName: string, errorInfo: IErrorInfo | undefined | null): boolean {
    return !!(
        errorInfo &&
        errorInfo.propertyErrors &&
        errorInfo.propertyErrors[propertyName] &&
        errorInfo.propertyErrors[propertyName].length
    );
}

export function getErrorInfoOrDefault(errorInfo?: IErrorInfo | null): IErrorInfo {
    return (
        errorInfo || {
            error: "There are validation errors",
            errorParameters: [],
            propertyErrors: {},
            localizableParametersIds: [],
            parametersLocalizations: {},
            errorType: "General",
        }
    );
}

export function isDirty(validationsCursor: flux.ICursor<IValidationsState>): boolean {
    const validationsState = flux.getState(validationsCursor);
    return isDirtyInner(validationsState);
}

export function isInvalid(validationsCursor: flux.ICursor<IValidationsState>): boolean {
    const validationsState = flux.getState(validationsCursor);
    return isInvalidInner(validationsState);
}

export function isInvalidOrNotValidatedYet(validationsCursor: flux.ICursor<IValidationsState>): boolean {
    const validationsState = flux.getState(validationsCursor);
    return !isDirtyInner(validationsState) || isInvalidInner(validationsState);
}

export function removeValidationError(validationsCursor: flux.ICursor<IValidationsState>, propertyName: string) {
    const validationsState = flux.getState(validationsCursor);
    if (
        validationsState.errorInfo &&
        validationsState.errorInfo.propertyErrors &&
        validationsState.errorInfo.propertyErrors[propertyName]
    ) {
        const errorInfo = deepErrorCopy(validationsState.errorInfo);
        if (areDefinedPropertyErrors(errorInfo.propertyErrors)) {
            delete errorInfo.propertyErrors[propertyName];
        }
        setValidations({
            cursor: validationsCursor,
            errorInfo:
                areDefinedPropertyErrors(errorInfo.propertyErrors) && Object.keys(errorInfo.propertyErrors).length === 0 ? null : errorInfo,
        });
    }
}

export interface IValidationStringData extends IValidationCursorFactoryParams {
    value: string;
}

export const removeValidationErrorsWithPrefix: flux.IAction<IValidationStringData> = flux.createAction<
    IValidationsState,
    IValidationStringData
>(dynamicValidationsCursorFactory, removeValidationErrorsWithPrefixHandler);

export function removeValidationErrorsWithPrefixHandler(
    validationsState: IValidationsState,
    data: IValidationStringData
): IValidationsState {
    if (validationsState.errorInfo && validationsState.errorInfo.propertyErrors) {
        const errorKeys = Object.keys(validationsState.errorInfo.propertyErrors);
        const errorKeysWithPrefix = errorKeys.filter((key) => startsWith(key, data.value));

        if (errorKeysWithPrefix) {
            const errorInfo = deepErrorCopy(validationsState.errorInfo);
            errorKeysWithPrefix.forEach((propertyName) => {
                if (errorInfo.propertyErrors) {
                    delete errorInfo.propertyErrors[propertyName];
                }
            });
            return setValidationsHandler(validationsState, { cursor: undefined, errorInfo: errorInfo });
        }
    }
    return validationsState;
}

export function revalidate<TValue extends Validator.ValueType>(
    cursor: flux.ICursor<IValidationsState>,
    value: TValue,
    propertyName: string,
    validationTypeEnum: IValidationTypeEnum
) {
    removeValidationError(cursor, propertyName);

    const validations = flux.getState(cursor);
    if (!validations.validationRules || !validations.validationRules.rules) {
        return;
    }

    let errorInfo = validations.errorInfo ? deepErrorCopy(validations.errorInfo) : undefined;

    const results = Validator.getPropertyResults(value, validations.validationRules.rules, propertyName, validationTypeEnum);

    if (results.length) {
        errorInfo = getErrorInfoOrDefault(errorInfo);
        results.forEach((result: Validator.IValidationResult) => {
            if (errorInfo) {
                errorInfo = addErrorIfNotExists(errorInfo, result.message, result.parameters, propertyName);
            }
        });
    }

    setValidations({ cursor, errorInfo });
}

// due to IE compatibility
function startsWith(text: string, searchText: string): boolean {
    if (text && searchText && text.length >= searchText.length) {
        return text.substr(0, searchText.length) === searchText;
    }
    return false;
}

function isDirtyInner(validationsState: IValidationsState): boolean {
    return validationsState.errorInfo !== undefined;
}

function isInvalidInner(validationsState: IValidationsState): boolean {
    if (!validationsState.errorInfo || !validationsState.errorInfo.propertyErrors) {
        return false;
    }

    return Object.keys(validationsState.errorInfo.propertyErrors).length > 0;
}
