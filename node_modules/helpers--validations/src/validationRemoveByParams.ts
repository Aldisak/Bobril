import * as b from "bobril";
import { IErrorInfo } from "./lib";

export declare type PropertyToClear = { startsWith?: string; endsWith?: string };
export interface IRemoveErrorsWithErrorKey {
    errorInfo: IErrorInfo | null | undefined;
    errorKeys?: string[] | string;
    properties?: PropertyToClear[] | PropertyToClear;
}

declare type KeysMap = { [key: string]: boolean };

// see unit tests to know how it works - removes property errors by error keys or properties (or all together)
export function removeValidationErrorsByParams(params: IRemoveErrorsWithErrorKey) {
    if (!params.errorInfo) {
        return;
    }
    const propErrors = params.errorInfo.propertyErrors;
    const errorKeysMap = getErrorKeysMap(params);
    const propertiesToClear = getArray(params.properties);

    if (propErrors) {
        for (const key in propErrors) {
            if (propErrors.hasOwnProperty(key)) {
                if (!isPropertyToClean(key, propertiesToClear)) {
                    continue;
                }
                if (errorKeysMap === undefined) {
                    // specific keys are not defined, remove them all
                    delete propErrors[key];
                } else {
                    const errorInfoBases = propErrors[key];
                    const newErrorInfoBases = [];
                    for (let i = 0; i < errorInfoBases.length; i++) {
                        const errorInfoBase = errorInfoBases[i];
                        if (!errorKeysMap[errorInfoBase.error]) {
                            newErrorInfoBases.push(errorInfoBase);
                        }
                    }

                    if (newErrorInfoBases.length) {
                        propErrors[key] = newErrorInfoBases;
                    } else {
                        delete propErrors[key];
                    }
                }
            }
        }
    }
}

function getErrorKeysMap(params: IRemoveErrorsWithErrorKey): KeysMap | undefined {
    if (params.errorKeys === undefined) {
        return undefined;
    }
    const errorKeysMap: KeysMap = {};
    for (const errorKey of getArray(params.errorKeys)) {
        if (errorKey) {
            errorKeysMap[errorKey] = true;
        }
    }
    return errorKeysMap;
}

function getArray<T>(value?: T | T[]): T[] {
    return value ? (b.isArray(value) ? value : [value]) : [];
}

function isPropertyToClean(property: string, propertiesToClear: PropertyToClear[]): boolean {
    if (propertiesToClear.length === 0) {
        return true;
    } // properties are not defined, try to clean all

    for (const propToClear of propertiesToClear) {
        const propStarts = propToClear.startsWith || "";
        const propEnds = propToClear.endsWith || "";
        const isStarts = property.substr(0, propStarts.length) === propStarts;
        const isEnds = property.substr(property.length - propEnds.length, propEnds.length) === propEnds;
        if (isStarts && isEnds) {
            return true;
        }
    }
    return false;
}
