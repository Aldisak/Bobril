import * as b from "bobril";
import { removeValidationErrorsByParams } from "./validationRemoveByParams";
import { IErrorInfo, addErrorIfNotExists } from "./lib";

// @TODO - better is return this message from BE
const ERROR_MESSAGE = "Value of the {0} field must be unique.";

export declare type Property<T> = IPropParams<T> | IPropParams<T>[];

export interface IPropParams<T> {
    getName: (index: number, item: T) => string;
    getValue: (item: T) => string | number | undefined;
    startsWith?: string; // if filled, it will clear just property that starts with this string
    endsWith?: string; // if filled, it will clear just property that ends with this string
}

export interface IRevalidateUniqueParams<T> extends IRevalidateUniqueBaseParams<T> {
    errorInfo?: IErrorInfo;
}

export interface IRevalidateUniqueBaseParams<T> {
    items: T[];
    property: Property<T>;
    errorCodesToClear?: string[]; // additional error codes to clear (default error code will be also cleared)
}

declare type ValuesPropsCache = Cache[];
declare type DuplicitListCache = ListCache[];
declare type Cache = { [value: string]: string[] };
declare type ListCache = { [value: string]: boolean };

interface IStore {
    valuesPropsCache: ValuesPropsCache; // cache with all used properties per each value to effective recognize duplicity
    duplicitListCache: DuplicitListCache; // cache with duplicit values per each property to create final errorInfo
    isDuplicitFound: boolean;
}

// TODO: improve performance?
// 2: validate just "on lost focus" not "not change" - should be the right way according to UX
export function revalidateUnique<T>(params: IRevalidateUniqueParams<T>): IErrorInfo | undefined {
    const propertiesToClear = b.isArray(params.property) ? params.property : [params.property];
    const store: IStore = {
        valuesPropsCache: [],
        duplicitListCache: [],
        isDuplicitFound: false,
    };

    removeValidationErrorsByParams({
        errorInfo: params.errorInfo,
        errorKeys: params.errorCodesToClear ? [ERROR_MESSAGE, ...params.errorCodesToClear] : [ERROR_MESSAGE],
        properties: propertiesToClear.map((prop) => ({ startsWith: prop.startsWith, endsWith: prop.endsWith })),
    });

    findDuplicates<T>(params.items, params.property, store);

    return store.isDuplicitFound ? getFinalErrorInfo<T>(params, store) : params.errorInfo;
}

function findDuplicates<T>(items: T[], propertyParam: Property<T>, store: IStore) {
    const properties = b.isArray(propertyParam) ? propertyParam : [propertyParam];
    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        for (let propIndex = 0; propIndex < properties.length; propIndex++) {
            const property = properties[propIndex];
            const value = property.getValue(item);
            const stringValue = value === undefined ? "" : "" + value;
            if (stringValue) {
                const propValues = getPropValueList(store.valuesPropsCache, propIndex, stringValue);
                propValues.push(property.getName(i, item));
                if (propValues.length > 1) {
                    store.isDuplicitFound = true;
                    const listCache = (store.duplicitListCache[propIndex] = store.duplicitListCache[propIndex] || {});
                    listCache[stringValue] = true;
                }
            }
        }
    }
}

function getFinalErrorInfo<T>(params: IRevalidateUniqueParams<T>, store: IStore): IErrorInfo {
    const errorInfo = tryCreateErrorInfo(params.errorInfo);
    for (let propIndex = 0; propIndex < store.duplicitListCache.length; propIndex++) {
        const duplicitListCache = store.duplicitListCache[propIndex];
        for (const duplicitValue in duplicitListCache) {
            if (duplicitListCache.hasOwnProperty(duplicitValue)) {
                for (const propertyName of getPropValueList(store.valuesPropsCache, propIndex, duplicitValue)) {
                    addErrorIfNotExists(
                        errorInfo,
                        ERROR_MESSAGE,
                        [{ value: getPropertyNameLastPart(propertyName), isLocalizable: true }],
                        propertyName
                    );
                }
            }
        }
    }
    return errorInfo;
}

function getPropertyNameLastPart(propertyName: string): string {
    const index = propertyName.lastIndexOf(".");
    return index ? propertyName.substr(index + 1) : propertyName;
}

function getPropValueList(cache: ValuesPropsCache, propCacheIndex: number, value: string): string[] {
    const propCache = (cache[propCacheIndex] = cache[propCacheIndex] || {});
    return (propCache[value] = propCache[value] || []);
}

function tryCreateErrorInfo(originalErrorInfo: IErrorInfo | undefined): IErrorInfo {
    return originalErrorInfo
        ? originalErrorInfo
        : {
              errorType: "Validation",
              error: "",
              propertyErrors: {},
          };
}
