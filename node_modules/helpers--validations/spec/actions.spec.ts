import { expectToBeMutated } from "helpers--jasmine";
import { getState, bootstrap, ICursor } from "bobflux";
import { IValidationsState, IValidationRulesDto } from "../src/lib";
import { IErrorInfo, IErrorInfoBase } from "../src/validationObjects";
import * as actions from "../src/actions/setValidations";
import * as resetValidations from "../src/actions/resetValidations";

const testValidationsCursor: ICursor<IValidationsState> = {
    key: "validations",
};

describe("appName", () => {
    beforeEach(() => {
        bootstrap({ validations: {} });
    });

    describe("actions", () => {
        describe("setValidations action", () => {
            it('sets the new value of "errorInfo" in state when it is not undefined ', () => {
                const state = getState(testValidationsCursor);

                const errorInfo: IErrorInfo = {
                    error: "",
                    propertyErrors: { ["error-key"]: [<IErrorInfoBase>{ error: "error" }] },
                    errorParameters: [],
                    localizableParametersIds: [],
                    parametersLocalizations: {},
                    errorType: "General",
                };

                actions.setValidations({
                    cursor: testValidationsCursor,
                    errorInfo,
                });

                actions.setValidations({
                    cursor: testValidationsCursor,
                    errorInfo: undefined,
                });

                const newState = getState(testValidationsCursor);
                expectToBeMutated(newState, state);
                expect(newState.errorInfo).toEqual(errorInfo);
            });

            it('sets the new value of "errorInfo" in state when it is not undefined', () => {
                const state = getState(testValidationsCursor);

                const validationRules: IValidationRulesDto = { rules: {} };

                actions.setValidations({
                    cursor: testValidationsCursor,
                    validationRules,
                });

                actions.setValidations({
                    cursor: testValidationsCursor,
                    validationRules: undefined,
                });

                const newState = getState(testValidationsCursor);
                expectToBeMutated(newState, state);
                expect(newState.validationRules).toEqual(validationRules);
            });
        });

        describe("resetValidations action", () => {
            it('set "errorInfo" and "validationRules" to undefined on resetValidations', () => {
                const errorInfo: IErrorInfo = {
                    error: "",
                    propertyErrors: { ["error-key"]: [<IErrorInfoBase>{ error: "error" }] },
                    errorParameters: [],
                    localizableParametersIds: [],
                    parametersLocalizations: {},
                    errorType: "General",
                };

                actions.setValidations({
                    cursor: testValidationsCursor,
                    errorInfo,
                });

                const state = getState(testValidationsCursor);

                resetValidations.resetValidations(testValidationsCursor);

                const newState = getState(testValidationsCursor);
                expectToBeMutated(newState, state);
                expect(newState.errorInfo).toEqual(null);
                expect(newState.validationRules).toEqual(undefined);
            });
        });
    });
});
