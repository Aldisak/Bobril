import { revalidateUnique, IErrorInfo, getErrorInfoOrDefault } from "../src/lib";
import * as RemoveByParamsScope from "../src/validationRemoveByParams";

interface IItem {
    name: string;
    subindex: number;
    gender: Gender;
    value: number;
}

enum Gender {
    Man,
    Woman,
}

const ERROR_UNIQUE_MESSAGE = "Value of the {0} field must be unique.";
const ERROR_UNIQUE = { error: ERROR_UNIQUE_MESSAGE };
const ERROR_SOME = { error: "some error" };

describe("validations unique", () => {
    let errorInfo: IErrorInfo;
    let items: IItem[] = [];

    beforeEach(() => {
        errorInfo = getErrorInfoOrDefault();
        items = [
            { name: "Carl", subindex: 0, gender: Gender.Man, value: 2 },
            { name: "Emma", subindex: 0, gender: Gender.Woman, value: 4 },
            { name: "Sophia", subindex: 1, gender: Gender.Woman, value: 8 },
            { name: "Dylan", subindex: 1, gender: Gender.Man, value: 6 },
        ];
    });

    it("should has no duplicates", () => {
        items[1].name = "Carl_one";
        revalidateUnique({
            errorInfo,
            items,
            property: { getName: (i) => `People[${i}].Name`, getValue: (item) => item.name },
        });

        expect(errorInfo.propertyErrors).toBeDefined();
        expect(errorInfo.propertyErrors!).toEqual({});
    });

    it("should mark 'Carl' as duplicate", () => {
        items[3].name = "Carl";
        revalidateUnique({
            errorInfo,
            items,
            property: { getName: (i) => `People[${i}].Name`, getValue: (item) => item.name },
        });

        expect(errorInfo.propertyErrors).toBeDefined();
        expect(errorInfo.propertyErrors!).toEqual({
            "People[0].Name": [getError("Name")],
            "People[3].Name": [getError("Name")],
        });
    });

    it("should mark 'Emma' as duplicate", () => {
        items[0].name = "Emma";
        revalidateUnique({
            errorInfo,
            items,
            property: { getName: (i) => `People[${i}].Name`, getValue: (item) => item.name },
        });

        expect(errorInfo.propertyErrors).toBeDefined();
        expect(errorInfo.propertyErrors!).toEqual({
            "People[0].Name": [getError("Name")],
            "People[1].Name": [getError("Name")],
        });
    });

    it("should mark duplicit for more properties on single item list", () => {
        items[1].name = items[0].name;
        items[2].value = items[1].value;

        revalidateUnique({
            errorInfo,
            items,
            property: [
                { getName: (i) => `List[${i}].Name`, getValue: (item) => item.name },
                { getName: (i) => `List[${i}].Value`, getValue: (item) => item.value },
            ],
        });

        expect(errorInfo.propertyErrors).toBeDefined();
        expect(errorInfo.propertyErrors!).toEqual({
            "List[0].Name": [getError("Name")],
            "List[1].Name": [getError("Name")],
            "List[1].Value": [getError("Value")],
            "List[2].Value": [getError("Value")],
        });
    });

    it("should mark duplicit by group with subindex on single list", () => {
        items[1].name = "Sophia";
        revalidateUnique({
            errorInfo,
            items,
            property: [
                {
                    getName: (_i, item) => `Men[${item.subindex}].Name`,
                    getValue: (item) => (item.gender === Gender.Man ? item.name : ""),
                },
                {
                    getName: (_i, item) => `Women[${item.subindex}].Name`,
                    getValue: (item) => (item.gender === Gender.Woman ? item.name : ""),
                },
            ],
        });

        expect(errorInfo.propertyErrors).toBeDefined();
        expect(errorInfo.propertyErrors!).toEqual({
            "Women[0].Name": [getError("Name")],
            "Women[1].Name": [getError("Name")],
        });
    });

    describe("clear validation messages before unique validations", () => {
        beforeEach(() => {
            spyOn(RemoveByParamsScope, "removeValidationErrorsByParams").and.callThrough();
            errorInfo.propertyErrors = {
                "List[0].Name": [ERROR_UNIQUE, ERROR_SOME],
                "List[1].Name": [ERROR_UNIQUE],
                "List[1].Value": [ERROR_UNIQUE],
                "List[2].Value": [ERROR_UNIQUE],
                "List[3].Value": [ERROR_SOME],
                Name: [ERROR_SOME],
            };
        });

        it("should call clear all errors with unique message", () => {
            revalidateUnique({
                errorInfo,
                items,
                property: { getName: (i) => `List[${i}].Name`, getValue: (item) => item.name },
            });

            expect(RemoveByParamsScope.removeValidationErrorsByParams).toHaveBeenCalledWith({
                errorInfo,
                errorKeys: [ERROR_UNIQUE_MESSAGE],
                properties: [{ startsWith: undefined, endsWith: undefined }],
            });
        });

        it("should clear just List* properties (startsWith)", () => {
            revalidateUnique({
                errorInfo,
                items,
                property: { getName: (i) => `List[${i}].Name`, getValue: (item) => item.name, startsWith: "List[" },
            });

            expect(RemoveByParamsScope.removeValidationErrorsByParams).toHaveBeenCalledWith({
                errorInfo,
                errorKeys: [ERROR_UNIQUE_MESSAGE],
                properties: [{ startsWith: "List[", endsWith: undefined }],
            });
        });

        it("should clear just List*Name properties (startsWith, endsWith)", () => {
            revalidateUnique({
                errorInfo,
                items,
                property: { getName: (i) => `List[${i}].Name`, getValue: (item) => item.name, startsWith: "List[", endsWith: "].Name" },
            });

            expect(RemoveByParamsScope.removeValidationErrorsByParams).toHaveBeenCalledWith({
                errorInfo,
                errorKeys: [ERROR_UNIQUE_MESSAGE],
                properties: [{ startsWith: "List[", endsWith: "].Name" }],
            });
        });

        it("should clear just List*Name and List*Value properties (startsWith, endsWith)", () => {
            revalidateUnique({
                errorInfo,
                items,
                property: [
                    { getName: (i) => `List[${i}].Name`, getValue: (item) => item.name, startsWith: "List[", endsWith: "].Name" },
                    { getName: (i) => `List[${i}].Value`, getValue: (item) => item.name, startsWith: "List[", endsWith: "].Value" },
                ],
            });

            expect(RemoveByParamsScope.removeValidationErrorsByParams).toHaveBeenCalledWith({
                errorInfo,
                errorKeys: [ERROR_UNIQUE_MESSAGE],
                properties: [
                    { startsWith: "List[", endsWith: "].Name" },
                    { startsWith: "List[", endsWith: "].Value" },
                ],
            });
        });

        it("should clear additionally defined error code", () => {
            revalidateUnique({
                errorInfo,
                items,
                errorCodesToClear: ["some extra error code that I want to clear"],
                property: [
                    { getName: (i) => `List[${i}].Name`, getValue: (item) => item.name, startsWith: "List[", endsWith: "].Name" },
                    { getName: (i) => `List[${i}].Value`, getValue: (item) => item.name, startsWith: "List[", endsWith: "].Value" },
                ],
            });

            expect(RemoveByParamsScope.removeValidationErrorsByParams).toHaveBeenCalledWith({
                errorInfo,
                errorKeys: [ERROR_UNIQUE_MESSAGE, "some extra error code that I want to clear"],
                properties: [
                    { startsWith: "List[", endsWith: "].Name" },
                    { startsWith: "List[", endsWith: "].Value" },
                ],
            });
        });
    });
});

function getError(errorParameter: string): IErrorInfo {
    return {
        error: "Value of the {0} field must be unique.",
        errorParameters: [errorParameter],
        localizableParametersIds: [0],
        propertyErrors: {},
        errorType: "General",
        parametersLocalizations: {},
    };
}
