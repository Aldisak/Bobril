import * as setValidationsScope from "../src/actions/setValidations";
import { bootstrap, ICursor } from "bobflux";
import { ApiMock, ApiSyncCallMockSpy, SpyWrapper } from "helpers--jasmine";
import {
    validationRulesCacheFactory,
    IValidationRulesCache,
    IValidationsState,
    IValidationRulesDto,
    IApiWithQueryValidationRules,
    IErrorInfo,
} from "../src/lib";
import { IPromiseWithTypedError } from "helpers--promise";

const testApi: IApiWithQueryValidationRules = {
    queryValidationRules: (_validationObjectTypeEnum): IPromiseWithTypedError<IValidationRulesDto, IErrorInfo> => {
        return <IPromiseWithTypedError<IValidationRulesDto, IErrorInfo>>{};
    },
};

export class TestApiMock extends ApiMock<IApiWithQueryValidationRules> {
    constructor() {
        super();
        this.withSyncCallMockSpy(() => testApi.queryValidationRules);
    }
    queryValidationRules(): ApiSyncCallMockSpy<IValidationRulesDto> {
        return this.getSpy(() => testApi.queryValidationRules);
    }
}

describe("validationRulesCache", () => {
    const testValidationsCursor: ICursor<IValidationsState> = { key: "validations" };
    let testApiMock: TestApiMock;
    let setValidationsSpy: SpyWrapper;
    let validationRulesCache: IValidationRulesCache;

    beforeEach(() => {
        bootstrap({ validations: {} });
        testApiMock = new TestApiMock();
        setValidationsSpy = SpyWrapper.create(setValidationsScope, (scope) => scope.setValidations);
        validationRulesCache = validationRulesCacheFactory(45);
    });

    it("calls query on given api at the first time", () => {
        validationRulesCache.getValidations(testValidationsCursor, testApiMock.get(), "test");
        expect(testApiMock.queryValidationRules().spy).toHaveBeenCalled();
    });

    it("doesn't call query on given api for the second time", () => {
        validationRulesCache.getValidations(testValidationsCursor, testApiMock.get(), "test");
        testApiMock.queryValidationRules().spy.calls.reset();
        validationRulesCache.getValidations(testValidationsCursor, testApiMock.get(), "test");
        expect(testApiMock.queryValidationRules().spy).not.toHaveBeenCalled();
    });

    it("sets validations to state on given cursor by setValidations action", () => {
        setValidationsSpy.init();
        validationRulesCache.getValidations(testValidationsCursor, testApiMock.get(), "test");
        expect(setValidationsSpy.spy).not.toHaveBeenCalled();

        const result = <IValidationRulesDto>{ rules: {} };
        testApiMock.queryValidationRules().resolve(result);

        expect(setValidationsSpy.spy).toHaveBeenCalledWith({ cursor: testValidationsCursor, validationRules: result });
    });

    it("calls 'onError' callback on reject query way", () => {
        setValidationsSpy.init();
        const error = { error: "some error" };
        const onError = jasmine.createSpy("onError");

        validationRulesCache.getValidations(testValidationsCursor, testApiMock.get(), "test", onError);
        testApiMock.queryValidationRules().reject(error);

        expect(onError).toHaveBeenCalledWith(error);
    });

    it("expires loaded particular validation rules on given expiration period", () => {
        jasmine.clock().install();
        validationRulesCache.getValidations(testValidationsCursor, testApiMock.get(), "test");
        testApiMock.queryValidationRules().spy.calls.reset();

        jasmine.clock().tick(45 * 60 * 1000 - 1);
        validationRulesCache.getValidations(testValidationsCursor, testApiMock.get(), "test");
        expect(testApiMock.queryValidationRules().spy).not.toHaveBeenCalled();

        jasmine.clock().tick(1);
        validationRulesCache.getValidations(testValidationsCursor, testApiMock.get(), "test");
        expect(testApiMock.queryValidationRules().spy).toHaveBeenCalled();
    });

    afterEach(() => {
        setValidationsSpy.release();
    });
});
