export * from "./assets";
import * as b from "bobril";
import * as FormElements from "bobwai--form-elements";
import * as s from "./styles";
import * as d from "./data";
import * as Constants from "./publicConstants";
import * as Color from "bobwai--color";
import * as Icon from "bobwai--icon";
import * as StateIcon from "bobwai--state-icon";
import * as TooltipEmplacer from "bobwai--tooltip-emplacer";
import * as rtlTextHelper from "helpers--rtl-text";
import * as WebAccessibility from "helpers--web-content-accessibility";
import {tryToSetSizeAccordingFormContext} from 'helpers--form-context';

const hexaColorAllowedKeys: RegExp = new RegExp("[#0-9a-fA-F]");

interface IContext extends b.IBobrilCtx {
    data: d.IData;
    hasFocus: boolean;
    inputComponent: {
        onChange(ctx: b.IBobrilCtx, value: string): void;
    };
    value: string;
    lastValueInData?: string;
    isHover: boolean;
    isReveal: boolean;
    changeDelayTimeout?: any;
    element?: HTMLElement;
    size?: d.Size;
}

export * from "./data";
export * from "./publicConstants";
import { OnChangeDefaultDelay } from "bobwai--form-elements";

namespace localVariables {
    export const timeout = OnChangeDefaultDelay;
}

export let create = b.createComponent<d.IData>({
    id: "bobwai--textbox",
    init(ctx: IContext) {
        ctx.hasFocus = false;
        ctx.value = "";
        ctx.lastValueInData = undefined;
        ctx.changeDelayTimeout = undefined;
        ctx.inputComponent = {
            onChange(_cx: b.IBobrilCtx, v: string) {
                onChange(ctx, v);
            },
        };
    },

    render(ctx: IContext, me: b.IBobrilNode) {
        b.style(me, getWrapperStyle(ctx, ctx.hasFocus));
        tryToSetSizeAccordingFormContext({ctx, reducedVariantEnumValue: d.Size.Small});
        specifyValueForRender(ctx);
        me.children = b.style({
            children: [
                ctx.data.isDisabled &&
                    ctx.data.value &&
                    !isPasswordType(ctx.data) &&
                    ctx.data.isTooltipHiddenInDisabledState !== true &&
                    createTooltipWithOverlay(ctx.data.value),
                createTextbox(ctx),
                ctx.data.type === d.Type.PasswordWithRevealButton && ctx.data.value && !ctx.data.isDisabled && createReveal(ctx),
                ctx.data.rightIcon && createIconRight(ctx),
                isError(ctx.data) && createErrorIcon(ctx),
            ],
        });

        if (!ctx.hasFocus && ctx.data.forceFocus) {
            setFocusManually(ctx);
        }
    },

    onFocusIn(ctx: IContext) {
        if (ctx.data.isDisabled && b.ieVersion()) {
            return;
        }
        ctx.hasFocus = true;
        if (ctx.data.withSelectedTextOnFocus && ctx.element) {
            let inputElement = getInput(ctx.element);
            if (inputElement) {
                inputElement.select();
            }
        }
        if (ctx.data.onFocusIn) ctx.data.onFocusIn(ctx);
        b.invalidate(ctx);
    },

    onFocusOut(ctx: IContext) {
        ctx.hasFocus = false;
        if (ctx.data.onFocusOut) ctx.data.onFocusOut(ctx);
        if (ctx.data.onChange && ctx.data.isOnChangeWithDelay && ctx.changeDelayTimeout !== undefined) {
            clearChangeDelayTimeout(ctx);
            ctx.data.onChange(ctx.value);
        }
        b.invalidate(ctx);
    },

    onKeyDown(ctx: IContext, event: b.IKeyDownUpEvent) {
        if (ctx.data.onKeyDown) {
            return ctx.data.onKeyDown(event.which);
        }
        return false;
    },

    onKeyPress(ctx: IContext, event: b.IKeyPressEvent): boolean {
        if (ctx.data.type === d.Type.HexaColor) {
            if (event.charCode === 8) return false; // onKeyPress is calling in FF on backspace down.
            return !isCharAllowedInHexaCodeFormat(String.fromCharCode(event.charCode));
        }
        if (ctx.data.onKeyPress) {
            return ctx.data.onKeyPress(event.charCode);
        }
        return false;
    },

    onClick(ctx: IContext): boolean {
        if (ctx.data.type === d.Type.Search && !ctx.hasFocus) setFocusManually(ctx);
        return !!ctx.data.onClick && ctx.data.onClick();
    },

    postInitDom(ctx: IContext, _me: b.IBobrilCacheNode, element: HTMLElement) {
        if (ctx.data.withInitiallySelectedText || (ctx.data.initState && ctx.data.initState === d.InitState.selectedText)) {
            setFocusManually(ctx, true);
            let inputElemet = getInput(element);
            if (inputElemet) {
                inputElemet.select();
            }
        } else if (ctx.data.initState === d.InitState.focused) {
            setFocusManually(ctx);
        }
        ctx.element = element;
    },

    postUpdateDom(ctx: IContext, _me: b.IBobrilCacheNode, element: HTMLElement) {
        if (ctx.hasFocus && ctx.data.forceBlur && element && element.children[0]) {
            (<HTMLElement>element.children[0]).blur();
        }
        ctx.element = element;
    },
    shouldStopBubble(ctx: IContext, name: string) {
        return (name === "onKeyDown" && !!ctx.data.shouldStopOnKeyDownBubble) || (name === "onClick" && !!ctx.data.shouldStopOnClickBubble);
    },
});

function isPasswordType(data: d.IData): boolean {
    return data.type === d.Type.Password || data.type === d.Type.PasswordWithRevealButton;
}

function getInput(element: HTMLElement): HTMLInputElement | undefined {
    return <HTMLInputElement>element.getElementsByTagName("input")[0];
}

// needed for edge
function createTooltipWithOverlay(value: string) {
    return TooltipEmplacer.create({
        content: b.styledDiv(null, s.tooltipOverlayStyle),
        tooltipMessage: value,
    });
}

function onChange(ctx: IContext, v: string) {
    ctx.value = v;
    if (ctx.data.isOnChangeWithDelay === true) {
        clearChangeDelayTimeout(ctx);

        ctx.changeDelayTimeout = setTimeout(() => ctx.data.onChange(v), localVariables.timeout);
    } else {
        ctx.data.onChange(v);
    }
}

function specifyValueForRender(ctx: IContext) {
    if (ctx.data.isOnChangeWithDelay === true) {
        if (ctx.lastValueInData !== ctx.data.value) {
            ctx.lastValueInData = ctx.data.value;
            clearChangeDelayTimeout(ctx);
            setValueFromData(ctx);
        }
    } else {
        setValueFromData(ctx);
    }
}

function clearChangeDelayTimeout(ctx: IContext) {
    if (ctx.changeDelayTimeout !== undefined) {
        clearTimeout(ctx.changeDelayTimeout);
    }
}

function setValueFromData(ctx: IContext) {
    if (ctx.data.value !== undefined) {
        ctx.value = ctx.data.value;
    }
}

function createTextbox(ctx: IContext): b.IBobrilChildren {
    const input = b.style(
        {
            tag: "input",
            attrs: {
                autocomplete: ctx.data.autocomplete === d.Autocomplete.NewPassword && "new-password",
                type: isPasswordType(ctx.data) && !ctx.isReveal ? "password" : "text",
                value: ctx.value !== null ? ctx.value : "",
                placeholder: ctx.data.isReadOnly === true ? "" : ctx.data.placeholder,
                disabled: ctx.data.isDisabled && "disabled",
                readOnly: ctx.data.isReadOnly || ctx.data.isReadOnlyWithBorder,
                maxLength: ctx.data.maxLength,
            },
            data: ctx.data,
            component: ctx.inputComponent,
        },
        getInputStyle(ctx),
        rtlTextHelper.getRtlTextStyles({
            enableRTL: Constants.EnableRTL,
            text: ctx.value,
        })
    );

    const accessibility = setWebAccessibilityIfNeeded(input, ctx.data);

    return [input, accessibility?.validationMessageNodeId && WebAccessibility.tryToGetAccessibleValidationMessageNode(accessibility)];
}

function setWebAccessibilityIfNeeded(input: b.IBobrilNode, data: d.IData): WebAccessibility.IWebContentAccessibility | undefined {
    let accessibility: WebAccessibility.IWebContentAccessibility = {};
    if (data.validationState === FormElements.ValidationState.Error) {
        accessibility.validationState = WebAccessibility.ContentAccessibilityValidationState.Invalid;
    }
    if (data.webContentAccessibility) {
        accessibility = b.assign(accessibility, data.webContentAccessibility);
    }
    if (Object.keys(accessibility).length !== 0) {
        WebAccessibility.setWebContentAccessibilityAttributes(input, accessibility);
        return accessibility;
    }
    return undefined;
}

let revealIcon = Icon.create({ sprite: b.sprite(Icon.preview_small_png, Color.Basic) });

let revealHoverIcon = Icon.create({ sprite: b.sprite(Icon.preview_small_png, Color.Application) });

let errorIcon = Icon.create({ sprite: b.sprite(Icon.exclamation_small_png, Color.Error) });

function createReveal(ctx: IContext): b.IBobrilNode {
    return b.style(
        {
            tag: "div",
            children: ctx.isHover ? b.styledDiv(revealHoverIcon, s.revealIconStyle) : b.styledDiv(revealIcon, s.revealIconStyle),
            component: {
                onMouseDown: (): boolean => {
                    ctx.isReveal = true;
                    b.invalidate(ctx);
                    return true;
                },
                onMouseUp: (): boolean => {
                    ctx.isReveal = false;
                    b.invalidate(ctx);
                    return true;
                },
                onMouseEnter: (): boolean => {
                    ctx.isHover = true;
                    b.invalidate(ctx);
                    return true;
                },
                onMouseLeave: (): boolean => {
                    ctx.isHover = false;
                    ctx.isReveal = false;
                    b.invalidate(ctx);
                    return true;
                },
            },
        },
        s.rightStyle,
        isSmall(ctx) && s.rightStyleWithSmallSize,
        ctx.data.size === d.Size.XSmall && s.rightStyleWithXSmallSize
    );
}

function createErrorIcon(ctx: IContext): b.IBobrilNode | undefined {
    if (hasSiblings(ctx.data)) return undefined;

    let errorIconContent = b.styledDiv(errorIcon, s.errorIconContentStyle);
    return b.styledDiv(
        errorIconContent,
        s.errorIconStyle,
        isSmall(ctx) && s.errorIconWithSmallSizeStyle,
        ctx.data.size === d.Size.XSmall && s.errorIconWithXSmallSizeStyle
    );
}

function createIconRight(ctx: IContext): b.IBobrilNode | undefined {
    if (ctx.data.rightIcon === undefined) {
        return;
    }

    const ri = ctx.data.rightIcon;

    if (ri.onClick) {
        return b.styledDiv(
            StateIcon.create({
                content: ri.icon,
                hoverContent: ri.iconHover,
                tooltip: ri.tooltip,
                onClick: () => {
                    ri.onClick!();
                    return true;
                },
            }),
            [s.rightStyle, isSmall(ctx) && s.rightStyleWithSmallSize, ctx.data.size === d.Size.XSmall && s.rightStyleWithXSmallSize]
        );
    } else {
        return {
            tag: "div",
            children: b.styledDiv(
                TooltipEmplacer.create({
                    content: ri.icon,
                    tooltipHeader: ri.tooltip && ri.tooltip.tooltipHeader,
                    tooltipMessage: ri.tooltip && ri.tooltip.tooltipMessage,
                }),
                [s.rightStyle, isSmall(ctx) && s.rightStyleWithSmallSize, ctx.data.size === d.Size.XSmall && s.rightStyleWithXSmallSize]
            ),
            component: {
                onMouseDown: () => {
                    if (ctx.me) {
                        b.focus(ctx.me);
                    }
                    return true;
                },
            },
        };
    }
}

function isError(data: d.IData): boolean {
    return data.validationState === FormElements.ValidationState.Error;
}

function setFocusManually(ctx: IContext, withInitiallySelectedText?: boolean) {
    ctx.hasFocus = true;
    // setTimeout workaround for chrome, firefox.
    setTimeout(function () {
        if (ctx.element !== undefined) {
            let inputElement = getInput(ctx.element);
            if (inputElement) {
                if (withInitiallySelectedText) inputElement.select();
                else inputElement.selectionStart = inputElement.value.length;
            }
        }
        b.focus(ctx.me);
    }, 0);
    b.invalidate(ctx);
}

function getWrapperStyle(ctx: IContext, hasFocus: boolean): b.IBobrilStyles[] {
    const data = ctx.data;
    return [
        s.wrapperStyle,
        s.getBorderRadius(disableLeftBorderRadius(data), disableRightBorderRadius(data)),
        s.getTransparentBorders(data, hasFocus),
        isSmall(ctx) && s.wrapperSmallSizeStyle,
        data.size === d.Size.XSmall && s.wrapperXSmallSizeStyle,
        isError(data) && !hasSiblings(data) && s.wrapperWithErrorIconStyle,
        getWrapperTypeStyle(data, hasFocus),
        shouldHaveFocusStyle(hasFocus, data.validationState) &&
            !data.isReadOnlyWithBorder && [s.focusedStyle, data.customFocusBorderColor && { borderColor: data.customFocusBorderColor }],
        data.isReadOnly && s.wrapperReadOnlyStyle,
    ];
}

function disableLeftBorderRadius(data: d.IData): boolean {
    return (
        data.isDisabledBorderRadiusLeftSide ||
        data.siblingType === FormElements.SiblingType.Left ||
        data.siblingType === FormElements.SiblingType.Both
    );
}

function disableRightBorderRadius(data: d.IData): boolean {
    return (
        data.isDisabledBorderRadiusRightSide ||
        data.siblingType === FormElements.SiblingType.Right ||
        data.siblingType === FormElements.SiblingType.Both
    );
}

function shouldHaveFocusStyle(hasFocus: boolean, state?: FormElements.ValidationState): boolean {
    return hasFocus && state !== FormElements.ValidationState.Error && state !== FormElements.ValidationState.Warning;
}

function getWrapperTypeStyle(data: d.IData, hasFocus: boolean): b.IBobrilStyles[] {
    return [
        isError(data) && s.invalidStyle.wrapper,
        data.validationState === FormElements.ValidationState.Warning && s.warningStyle.wrapper,
        data.isDisabled && s.disabledStyle.wrapper,
        data.type === d.Type.Search && hasFocus && s.searchWrapperFocusedStyle,
        data.type === d.Type.Search && !hasFocus && s.searchWrapperStyle,
        canBeHighlighted(data) && s.highlightedStyle,
    ];
}

function getInputStyle(ctx: IContext): b.IBobrilStyles[] {
    return [
        s.inputStyle,
        isSmall(ctx) && s.inputStyleSmall,
        ctx.data.size === d.Size.XSmall && s.inputStyleXSmall,
        ctx.data.textAlign === FormElements.TextAlign.Center && s.centerStyle,
        getInputTypeStyle(ctx),
    ];
}

function isSmall(ctx: IContext): boolean {
    return ctx.data.size === d.Size.Small || ctx.size === d.Size.Small;
}

function getInputTypeStyle(ctx: IContext): b.IBobrilStyles[] {
    const data = ctx.data;
    return [
        isError(data) && s.invalidStyle.input,
        data.validationState === FormElements.ValidationState.Warning && s.warningStyle.input,
        data.isDisabled && s.disabledStyle.input,
        ((data.type === d.Type.PasswordWithRevealButton && !data.isDisabled) || data.rightIcon !== undefined) &&
            (isSmall(ctx)
                ? s.inputWithIconStyleSmall
                : data.size === d.Size.XSmall
                ? s.inputWithIconStyleXSmall
                : s.inputWithIconStyle),
        data.isReadOnly && s.inputReadOnlyStyle,
    ];
}

function canBeHighlighted(data: d.IData): boolean {
    return (
        !!data.isHighlighted &&
        !data.isDisabled &&
        data.validationState !== FormElements.ValidationState.Error &&
        data.validationState !== FormElements.ValidationState.Warning
    );
}

function isCharAllowedInHexaCodeFormat(value: string) {
    return hexaColorAllowedKeys.test(value);
}

function hasSiblings(data: d.IData): boolean {
    return data.siblingType !== undefined && data.siblingType !== FormElements.SiblingType.None;
}

// added by script - BEGIN
export const Textbox = create;
// added by script - END
