import * as b from "bobril";
import * as Color from "bobwai--color";
import * as Font from "bobwai--font";
import * as FormElements from "bobwai--form-elements";
import * as Mixins from "bobwai--style-mixins";
import * as textboxAssets from "./assets";
import * as d from "./data";

const inputIndent = 3;
const height = 35;
const smallHeight = 24;
const xSmallHeight = 20;
const leftPadding = 12 - inputIndent;
const rightPadding = 12;
const leftSmallPadding = 6 - inputIndent;
const rightSmallPadding = 6;
const searchLeftPadding = 44 - inputIndent;
const borderRadius = 2;
const borderSize = 1;

const minHeight = 33;
const smallMinHeight = 22;
const xSmallMinHeight = 18;
const rightContent = 0;
const rightContentTop = 0;
const paddingRight = 7;
const paddingRightSmall = 1;
const paddingLeft = 7;

const rightContentWidth = 34;
const rightContentSmallWidth = 28;

const color = Color.Basic;
const borderColor = Color.Grey300;
const background = Color.White;
const placeholderColor = Color.Grey500;

const warningColor = Color.Warning;
const warningBackground = Color.Warning_05_solid;
const invalidColor = Color.Error;
const invalidBackground = Color.Error_05_solid;
const disabledColor = Color.Grey500;
const disabledBackground = Color.Grey100;

const heightWithoutBorders = height - 2 * borderSize;
const smallHeightWithoutBorders = smallHeight - 2 * borderSize;
const xSmallHeightWithoutBorders = xSmallHeight - 2 * borderSize;

export const errorIconRight = -Mixins.ValidationError.errorIconWidth - 1;
export const errorIconWidth = Mixins.ValidationError.errorIconWidth;
export const errorIconTop = -1;
export const errorIconTopWithSmallSize = -5;
export const errorIconTopWithXSmallSize = -8;

export const wrapperStyle = b.styleDef(
    {
        position: "relative",
        border: `${borderSize}px solid ${borderColor}`,
        height: heightWithoutBorders,
        lineHeight: "normal",
        background: background,
        fontWeight: Font.FontWeightRegular,
    },
    {},
    "textbox"
);

export function getBorderRadius(disableLeftSide?: boolean, disableRightSide?: boolean) {
    return {
        borderTopLeftRadius: disableLeftSide ? 0 : borderRadius,
        borderTopRightRadius: disableRightSide ? 0 : borderRadius,
        borderBottomLeftRadius: disableLeftSide ? 0 : borderRadius,
        borderBottomRightRadius: disableRightSide ? 0 : borderRadius,
    };
}

export const wrapperSmallSizeStyle = b.styleDefEx(
    wrapperStyle,
    {
        height: smallHeightWithoutBorders,
    },
    {},
    "textbox-small"
);

export const wrapperXSmallSizeStyle = b.styleDefEx(
    wrapperStyle,
    {
        height: xSmallHeightWithoutBorders,
        borderRadius: 0,
    },
    {},
    "textbox-xsmall"
);

export const wrapperReadOnlyStyle = b.styleDefEx(
    wrapperStyle,
    {
        border: "none",
        paddingLeft: 0,
        paddingRight: 0,
    },
    {},
    "textbox-read-only"
);

export const wrapperWithErrorIconStyle = b.styleDefEx(
    wrapperStyle,
    {
        marginRight: errorIconWidth,
    },
    {},
    "textbox-with-error-icon"
);

const inputBaseStyle = b.styleDef(
    {
        height: heightWithoutBorders,
        color: color,
        backgroundColor: "transparent",
        outline: "none",
        width: "100%",
        padding: 0,
        paddingLeft: leftPadding,
        paddingRight: rightPadding,
        textIndent: inputIndent,
        margin: 0,
        border: 0,
        boxSizing: "border-box",
    },
    {
        ":-ms-clear": {
            display: "none",
        },
        ":-ms-reveal": {
            display: "none",
        },
    }
);

const inputBaseStyleSmall = b.styleDefEx(inputBaseStyle, {
    height: smallHeightWithoutBorders,
    paddingLeft: leftSmallPadding,
    paddingRight: rightSmallPadding,
});

const inputBaseStyleXSmall = b.styleDefEx(inputBaseStyle, {
    height: xSmallHeightWithoutBorders,
    paddingLeft: leftSmallPadding,
    paddingRight: rightSmallPadding,
    display: "block",
});

export const inputStyle = b.styleDef(
    [inputBaseStyle],
    Mixins.createPlaceholderStyle({
        color: placeholderColor,
        fontStyle: "italic",
    }),
    "input"
);

export const inputStyleSmall = b.styleDefEx(inputStyle, [inputBaseStyleSmall], {}, "input-small");

export const inputStyleXSmall = b.styleDefEx(inputStyle, [inputBaseStyleXSmall], {}, "input-xsmall");

export const centerStyle = b.styleDefEx(inputStyle, {
    textAlign: "center",
});

export const inputWithIconStyle = b.styleDefEx(inputStyle, {
    paddingRight: rightContentWidth,
});

export const inputWithIconStyleSmall = b.styleDefEx(inputStyleSmall, {
    paddingRight: rightContentSmallWidth,
});

export const inputWithIconStyleXSmall = b.styleDefEx(inputStyleXSmall, {
    paddingRight: rightContentSmallWidth,
});

export const inputReadOnlyStyle = b.styleDefEx(inputStyle, {
    textIndent: 0,
    fontWeight: Font.FontWeightSemibold,
});

export const invalidStyle = {
    wrapper: colorizeWrapper(invalidColor, invalidBackground, "wrapper-is-invalid"),
    input: colorizeInput(invalidColor, "input-is-invalid"),
};

export const warningStyle = {
    wrapper: colorizeWrapper(warningColor, warningBackground, "wrapper-is-warning"),
    input: colorizeInput(warningColor, "input-is-warning"),
};

export const disabledStyle = {
    wrapper: b.styleDef({ backgroundColor: disabledBackground }, {}, "wrapper-is-disabled"),
    input: b.styleDef({ color: disabledColor, opacity: 1, textFillColor: Color.Grey500 }, {}, "input-is-disabled"),
};

export const focusedStyle = b.styleDef({ borderColor: Color.Application }, {}, "is-focused");

export const highlightedStyle = b.styleDef({ borderColor: Color.Application }, {}, "is-highlighted");

const spriteSearchIconStyle = b.sprite(textboxAssets.textbox_icon_search_png);
const spriteSearchHoverIconStyle = b.sprite(textboxAssets.textbox_icon_search_hover_png);

const searchBeforeBaseStyle = {
    content: "",
    display: "inline-block",
    left: leftPadding,
    position: "absolute",
    margin: "auto 0",
    bottom: 0,
    top: 0,
};

export const searchWrapperStyle = b.styleDef(
    { paddingLeft: searchLeftPadding },
    { before: [searchBeforeBaseStyle, spriteSearchIconStyle] },
    "textbox--search"
);

export const searchWrapperFocusedStyle = b.styleDef(
    [{ paddingLeft: searchLeftPadding }],
    { before: [searchBeforeBaseStyle, spriteSearchHoverIconStyle] },
    "textbox--search"
);

function colorizeWrapper(textColor: string, backgroundColor: string, nameHint: string) {
    return b.styleDef(
        {
            background: backgroundColor,
            borderColor: textColor,
        },
        {},
        nameHint
    );
}

function colorizeInput(textColor: string, nameHint: string) {
    return b.styleDef(
        { color: textColor, textFillColor: `${textColor} !important` },
        Mixins.createPlaceholderStyle({ color: textColor }),
        nameHint
    );
}

export const revealIconStyle = b.styleDef(
    [
        Mixins.centerVerticalChild(),
        Mixins.getClickableElement(),
        {
            fontSize: 0,
        },
    ],
    {},
    "reveal-icon"
);

export const iconRightStyle = b.styleDef(revealIconStyle, {}, "icon-right");

export const iconRightStyleDisabled = b.styleDef(
    [
        Mixins.centerVerticalChild(),
        {
            fontSize: 0,
        },
    ],
    {},
    "icon-right-disabled"
);

export const rightStyle = b.styleDef(
    [
        Mixins.centerVerticalParent(minHeight),
        {
            position: "absolute",
            right: rightContent,
            top: rightContentTop,
        },
        {
            paddingRight: paddingRight,
            paddingLeft: paddingLeft,
        },
    ],
    {}
);

export const rightStylePassive = b.styleDef(
    [
        Mixins.centerVerticalParent(minHeight),
        {
            position: "absolute",
            right: rightContent,
            top: rightContentTop,
        },
        {
            paddingRight: paddingRight,
            paddingLeft: paddingLeft,
        },
    ],
    {}
);

export const rightStyleWithSmallSize = b.styleDefEx(rightStyle, [
    Mixins.centerVerticalParent(smallMinHeight),
    { paddingRight: paddingRightSmall },
]);

export const rightStyleWithXSmallSize = b.styleDefEx(rightStyle, [
    Mixins.centerVerticalParent(xSmallMinHeight),
    {
        marginTop: -1,
        paddingRight: paddingRightSmall,
    },
]);

export const errorIconStyle = b.styleDef([
    Mixins.centerVerticalParent(height),
    {
        top: errorIconTop,
        position: "absolute",
        right: errorIconRight,
        width: errorIconWidth,
        overflow: "hidden",
    },
]);

export const errorIconWithSmallSizeStyle = b.styleDefEx(errorIconStyle, {
    top: errorIconTopWithSmallSize,
});

export const errorIconWithXSmallSizeStyle = b.styleDefEx(errorIconStyle, {
    top: errorIconTopWithXSmallSize,
});

export const errorIconContentStyle = b.styleDef([
    Mixins.centerVerticalChild(),
    {
        fontSize: 0,
    },
]);

export const tooltipOverlayStyle = b.styleDef({ height: "100%", left: 0, right: 0, position: "absolute" });

export function getTransparentBorders(data: d.IData, isActive: boolean) {
    if (isActive) return undefined;
    switch (data.siblingType) {
        case FormElements.SiblingType.Left:
        case FormElements.SiblingType.Both: {
            return {
                backgroundClip: "padding-box",
                borderLeftColor: "transparent",
            };
        }
        default:
            return undefined;
    }
}
