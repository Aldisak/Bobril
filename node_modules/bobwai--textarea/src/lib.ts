import * as b from "bobril";
import * as s from "./styles";
import * as d from "./data";
import * as constants from "./publicConstants";
import * as FormElements from "bobwai--form-elements";
import * as WebContentAccesibility from "helpers--web-content-accessibility";
import * as Color from "bobwai--color";
import * as Icon from "bobwai--icon";
import * as rtlTextHelper from "helpers--rtl-text";

export * from "./publicConstants";
export * from "./data";

const measuringTextAreaKey = "measuringTextArea";

namespace localVariables {
    export const timeout: number = 500;
}

interface IContext extends b.IBobrilCtx {
    hasFocus: boolean;
    data: d.IData;
    value: string;
    lastValueInData?: string;
    lastSelectionStart: number;
    lastSelectionEnd: number;
    lastIsVScrollbarVisible: boolean;
    lastScrollHeight: number;
    element: HTMLElement;
    changeDelayTimeout?: number;
    lastMeasuredHeight: number;
}

export let create = b.createComponent<d.IData>({
    id: "bobwai--textarea",
    init(ctx: IContext): void {
        ctx.value = "";
        ctx.hasFocus = false;
        ctx.lastScrollHeight = 0;
        ctx.changeDelayTimeout = undefined;
    },

    render(context: IContext, me: b.IBobrilNode): void {
        specifyValueForRender(context);

        const textarea = b.style(
            {
                tag: "textarea",
                attrs: {
                    value: context.value,
                    placeholder: context.data.isReadOnly === true ? "" : context.data.placeholder,
                    rows: context.data.rows || constants.DefaultRows,
                    cols: context.data.cols,
                    disabled: context.data.isDisabled ? "disabled" : undefined,
                    spellcheck: !!context.data.spellcheckEnabled,
                    maxLength: context.data.maxLength,
                    readOnly: context.data.isReadOnly || context.data.isTextPreview,
                },
                data: context.data,
                component: {
                    onChange(_ctx: b.IBobrilCtx, v: string): void {
                        context.value = v;
                        if (context.data.onChange) {
                            if (context.data.isOnChangeWithDelay === true) {
                                clearChangeDelayTimeout(context);
                                context.changeDelayTimeout = window.setTimeout(() => {
                                    if (context.data.onChange) {
                                        context.data.onChange(v);
                                    }
                                }, localVariables.timeout);
                            } else {
                                context.data.onChange(v);
                            }
                        }
                        if (context.element) {
                            emitOnVerticalScroolVisibilityChange(context);
                            emitOnTextHeightChange(context);
                        }
                    },
                    onSelectionChange(ctx: IContext, ev: b.ISelectionChangeEvent): void {
                        if (ctx.data.onSelectionChange) {
                            ctx.data.onSelectionChange(ev);
                        }
                    },
                },
            },
            getTextareaStyle(context.data),
            rtlTextHelper.getRtlTextStyles({
                enableRTL: constants.EnableRTL,
                text: context.value,
            })
        );

        let accessibility: WebContentAccesibility.IWebContentAccessibility | undefined;

        if (context.data.webContentAccessibility) {
            accessibility = context.data.webContentAccessibility;
            WebContentAccesibility.setWebContentAccessibilityAttributes(textarea, accessibility);
        }

        const children = textarea;

        b.style(children, {
            resize: context.data.resize ? d.Resize[context.data.resize] : d.Resize[d.Resize.None],
            width: context.data.cols ? undefined : constants.DefaultWidth,
            height: context.data.autoHeight ? constants.DefaultHeight : undefined,
        });

        me.children = [
            children,
            isError(context.data) && createErrorIcon(),
            getMeasuringAreaIfNeeded(context),
            accessibility &&
                accessibility.validationMessageNodeId &&
                WebContentAccesibility.tryToGetAccessibleValidationMessageNode(accessibility),
        ];

        b.style(me, getStyle(context.data));
    },

    onFocusIn(ctx: IContext): void {
        ctx.hasFocus = true;
        if (ctx.data.onFocusIn) {
            ctx.data.onFocusIn(ctx);
        }
        b.invalidate(ctx);
    },

    onFocusOut(ctx: IContext): void {
        ctx.hasFocus = false;
        if (ctx.data.onFocusOut) {
            ctx.data.onFocusOut(ctx);
        }
        if (ctx.data.onChange && ctx.data.isOnChangeWithDelay && ctx.changeDelayTimeout !== undefined) {
            clearChangeDelayTimeout(ctx);
            ctx.data.onChange(ctx.value);
        }
        b.invalidate(ctx);
    },

    postInitDom(ctx: IContext, _me: b.IBobrilCacheNode, element: HTMLElement): void {
        ctx.element = <HTMLInputElement>element.firstChild;
        emitOnVerticalScroolVisibilityChange(ctx);
        emitOnTextHeightChange(ctx);

        if (ctx.data.initState === d.InitState.selectedText) {
            setFocusManually(ctx);
            (<HTMLInputElement>element.firstChild).select();
        } else if (ctx.data.initState === d.InitState.focused) {
            setFocusManually(ctx);
        }
        if (ctx.data.selection) {
            setSelectionManually(ctx);
        }
    },

    postUpdateDom(ctx: IContext): void {
        if (ctx.data.selection) {
            setSelectionManually(ctx);
        }
        if (ctx.element) {
            emitOnVerticalScroolVisibilityChange(ctx);
            emitOnTextHeightChange(ctx);
        }
    },
});

function specifyValueForRender(ctx: IContext): void {
    if (ctx.data.isOnChangeWithDelay === true) {
        if (ctx.lastValueInData !== ctx.data.value) {
            ctx.lastValueInData = ctx.data.value;
            clearChangeDelayTimeout(ctx);
            setValueFromData(ctx);
        }
    } else {
        setValueFromData(ctx);
    }
}

function setValueFromData(ctx: IContext): void {
    if (ctx.data.value === null) {
        ctx.value = "";
    } else if (ctx.data.value !== undefined) {
        ctx.value = ctx.data.value;
    }
}

function getMeasuringAreaIfNeeded(context: IContext): b.IBobrilNode | undefined {
    let measuringTextArea = undefined;
    if (context.data.onRowsCountChange) {
        measuringTextArea = b.style(
            {
                tag: "textarea",
                attrs: {
                    value: context.value,
                    placeholder: context.data.isReadOnly === true ? "" : context.data.placeholder,
                    cols: context.data.cols,
                    disabled: context.data.isDisabled ? "disabled" : undefined,
                    spellcheck: !!context.data.spellcheckEnabled,
                    maxLength: context.data.maxLength,
                    readOnly: context.data.isReadOnly || context.data.isTextPreview,
                },
                data: context.data,
            },
            getTextareaStyle(context.data),
            rtlTextHelper.getRtlTextStyles({
                enableRTL: constants.EnableRTL,
                text: context.value,
            })
        );

        measuringTextArea.ref = [context, measuringTextAreaKey];

        b.style(measuringTextArea, [
            {
                resize: context.data.resize ? d.Resize[context.data.resize] : d.Resize[d.Resize.None],
                width: context.data.cols ? undefined : constants.DefaultWidth,
            },
            s.measuringAreaStyle,
        ]);
    }
    return measuringTextArea;
}

function setSelectionManually(ctx: IContext): void {
    const selection = ctx.data.selection;

    b.focus(ctx.me);
    if (selection && !!ctx.me.children) {
        b.select(<b.IBobrilCacheNode>ctx.me.children[0], selection.start, selection.end);
    }
    b.invalidate();
}

function createErrorIcon(): b.IBobrilNode {
    const errorIcon = Icon.create({ sprite: b.sprite(Icon.exclamation_small_png, Color.Error) }),
        errorIconContent = b.styledDiv(errorIcon, s.errorIconContentStyle);

    return b.styledDiv(errorIconContent, s.errorIconStyle);
}

function isError(data: d.IData): boolean {
    return data.validationState === FormElements.ValidationState.Error;
}

function isWarning(data: d.IData): boolean {
    return data.validationState === FormElements.ValidationState.Warning;
}

function setFocusManually(ctx: IContext): void {
    ctx.hasFocus = true;
    b.focus(ctx.me);
    b.invalidate(ctx);
}

function getStyle(data: d.IData): b.IBobrilStyle[] {
    return [data.autoHeight && s.autoHeightStyle, isError(data) && s.textareaBaseWithErrorIconStyle];
}

function getTextareaStyle(data: d.IData): b.IBobrilStyles[] {
    const borderVisibility: FormElements.IBorderVisibility = (data.customTheme && data.customTheme.borderVisibility) || {};

    const overflowYResolved = (data.customTheme && data.customTheme.overflowY) || (data.onRowsCountChange && "hidden");

    return [
        s.textareaStyle,
        overflowYResolved && { overflowY: overflowYResolved },
        data.customTheme && data.customTheme.scrollbarY && { scrollbarY: data.customTheme.scrollbarY },
        data.customTheme && data.customTheme.backgroundColor && { backgroundColor: data.customTheme.backgroundColor },
        data.customTheme && data.customTheme.fontStyle && { fontStyle: data.customTheme.fontStyle },
        data.customTheme && data.customTheme.fontSize !== undefined && { fontSize: data.customTheme.fontSize },
        data.customTheme && data.customTheme.padding !== undefined && { padding: data.customTheme.padding },
        data.customTheme && data.customTheme.border && { border: data.customTheme.border },
        borderVisibility && borderVisibility.hasBorderBottom === false && { borderBottomWidth: 0 },
        borderVisibility && borderVisibility.hasBorderTop === false && { borderTopWidth: 0 },
        borderVisibility && borderVisibility.hasBorderLeft === false && { borderLeftWidth: 0 },
        borderVisibility && borderVisibility.hasBorderRight === false && { borderRightWidth: 0 },
        data.customTheme && data.customTheme.lineHeight && { lineHeight: data.customTheme.lineHeight },
        data.customTheme && data.customTheme.fontFamily && { fontFamily: data.customTheme.fontFamily },
        isError(data) && s.invalidStyle,
        isWarning(data) && s.warningStyle,
        data.isDisabled && [s.disabledStyle, isError(data) && s.disabledErrorStyle, isWarning(data) && s.disabledWarningStyle],
        data.isReadOnly && s.textareaReadOnlyStyle,
        data.validationState !== FormElements.ValidationState.Error && !data.isDisabled && data.isHighlighted && s.textAreaHighlightedStyle,
        data.radiusVariant === d.RadiusVariant.Bottom && s.bottomRadiusStyle,
        data.radiusVariant === d.RadiusVariant.Top && s.topRadiusStyle,
        data.isTextPreview && [s.noWrapStyle, s.textAreaPreviewStyle],
        data.noWrap && s.noWrapStyle,
    ];
}

function emitOnTextHeightChange(ctx: IContext): void {
    const areaElement = ctx.element;
    const delta = areaElement.scrollHeight - areaElement.clientHeight;
    if (ctx.data.onRowsCountChange && ctx.refs && ctx.refs[measuringTextAreaKey]) {
        const measuringTextArea = <HTMLTextAreaElement>b.getDomNode(ctx.refs[measuringTextAreaKey]);
        if (measuringTextArea) {
            const measuredHeight = measuringTextArea.scrollHeight;
            if (ctx.lastMeasuredHeight !== measuredHeight) {
                ctx.lastMeasuredHeight = measuredHeight;
                const rowHeight = b.ieVersion() ? 17.7 : 19;
                ctx.data.onRowsCountChange(Math.round(measuredHeight / rowHeight));
            }
        }
    }
    if (ctx.data.onTextHeightChange && ctx.lastScrollHeight !== areaElement.scrollHeight) {
        ctx.data.onTextHeightChange(areaElement.scrollHeight, delta);
        ctx.lastScrollHeight = areaElement.scrollHeight;
    }
}

function emitOnVerticalScroolVisibilityChange(ctx: IContext): void {
    const areaElement = ctx.element,
        scrollbarWidth = getElementScrolbarWidth(areaElement);

    if (ctx.data.onVerticalScroolVisibilityChange && scrollbarWidth > 0 !== ctx.lastIsVScrollbarVisible) {
        ctx.data.onVerticalScroolVisibilityChange(scrollbarWidth);
        ctx.lastIsVScrollbarVisible = scrollbarWidth > 0;
    }
}

function getElementScrolbarWidth(element: HTMLElement): number {
    return element.offsetWidth - element.clientWidth - s.borderSize * 2;
}

function clearChangeDelayTimeout(ctx: IContext): void {
    if (ctx.changeDelayTimeout !== undefined) {
        clearTimeout(ctx.changeDelayTimeout);
    }
}

// added by script - BEGIN
export const Textarea = create;
// added by script - END
