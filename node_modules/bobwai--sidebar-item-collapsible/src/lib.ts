import * as b from "bobril";
import * as styles from "./styles";
import * as Item from "bobwai--sidebar-item";
import * as FormElements from "bobwai--form-elements";
import * as Constants from "./publicConstants";

export const create = b.createComponent<IData>({
    id: "bobwai--sidebar-item-collapsible",
    render(ctx: IContext, me: b.IBobrilNode): void {
        me.children = [
            mainItem(ctx),
            (!ctx.data.isAnimated || (ctx.data.isAnimated && ctx.subItemElementHeight !== undefined)) && subItemList(ctx),
            ctx.data.isAnimated && ctx.subItemElementHeight === undefined && measurableItem(ctx),
        ];
        b.style(me, getStyle(ctx.data), ctx.data.topBorderVisible && styles.topBorderStyle);
    },
    postUpdateDom(ctx: IContext, _me: b.IBobrilNode, element: HTMLElement): void {
        measureContent(ctx, element);
    },
    postInitDom(ctx: IContext, _me: b.IBobrilNode, element: HTMLElement): void {
        measureContent(ctx, element);
    },
});

function measureContent(ctx: IContext, element: HTMLElement): void {
    if (ctx.data.isAnimated) {
        const width = element.getBoundingClientRect().width - 2 * Item.ItemCollapsibleContentPadding;

        if (ctx.subItemElementWidth === undefined || ctx.subItemElementWidth !== width) {
            ctx.subItemElementWidth = element.getBoundingClientRect().width - 2 * Item.ItemCollapsibleContentPadding;
            ctx.subItemElementHeight = undefined;
            b.invalidate(ctx);
            return;
        }

        if (ctx.subItemElementHeight === undefined) {
            let subItemElementHeight: number;
            let itemBottomPadding: number;
            let boundingClientRect: ClientRect;

            const measurableElement = <HTMLElement>element.getElementsByClassName(styles.measurableItemStyle)[0];
            if (measurableElement) {
                boundingClientRect = measurableElement.getBoundingClientRect();
                subItemElementHeight = boundingClientRect.height;
                itemBottomPadding =
                    ctx.data.bottomPadding === BottomPadding.Medium
                        ? styles.localVariables.itemCollapsibleBottomMediumPadding
                        : Item.ItemCollapsibleContentPadding;

                ctx.subItemElementHeight = subItemElementHeight + itemBottomPadding;
                b.invalidate(ctx);
            }
        }
    }
}

export interface IData extends Item.IData {
    isHighlighted?: boolean;
    collapsibleContent?: b.IBobrilChildren; // content of collapsible item
    bottomPadding?: BottomPadding;
    contentSidePadding?: SidePadding;
    topBorderVisible?: boolean;
    /** experimental */
    isAnimated?: boolean;
}
export * from "./publicConstants";

interface IContext extends b.IBobrilCtx {
    data: IData;
    subItemElementHeight?: number;
    subItemElementWidth?: number;
}

export enum BottomPadding {
    Default,
    Medium,
}

export enum SidePadding {
    None,
    Default,
}

function mainItem(ctx: IContext): b.IBobrilNode {
    ctx.data.isCollapsible = true;

    if (ctx.data.isAnimated) {
        ctx.data.hideBottomBorder = true;
    }

    return Item.create(ctx.data);
}

function subItemList(ctx: IContext): b.IBobrilNode | undefined {
    if (!ctx.data.isDisabled && (ctx.data.isAnimated || (!ctx.data.isAnimated && ctx.data.isExpanded))) {
        const styleList = [
            styles.subItemListStyle,
            ctx.data.contentSidePadding !== undefined && {
                paddingLeft: getSidePadding(ctx.data.contentSidePadding),
                paddingRight: getSidePadding(ctx.data.contentSidePadding),
            },
            ctx.data.isAnimated ? styles.subItemAnimatedListStyle : styles.subitemNoAnimatedListStyle,
            ctx.data.isExpanded
                ? { minHeight: ctx.subItemElementHeight, maxHeight: ctx.subItemElementHeight }
                : ctx.subItemElementHeight !== undefined && { minHeight: 0, maxHeight: 0 },
            !ctx.data.isAnimated && ctx.data.bottomPadding === BottomPadding.Medium && styles.subitemMediumBottomPaddingStyle,
            ctx.data.isExpanded && styles.subItemExpandedListStyle,
            ctx.data.isSeparator && styles.subItemListWithSeparatorStyle,
        ];
        return b.styledDiv(ctx.data.collapsibleContent, styleList);
    }
    return;
}

function measurableItem(ctx: IContext): b.IBobrilNode | undefined {
    if (!ctx.data.isDisabled) {
        return b.styledDiv(
            ctx.data.collapsibleContent,
            styles.measurableItemStyle,
            ctx.subItemElementWidth !== undefined && { width: ctx.subItemElementWidth }
        );
    }
    return;
}

function getStyle(data: IData): b.IBobrilStyles {
    if (data.isHighlighted && data.isExpanded && !data.isDisabled) {
        return [
            styles.collapsibleItemHighlightedExpandedStyle,
            data.validationState === FormElements.ValidationState.Error && styles.collapsibleItemHighlightedExpandedInvalidStyle,
            data.validationState === FormElements.ValidationState.Warning && styles.collapsibleItemHighlightedExpandedWarningStyle,
        ];
    }
    return [];
}

function getSidePadding(sidePadding: SidePadding): number {
    switch (sidePadding) {
        case SidePadding.None:
            return Constants.sidePaddingNone;
        default:
            return Constants.sidePaddingDefault;
    }
}

// added by script - BEGIN
export const SidebarItemCollapsible = create;
// added by script - END
