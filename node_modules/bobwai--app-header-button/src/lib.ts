import * as b from "bobril";
import * as Mixins from "bobwai--style-mixins";
import * as d from "./data";
import * as title from "./title";
import * as c from "./publicConstants";
import * as Color from "bobwai--color";
import * as TooltipEmplacer from "bobwai--tooltip-emplacer";
import * as Focus from "bobwai--focus";
import { KeyCode } from "helpers--key-codes";
import { isActionTypeButton, isNavigationTypeButton } from "./helper";
import { ContentAccessibilityRole } from "bobwai--focus";

namespace localVariables {
    export const buttonBackground = c.ButtonBackgroundActive;
    export const buttonBackgroundSelected = c.ButtonBackgroundSelected;
    export const buttonBackgroundOver = c.ButtonBackgroundOver;
    // light style
    export const buttonBackgroundLight = c.ButtonBackgroundActiveLight;
    export const buttonBackgroundOverLight = c.ButtonBackgroundOverLight;

    export const buttonPaddingHorizontal = Mixins.Spacing.Spacing500;
    export const actionButtonPaddingHorizontal = Mixins.Spacing.Spacing200;
    export const buttonPaddingHorizontalSmall = Mixins.Spacing.Spacing300;
    export const buttonPaddingHorizontalWithIcon = Mixins.Spacing.Spacing300;
    export const buttonPaddingHorizontalWithIconSmall = Mixins.Spacing.Spacing200;
    export const buttonPaddingSiblingButtons = Mixins.Spacing.Spacing100 / 2;
    export const buttonFocusOffset = Mixins.Spacing.Spacing200;
    export const buttonFocusOffsetForSiblingButton = 1;
    export const actionButtonHighlightedOffset = buttonFocusOffset;
    export const actionButtonHighlightedOffsetForSiblingButton = buttonFocusOffsetForSiblingButton;

    export const buttonHeight = 50;
    export const buttonLineHeight = buttonHeight;
    export const buttonIconMargin = Mixins.Spacing.Spacing300;
    export const buttonRightIconLeftMargin = Mixins.Spacing.Spacing100;
    export const buttonIconWithTitleRightMargin = Mixins.Spacing.Spacing200;
    export const buttonIconWithPreIconTitleLeftMargin = Mixins.Spacing.Spacing200;

    export const disabledOpacity = 0.7;
}

export let create = b.createComponent<d.IData>({
    id: "bobwai--app-header-button",
    init(ctx: IContext): void {
        ctx.isHover = false;
    },
    render(ctx: IContext, me: b.IBobrilNode): void {
        if (hasActiveUrl(ctx.data)) {
            me.tag = "a";
            me.attrs = { href: ctx.data.url, tabindex: -1 };
        }
        const button = createButton(ctx);
        me.children = getFocus(
            ctx,
            ctx.data.tooltip
                ? TooltipEmplacer.create({
                      content: button,
                      tooltipHeader: ctx.data.tooltip.tooltipHeader,
                      tooltipMessage: ctx.data.tooltip.tooltipMessage,
                      preferedPlacement: ctx.data.tooltipPreferredPlacement || TooltipEmplacer.Placement.bottomRight,
                  })
                : button
        );

        b.style(me, appHeaderButtonWrapperStyle);
    },
    onClick(ctx: IContext): boolean {
        if (ctx.data.onClick && !ctx.data.isDisabled && !ctx.isOnClickHandled) {
            ctx.isPressed = false;
            ctx.isOnClickHandled = false;
            ctx.data.onClick();
            return true;
        }
        return !!ctx.data.onClick;
    },
    onMouseDown(ctx: IContext, e: b.IBobrilMouseEvent): boolean {
        if (ctx.data.onClick && !ctx.data.isDisabled && e.button === 1) {
            ctx.isPressed = true;
            b.invalidate(ctx);
        }
        return false;
    },
    onMouseUp(ctx: IContext, e: b.IBobrilMouseEvent): boolean {
        // HACK, temporary fix of BG-1221 (onClick ignored time to time)
        if (ctx.data.onClick && !ctx.data.isDisabled && ctx.isPressed && e.button === 1) {
            ctx.isPressed = false;
            ctx.isOnClickHandled = true;
            ctx.data.onClick();
            return true;
        }
        return !!ctx.data.onClick;
    },
    onMouseEnter(ctx: IContext): boolean {
        if (ctx.data.isDisabled) {
            return true;
        }
        if (ctx.data.onClick || hasActiveUrl(ctx.data)) {
            ctx.isHover = true;
            b.invalidate(ctx);
        }
        ctx.data.onMouseEnter && ctx.data.onMouseEnter();
        return true;
    },
    onMouseLeave(ctx: IContext): boolean {
        if (ctx.isPressed) {
            ctx.isPressed = false;
            b.invalidate(ctx);
        }
        if (ctx.data.isDisabled) {
            return true;
        }
        if (ctx.data.onClick || hasActiveUrl(ctx.data)) {
            ctx.isHover = false;
            b.invalidate(ctx);
        }
        ctx.data.onMouseLeave && ctx.data.onMouseLeave();
        return true;
    },
    onDrag(ctx: IContext) {
        if (ctx.isDrag) {
            return false;
        }
        ctx.isDrag = true;
        b.invalidate(ctx);
        return false;
    },
    onDragEnd(ctx: IContext) {
        ctx.isDrag = false;
        b.invalidate(ctx);
        return false;
    },
});

function getFocus(ctx: IContext, content: b.IBobrilNode): b.IBobrilNode {
    return Focus.create(
        b.assign(
            {
                color: getFocusBorderColor(ctx.data),
                focussedViaClick: {
                    color: "transparent",
                },
                focusCommandKeys: [KeyCode.Enter, KeyCode.Space],
                isDisabled: !hasActiveUrl(ctx.data) && !ctx.data.onClick,
                borderStyle: Focus.BorderStyle.Solid,
                borderRadius: Focus.BorderRadius.Small,

                onFocusCommand: () => {
                    if (!ctx.data.isDisabled) {
                        if (hasActiveUrl(ctx.data)) {
                            tryToClickOnLink(ctx);
                        }
                        if (ctx.data.onClick !== undefined) {
                            ctx.data.onClick();
                        }
                    }
                },
                webContentAccessibility: {
                    ariaLabel: getAriaLabel(ctx.data),
                    role: getWebContentRole(ctx.data),
                    isDisabled: ctx.data.isDisabled,
                    tooltip: ctx.data.tooltip,
                },
                content: content,
            },
            getFocusOffset(ctx.data)
        )
    );
}

function getWebContentRole(data: d.IData): ContentAccessibilityRole | undefined {
    if (hasActiveUrl(data)) {
        return ContentAccessibilityRole.Link;
    }
    if (data.onClick !== undefined) {
        return ContentAccessibilityRole.Button;
    }
    return undefined;
}

function tryToClickOnLink(ctx: IContext): void {
    const linkElement: HTMLElement | undefined = <HTMLElement | undefined>b.getDomNode(ctx.me);
    if (linkElement) {
        linkElement.click();
    }
}

function getAriaLabel(data: d.IData): string {
    const title = data.title || "";
    if (data.webContentAccessibility) {
        return data.webContentAccessibility.ariaLabel + " " + title;
    }
    return title;
}

function getFocusOffset(data: d.IData): { offsetTop: number; offsetLeft: number; offsetRight: number; offsetBottom: number } {
    const defaultFocusOffset = localVariables.buttonFocusOffset;
    const offsetTop = defaultFocusOffset;
    const offsetBottom = defaultFocusOffset;
    let offsetLeft = defaultFocusOffset;
    let offsetRight = defaultFocusOffset;
    if (isActionTypeButton(data)) {
        if (data.siblingButtons === d.SiblingButtons.Both || data.siblingButtons === d.SiblingButtons.Left) {
            offsetLeft = localVariables.buttonFocusOffsetForSiblingButton;
        }
        if (data.siblingButtons === d.SiblingButtons.Both || data.siblingButtons === d.SiblingButtons.Right) {
            offsetRight = localVariables.buttonFocusOffsetForSiblingButton;
        }
    }
    return {
        offsetTop,
        offsetBottom,
        offsetLeft,
        offsetRight,
    };
}

function getFocusBorderColor(data: d.IData): Color.IColor {
    if (data.theme === d.Theme.Light) {
        return Color.Basic_64;
    }
    return Color.White_64;
}

function hasActiveUrl(data: d.IData): boolean {
    return data.url !== undefined && data.url.length > 0 && !data.isDisabled;
}

function canBeClicked(data: d.IData): boolean {
    return !data.isDisabled && (data.onClick !== undefined || hasActiveUrl(data));
}

function isSelectedStateAllowClick(data: d.IData): boolean {
    // action type button can be also clickable
    if (data.isSelected) {
        return isActionTypeButton(data);
    }
    return true;
}

function createButton(ctx: IContext): b.IBobrilNode {
    let icon;
    let rightIcon;
    if (ctx.data.icon) {
        icon = ctx.data.hoveredIcon && (ctx.isHover || ctx.data.isSelected) ? ctx.data.hoveredIcon : ctx.data.icon;
    }
    if (ctx.data.rightIcon) {
        rightIcon = ctx.data.rightHoveredIcon && (ctx.isHover || ctx.data.isSelected) ? ctx.data.rightHoveredIcon : ctx.data.rightIcon;
    }
    const button = {
        children: [
            ctx.data.preIconTitle &&
                title.create({ data: ctx.data, disabledOpacity: localVariables.disabledOpacity, isPreIconTitle: true }),
            icon &&
                b.style(b.cloneNode(icon), [
                    headerButtonIconStyle,
                    (ctx.data.title || ctx.data.rightIcon) && headerButtonLeftIconWithTitleStyle,
                    ctx.data.preIconTitle && headerButtonLeftIconWithPreIconTitleStyle,
                    ctx.data.isDisabled && headerButtonIconDisabledStyle,
                ]),

            ctx.data.title && title.create({ data: ctx.data, disabledOpacity: localVariables.disabledOpacity }),
            rightIcon &&
                b.style(b.cloneNode(rightIcon), [
                    headerButtonIconRightStyle,
                    ctx.data.icon && !ctx.data.title && headerButtonIconRightWithLeftIconOnlyStyle,
                    ctx.data.isDisabled && headerButtonIconDisabledStyle,
                ]),
        ],
    };

    return b.styledDiv(
        b.styledDiv(
            [getHighlightedBackground(ctx), button],
            [
                highlightedLayerWrapperStyle,
                {
                    paddingLeft: getLeftPadding(ctx.data),
                    paddingRight: getRightPadding(ctx.data),
                },
            ]
        ),
        getDefaultStyle(ctx)
    );
}

function getHighlightedBackground(ctx: IContext): b.IBobrilNode | undefined {
    if (ctx.isHover || ctx.isPressed || ctx.data.isSelected) {
        let offset = 0;
        let left = offset;
        let right = offset;
        if (isActionTypeButton(ctx.data)) {
            offset = localVariables.actionButtonHighlightedOffset;
            left = offset;
            right = offset;
            if (ctx.data.siblingButtons === d.SiblingButtons.Left || ctx.data.siblingButtons === d.SiblingButtons.Both) {
                left = localVariables.actionButtonHighlightedOffsetForSiblingButton;
            }
            if (ctx.data.siblingButtons === d.SiblingButtons.Right || ctx.data.siblingButtons === d.SiblingButtons.Both) {
                right = localVariables.actionButtonHighlightedOffsetForSiblingButton;
            }
        }

        const isLightTheme = ctx.data.theme === d.Theme.Light;
        return b.styledDiv("", [
            highlightedBackgroundBaseStyle,
            // hover style - is also available for selected action type button
            ctx.isHover && [
                !ctx.data.isSelected && (isLightTheme ? hoverBackgroundLightStyle : hoverBackgroundStyle),
                ctx.data.isSelected && isActionTypeButton(ctx.data) && (isLightTheme ? hoverBackgroundLightStyle : hoverBackgroundStyle),
            ],
            // pressed style - is also available for selected action type button
            ctx.isPressed && [
                !ctx.data.isSelected && (isLightTheme ? pressedBackgroundLightStyle : pressedBackgroundStyle),
                ctx.data.isSelected &&
                    isActionTypeButton(ctx.data) &&
                    (isLightTheme ? pressedBackgroundLightStyle : pressedBackgroundStyle),
            ],
            // selected style
            ctx.data.isSelected && [
                isActionTypeButton(ctx.data) &&
                    !ctx.isHover &&
                    !ctx.isPressed &&
                    (isLightTheme ? selectedActionButtonBackgroundLightStyle : selectedActionButtonBackgroundStyle),
                isNavigationTypeButton(ctx.data) && [
                    selectedNavigationButtonBackgroundStyle,
                    ctx.data.customTheme &&
                        ctx.data.customTheme.selectedBackgroundColor && { background: ctx.data.customTheme.selectedBackgroundColor },
                ],
            ],
            {
                left: left,
                right: right,
                top: offset,
                bottom: offset,
            },
        ]);
    }
    return undefined;
}

export * from "./publicConstants";
export * from "./data";

interface IContext extends b.IBobrilCtx {
    data: d.IData;
    isHover: boolean;
    isDrag: boolean;
    isPressed: boolean;
    isOnClickHandled: boolean;
}

function getDefaultStyle(ctx: IContext): b.IBobrilStyles[] {
    return [
        centerParentStyle,
        headerButtonBaseStyle,
        ctx.data.theme === d.Theme.Light && headerButtonLightStyle,
        !ctx.isDrag && cursorDefaultStyle,

        getColorStyle(getTitleColorActive(ctx.data)),
        !ctx.isDrag && canBeClicked(ctx.data) && isSelectedStateAllowClick(ctx.data) && clickableStyle,
        ctx.isHover && getColorStyle(getTitleColorOver(ctx.data)),

        ctx.data.isSelected && [getColorStyle(getTitleColorSelected(ctx.data))],
        ctx.data.customTheme &&
            ctx.data.customTheme.backgroundColor &&
            !ctx.data.isSelected &&
            getBackgroundColorStyle(ctx.data.customTheme.backgroundColor),
    ];
}

function hasIconOnly(data: d.IData): boolean {
    return data.icon !== undefined && data.title === undefined;
}

function getLeftPadding(data: d.IData): number {
    if (isNavigationTypeButton(data)) {
        return getSidePaddingForNavigationButton({
            hasIcon: data.icon !== undefined && data.preIconTitle === undefined,
            isSmallVariant: data.padding === d.Padding.Small,
        });
    }
    if (isActionTypeButton(data)) {
        return getSidePaddingForActionButton({
            isSiblingButton: data.siblingButtons === d.SiblingButtons.Left || data.siblingButtons === d.SiblingButtons.Both,
        });
    }
    return 0;
}

function getRightPadding(data: d.IData): number {
    if (isNavigationTypeButton(data)) {
        return getSidePaddingForNavigationButton({
            hasIcon: data.rightIcon !== undefined || hasIconOnly(data),
            isSmallVariant: data.padding === d.Padding.Small,
        });
    }
    if (isActionTypeButton(data)) {
        return getSidePaddingForActionButton({
            isSiblingButton: data.siblingButtons === d.SiblingButtons.Right || data.siblingButtons === d.SiblingButtons.Both,
        });
    }
    return 0;
}

function getSidePaddingForNavigationButton(params: { hasIcon: boolean; isSmallVariant: boolean }): number {
    if (params.hasIcon) {
        return params.isSmallVariant ? localVariables.buttonPaddingHorizontalWithIconSmall : localVariables.buttonPaddingHorizontalWithIcon;
    } else {
        return params.isSmallVariant ? localVariables.buttonPaddingHorizontalSmall : localVariables.buttonPaddingHorizontal;
    }
}

function getSidePaddingForActionButton(params: { isSiblingButton: boolean }): number {
    if (params.isSiblingButton) {
        return localVariables.buttonPaddingSiblingButtons;
    }
    return localVariables.actionButtonPaddingHorizontal;
}

function getTitleColorActive(data: d.IData): Color.IColor {
    return data.customTheme && data.customTheme.color
        ? data.customTheme.color
        : data.theme === d.Theme.Light
        ? c.TitleColorActiveLight
        : c.TitleColorActive;
}

function getTitleColorSelected(data: d.IData): Color.IColor {
    return data.customTheme && data.customTheme.hoverColor
        ? data.customTheme.hoverColor
        : data.theme === d.Theme.Light
        ? c.TitleColorSelectedLight
        : c.TitleColorSelected;
}

function getTitleColorOver(data: d.IData): Color.IColor {
    return getTitleColorSelected(data);
}

const headerButtonIconStyle = b.styleDef([
    Mixins.centerVerticalChildInlineBlock(),
    {
        margin: localVariables.buttonIconMargin,
        position: "relative",
    },
]);

const headerButtonLeftIconWithTitleStyle = b.styleDefEx(headerButtonIconStyle, {
    marginRight: localVariables.buttonIconWithTitleRightMargin,
});

const headerButtonLeftIconWithPreIconTitleStyle = b.styleDefEx(headerButtonIconStyle, {
    marginLeft: localVariables.buttonIconWithPreIconTitleLeftMargin,
});

const headerButtonIconRightStyle = b.styleDef([
    Mixins.centerVerticalChildInlineBlock(),
    {
        position: "relative",
        marginLeft: localVariables.buttonRightIconLeftMargin,
    },
]);

const headerButtonIconRightWithLeftIconOnlyStyle = b.styleDefEx(headerButtonIconRightStyle, {
    marginLeft: 0,
});

const appHeaderButtonWrapperStyle = b.styleDef(
    {
        verticalAlign: "top",
        display: "inline-block",
    },
    {},
    "app-header-button-wrapper"
);

const highlightedBackgroundBaseStyle = b.styleDef({
    boxSizing: "border-box",
    position: "absolute",
});

const hoverBackgroundStyle = b.styleDef({
    background: localVariables.buttonBackgroundOver,
});
const hoverBackgroundLightStyle = b.styleDef({
    background: localVariables.buttonBackgroundOverLight,
});
const pressedBackgroundStyle = b.styleDef({
    background: Color.White_24,
});
const pressedBackgroundLightStyle = b.styleDef({
    background: Color.Basic_24,
});
const selectedActionButtonBackgroundStyle = b.styleDef({
    background: Color.White_16,
});
const selectedActionButtonBackgroundLightStyle = b.styleDef({
    background: Color.Basic_16,
});
const selectedNavigationButtonBackgroundStyle = b.styleDef({
    background: localVariables.buttonBackgroundSelected,
});

const headerButtonIconDisabledStyle = b.styleDef({
    opacity: localVariables.disabledOpacity,
});

const clickableStyle = Mixins.getClickableElement();
const cursorDefaultStyle = Mixins.getUnselectable();

const centerParentStyle = b.styleDef(Mixins.centerVerticalParent(localVariables.buttonHeight));

const headerButtonBaseStyle = b.styleDef(
    {
        background: localVariables.buttonBackground,
        height: localVariables.buttonHeight,
        lineHeight: `${localVariables.buttonLineHeight}px`,
        position: "relative",
    },
    {},
    "app-header-btn"
);

const headerButtonLightStyle = b.styleDefEx(
    headerButtonBaseStyle,
    {
        background: localVariables.buttonBackgroundLight,
    },
    {},
    "app-header-btn-light"
);

const highlightedLayerWrapperStyle = b.styleDef({
    display: "inline-block",
});

function getColorStyle(color: Color.IColor): b.IBobrilStyle {
    return { color: color };
}

function getBackgroundColorStyle(color: Color.IColor): b.IBobrilStyle {
    return { backgroundColor: color };
}

// added by script - BEGIN
export const AppHeaderButton = create;
// added by script - END
