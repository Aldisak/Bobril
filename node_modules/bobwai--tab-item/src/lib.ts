import * as b from "bobril";
import * as c from "./publicConstants";
import * as s from "./styles";
import * as su from "./stylesUpdated";
import * as Color from "bobwai--color";
import * as FormElements from "bobwai--form-elements";
import * as Icon from "bobwai--icon";
import * as StateIcon from "bobwai--state-icon";
import * as TooltipEllipsis from "bobwai--tooltip-ellipsis";
import * as TooltipEmplacer from "bobwai--tooltip-emplacer";

export const create = b.createComponent<IData>({
    id: "bobwai--tab-item",
    onClick(ctx: IContext): boolean {
        if (ctx.data.onClick && !ctx.data.isDisabled && !ctx.data.isSelected) {
            ctx.data.onClick(ctx.data);
            return true;
        }
        return false;
    },
    render(ctx: IContext, me: b.IBobrilNode): void {
        if (useLatestStyles(ctx.data)) {
            renderWithLatestStyles(ctx, me);
            return;
        }

        if (ctx.data.iconContent) {
            me.children = getIcon(ctx.data);
            me.attrs = {
                title: ctx.data.label,
            };
        } else {
            const marginTitle = s.localVariables.marginRightIcon * 2 + (c.MarginLeftIcon - s.localVariables.borderWidth) / 2;
            const marginLeftRightIcon = c.MarginLeftIcon + s.localVariables.marginRightIcon;
            me.children = b.styledDiv(
                [
                    TooltipEllipsis.create({
                        tooltipMessage: ctx.data.label,
                        content: b.styledDiv(ctx.data.label, [
                            s.labelStyle,
                            {
                                maxWidth:
                                    s.localVariables.maxWidth -
                                    c.TextPaddingRightLeft * 2 -
                                    (ctx.data.onDelete ? marginTitle : marginTitle - marginLeftRightIcon),
                            },
                        ]),
                    }),
                    (ctx.data.counter || ctx.data.counter === 0) && b.styledDiv(ctx.data.counter.toString(), s.counterStyle),
                    ctx.data.onDelete && createDeleteIcon(ctx.data),
                ],
                getContentStyle(ctx.data)
            );
        }
        b.style(me, getStyles(ctx.data));
    },
});

export * from "./publicConstants";

export interface IData {
    label: string;
    size?: Size;
    counter?: string | number;
    iconContent?: b.IBobrilNode;
    selectedIconContent?: b.IBobrilNode;
    errorIconContent?: b.IBobrilNode;
    warningIconContent?: b.IBobrilNode;
    infoIconContent?: b.IBobrilNode;
    isSelected?: boolean;
    isDisabled?: boolean;
    deletionTooltip?: string;
    validationState?: FormElements.ValidationState;
    isInfo?: boolean;
    isCentered?: boolean;
    useLatestStyles?: boolean;
    onClick?(item: IData): void;
    onDelete?(): void;
}

export enum Size {
    Default,
    /**
     * Small variant not work with icon content
     */
    Small,
}

interface IContext extends b.IBobrilCtx {
    data: IData;
}

function getStyles(data: IData): b.IBobrilStyles {
    return [
        getNormalStyle(data),
        data.isSelected && getSelectedStyle(data),
        data.isDisabled && s.tabItemDisabledStyle,
        data.iconContent === undefined && data.size === Size.Small && s.tabItemSmallStyle,
        data.validationState === FormElements.ValidationState.Error && s.errorStyle,
        data.validationState === FormElements.ValidationState.Error && data.isSelected && s.errorActiveStyle,
        data.validationState === FormElements.ValidationState.Warning && s.warningStyle,
        data.validationState === FormElements.ValidationState.Warning && data.isSelected && s.warningActiveStyle,
        data.isInfo === true && s.infoStyle,
        data.isInfo === true && data.isSelected && s.infoActiveStyle,
    ];
}

function getNormalStyle(data: IData): b.IBobrilStyles {
    return [
        s.tabItemBaseStyle,
        data.isCentered && s.centeredStyle,
        data.iconContent && s.tabItemIconStyle,
        !data.iconContent && s.tabItemWithLabelStyle,
    ];
}

const normalCloseButton = Icon.create({
    sprite: b.sprite(Icon.close_small_png, Color.Grey500),
});

const hoverCloseButton = Icon.create({
    sprite: b.sprite(Icon.close_small_png, Color.Error),
});

const normalCloseButtonLatestStyles = Icon.create({
    sprite: b.sprite(Icon.close_small_png, Color.Basic),
});

function createDeleteIcon(data: IData): b.IBobrilNode {
    const icon = b.styledDiv(
        StateIcon.create({
            content: normalCloseButton,
            hoverContent: hoverCloseButton,
            onClick: (): void => {
                data.onDelete && data.onDelete();
            },
            isDisabled: data.isDisabled,
            isFocusable: false,
        }),
        s.deleteIconStyle,
        data.size === Size.Small && {
            top: s.localVariables.deleteIconPaddingTop / 2,
        }
    );

    return data.deletionTooltip && !data.isDisabled
        ? TooltipEmplacer.create({
              tooltipMessage: data.deletionTooltip,
              content: icon,
              preferedPlacement: TooltipEmplacer.Placement.topCenter,
              validationState: FormElements.ValidationState.Error,
          })
        : icon;
}

function getIcon(data: IData): b.IBobrilNode {
    if (data.validationState === FormElements.ValidationState.Error && data.errorIconContent) {
        return b.styledDiv(data.errorIconContent, getContentStyle(data));
    }
    if (data.validationState === FormElements.ValidationState.Warning && data.warningIconContent) {
        return b.styledDiv(data.warningIconContent, getContentStyle(data));
    }
    if (data.isInfo === true && data.infoIconContent) {
        return b.styledDiv(data.infoIconContent, getContentStyle(data));
    }
    if (data.isSelected && data.selectedIconContent) {
        return b.styledDiv(data.selectedIconContent, getContentStyle(data));
    }
    return b.styledDiv(data.iconContent, getContentStyle(data));
}

export function getSelectedStyle(data: IData): b.IBobrilStyles {
    return data.iconContent ? s.tabItemIconActiveStyle : s.tabItemActiveStyle;
}

export function getContentStyle(data: IData): b.IBobrilStyles {
    return [
        s.contentStyle,
        data.onDelete && { marginRight: c.MarginLeftIcon + s.localVariables.marginRightIcon },
        data.isDisabled && s.contentDisabledStyle,
    ];
}

function useLatestStyles(data: IData): boolean {
    return data.useLatestStyles !== undefined ? data.useLatestStyles : c.UseLatestStyles() || false;
}

//------------------ latest styles ----------------

const errorIcon = b.sprite(Icon.error_small_png, Color.Error);
const warnIcon = b.sprite(Icon.warning_small_png, Color.Warning);
const infoIcon = b.sprite(Icon.info2_small_png, Color.Info);

function renderWithLatestStyles(ctx: IContext, me: b.IBobrilNode): void {
    const iconsCount =
        (ctx.data.iconContent ? 1 : 0) +
        (ctx.data.onDelete ? 1 : 0) +
        (ctx.data.validationState === FormElements.ValidationState.Error ||
        ctx.data.validationState === FormElements.ValidationState.Warning ||
        ctx.data.isInfo
            ? 1
            : 0);
    const iconsReservedSpace = iconsCount * (su.localVariables.iconSize + su.localVariables.innerSpacing);

    const parts = [];
    if (ctx.data.iconContent) {
        parts.push(getIconPart(ctx.data.iconContent, parts.length > 0));
    }
    if (ctx.data.label) {
        parts.push(getTextPart(ctx.data.label, parts.length > 0, su.localVariables.maxWidth - iconsReservedSpace));
    }
    if (ctx.data.counter) {
        parts.push(getTextPart(ctx.data.counter, parts.length > 0));
    }
    if (ctx.data.validationState === FormElements.ValidationState.Error) {
        parts.push(getIconPart(Icon.create({ sprite: errorIcon }), parts.length > 0));
    } else if (ctx.data.validationState === FormElements.ValidationState.Warning) {
        parts.push(getIconPart(Icon.create({ sprite: warnIcon }), parts.length > 0));
    } else if (ctx.data.isInfo) {
        parts.push(getIconPart(Icon.create({ sprite: infoIcon }), parts.length > 0));
    }
    if (ctx.data.onDelete) {
        parts.push(getIconPart(getDeleteIcon(ctx.data), parts.length > 0));
    }

    me.children = parts;
    b.style(me, [
        su.baseStyle,
        ctx.data.size === Size.Small && su.baseSmallStyle,
        ctx.data.isDisabled && su.baseDisabledStyle,
        !ctx.data.isDisabled && !ctx.data.isSelected && su.baseHoverableStyle,
        ctx.data.isSelected && su.baseActiveStyle,
        ctx.data.isSelected && ctx.data.validationState === FormElements.ValidationState.Error && su.baseActiveErrorStyle,
        ctx.data.isSelected && ctx.data.validationState === FormElements.ValidationState.Warning && su.baseActiveWarningStyle,
        ctx.data.isSelected &&
            ctx.data.isInfo &&
            ctx.data.validationState !== FormElements.ValidationState.Error &&
            ctx.data.validationState !== FormElements.ValidationState.Warning &&
            su.baseActiveInfoStyle,
    ]);
}

function getIconPart(content: b.IBobrilNode, useInnerSpacing: boolean): b.IBobrilNode {
    return b.styledDiv(content, [su.iconStyle, useInnerSpacing && su.withInnerSpacing]);
}

function getTextPart(content: string | number, useInnerSpacing: boolean, maxWidth?: number): b.IBobrilNode {
    return b.styledDiv(
        maxWidth
            ? TooltipEllipsis.create({
                  content: b.styledDiv(content, su.lineEllipsis, maxWidth && { maxWidth: maxWidth }),
                  tooltipMessage: content.toString(),
              })
            : content,
        [su.textStyle, useInnerSpacing && su.withInnerSpacing]
    );
}

function getDeleteIcon(data: IData): b.IBobrilNode {
    const icon = StateIcon.create({
        content: normalCloseButtonLatestStyles,
        hoverContent: hoverCloseButton,
        onClick: (): void => {
            if (data.onDelete) {
                data.onDelete();
            }
        },
        isDisabled: data.isDisabled,
        isFocusable: false,
    });

    return data.deletionTooltip && !data.isDisabled
        ? TooltipEmplacer.create({
              tooltipMessage: data.deletionTooltip,
              content: icon,
              preferedPlacement: TooltipEmplacer.Placement.topCenter,
              validationState: FormElements.ValidationState.Error,
          })
        : icon;
}

// added by script - BEGIN
export const TabItem = create;
// added by script - END
