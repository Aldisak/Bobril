import * as b from "bobril";
import * as g from "bobril-g11n";
import { Tag } from "./tag";
import { Diff } from "./diff";
import { User } from "./utils";

const rawTagRegex = /@{\d+}/g;

// 10 = 0a = \n
// 13 = 0c = CR
const nonPrintableCharRegex = /[\x00-\x09\x0b\x0d-\x1F]/g; // 0-31 včetně
const disallowedNonPrintables = [10, 13];

export function sanitizeString(text: string) {
    return text.replace(nonPrintableCharRegex, "");
}

export class Inset {
    user?: User;
    text: string;
    raw?: string;
    constructor(arg: User | string) {
        if (typeof arg === "string") {
            this.text = arg;
        } else {
            this.text = formatUser(arg);
            if (arg !== undefined) {
                this.user = arg;
                this.raw = idToRawTag(arg.id);
            }
        }
    }
    get id(): number {
        return this.user!.id;
    }
    get isActive(): boolean {
        return this.user !== undefined;
    }
}

class Selection {
    start: number;
    end: number;

    tagStart: number;
    tagEnd: number;

    constructor(diff: Diff, tagStart: number, tagEnd: number) {
        this.start = diff.start;
        this.end = diff.start + diff.removed;
        this.tagStart = tagStart;
        this.tagEnd = tagEnd;
    }

    get startsBeforeTag(): boolean {
        return this.start <= this.tagStart;
    }

    get endsAfterTag(): boolean {
        return this.tagEnd <= this.end;
    }

    get fullyCoversTag(): boolean {
        return this.startsBeforeTag && this.endsAfterTag;
    }

    get startsInsideTag(): boolean {
        return this.tagStart < this.start && this.start < this.tagEnd;
    }

    get endsInsideTag(): boolean {
        return this.tagStart < this.end && this.end < this.tagEnd;
    }

    get onlyInsideTag(): boolean {
        return this.startsInsideTag && this.endsInsideTag;
    }

    get modifiesTag(): boolean {
        return this.startsInsideTag || this.endsInsideTag;
    }

    get bleedsOutsideTag(): boolean {
        return this.startsBeforeTag || this.endsAfterTag;
    }
}

export class State {
    userList: User[];
    // raw and user-facing strings of text and tags
    rawString?: string;
    translatedString?: string;
    terminatedString?: string;
    shadowContent?: b.IBobrilChild[] | string;
    // signaling to skip applying diff to string from last state, if only content of single tag is edited
    preventSplice: boolean = false;
    // Removing last character results in removing the whole tag. We need properties to signal it and help readjust cursor.
    removedLastCharOfTag: boolean = false;
    removedInset?: Inset;
    // building blocks from which strings & shadowContent is generated.
    messageParts: string[] = [];
    insets: Inset[] = [];

    static fromRawString(rawString: string, userList: User[]): State {
        let state = new State(userList);
        state.initWithRawString(rawString);
        return state;
    }

    static fromStateAndDiff(lastState: State, diff: Diff, userList: User[]): State {
        let state = new State(userList);
        state.initWithStateAndDiff(lastState, diff);
        return state;
    }

    constructor(userList: User[]) {
        this.userList = userList;
    }

    initWithRawString(rawString: string) {
        this.rawString = rawString;
        this.parseRawString(this.rawString);
        this.createAll();
    }

    initWithStateAndDiff(lastState: State, diff: Diff) {
        this.createInsetsFromDiff(lastState, diff);
        if (this.insets.length > 0) {
            let splicedTerminatedString;
            if (this.preventSplice) {
                splicedTerminatedString = lastState.terminatedString!;
            } else {
                splicedTerminatedString = splice(lastState.terminatedString!, diff.start, diff.removed, diff.insertion!);
            }
            this.messageParts = this.splitTerminatedString(splicedTerminatedString);
            // Merge messageParts & insets into raw string.
            this.createRawString();
        } else {
            this.rawString = splice(lastState.translatedString!, diff.start, diff.removed, diff.insertion!);
        }
        // The new addition may be new tag @{123} -> Reparse the raw string to new messageParts & insets.
        this.parseRawString(this.rawString!);
        // Create all other internals from the newly parsed messageParts & insets.
        this.createShadowContent();
        this.createTranslatedString();
        this.createTerminatedString();
    }

    createInsetsFromDiff(lastState: State, diff: Diff) {
        let lastTagEnd = 0;
        let insets: Inset[] = [];
        this.insets = insets;
        for (let i = 0; i < lastState.insets.length; i++) {
            let inset = lastState.insets[i];
            let tagStart = lastTagEnd + lastState.messageParts[i].length;
            let tagEnd = tagStart + inset.text.length;
            lastTagEnd = tagEnd;
            let sel = new Selection(diff, tagStart, tagEnd);
            // return nothing if the selection covers the whole tag and thus deletes it.
            if (sel.fullyCoversTag) {
                continue;
            }
            // return the unmodified tag if the changes occur somewhere else.
            if (!sel.modifiesTag) {
                insets.push(inset);
                continue;
            }
            // deleting last character removes the whole tag
            if (diff.removed === 1 && diff.added === 0 && tagEnd === sel.end) {
                insets.push(new Inset(""));
                this.removedLastCharOfTag = true;
                this.removedInset = inset;
                continue;
            }
            // Of change only occurs inside this tag and does not change surrounding text,
            // only apply the splice to the tag and prevent outsides from changing.
            if (sel.onlyInsideTag) {
                this.preventSplice = true;
            }
            let clipStart = Math.max(0, sel.start - tagStart);
            let clipEnd = Math.max(0, sel.end - tagStart);
            let clipLength = clipEnd - clipStart;
            let modifiedTag;
            if (diff.added > 0 && sel.bleedsOutsideTag) {
                modifiedTag = splice(inset.text, clipStart, clipLength);
            } else {
                modifiedTag = splice(inset.text, clipStart, clipLength, diff.insertion!);
            }
            insets.push(new Inset(modifiedTag));
        }
    }

    // If user modified tag, it becomes plain string. But we only want valid tags in this.insets.
    // This method removes such string from this.insets and merges it with surrounding string from this.messageParts
    pruneColdInsets() {
        for (let i = 0; i < this.insets.length; i++) {
            let inset = this.insets[i];
            if (!inset.isActive) {
                let newPart = this.messageParts[i] + inset.text + this.messageParts[i + 1];
                this.insets.splice(i, 1);
                this.messageParts.splice(i, 2, newPart);
                i--;
            }
        }
    }

    parseRawString(rawString: string): void {
        this.messageParts = rawString.split(rawTagRegex);
        this.insets = (rawString.match(rawTagRegex) || [])
            .map(tagToId)
            .map(id => this.getUser(id) || { id })
            .map(user => new Inset(user!));
    }

    createAll() {
        if (this.shadowContent === undefined) {
            this.createShadowContent();
        }
        if (this.translatedString === undefined) {
            this.createTranslatedString();
        }
        if (this.rawString === undefined) {
            this.createRawString();
        }
        if (this.terminatedString === undefined) {
            this.createTerminatedString();
        }
    }

    createShadowContent() {
        let tags = this.insets.map(inset => (inset.isActive ? <Tag inset={inset} /> : inset.text));
        this.shadowContent = compileArray(this.messageParts, tags);
    }

    createTranslatedString() {
        let tags = this.insets.map(inset => inset.text);
        this.translatedString = compileString(this.messageParts, tags);
    }

    createRawString(): void {
        let tags = this.insets.map(inset => inset.raw || inset.text);
        this.rawString = compileString(this.messageParts, tags);
    }

    createTerminatedString(): void {
        let charCode = 0;
        let terminators = this.insets.map(inset => {
            charCode++;
            if (disallowedNonPrintables.indexOf(charCode) !== -1) {
                charCode++;
            }
            if (inset.isActive) {
                return createTermination(charCode, inset.text.length);
            } else {
                return inset.text;
            }
        });
        this.terminatedString = compileString(this.messageParts, terminators);
    }

    splitTerminatedString(terminatedString: string): string[] {
        // ascii 0 - 32 are nonprintable characters.
        let parts = [terminatedString];
        let charCodes = unique(terminatedString.match(nonPrintableCharRegex) || []).map(getCharCode);
        for (let charCode of charCodes) {
            let regex = new RegExp(`${String.fromCharCode(charCode)}+`, "g");
            for (let partIndex = 0; partIndex < parts.length; partIndex++) {
                let part = parts[partIndex];
                let splitted = part.split(regex);
                parts.splice(partIndex, 1, ...splitted);
            }
        }
        return parts;
    }

    @b.bind translateTag(tag: string): string {
        if (isRawTag(tag)) {
            let id = tagToId(tag);
            let user = this.getUser(id);
            return formatUser(user);
        } else {
            return tag;
        }
    }

    @b.bind getUser(id: number): User | undefined {
        return this.userList.find(user => user.id === id);
    }
}

function unique<T>(array: T[]): T[] {
    let output = [];
    for (let item of array) {
        if (array.indexOf(item) !== -1) {
            output.push(item);
        }
    }
    return output;
}

function createTermination(code: number, length: number) {
    return repeat(String.fromCharCode(code), length);
}

function getCharCode(char: string) {
    return char.charCodeAt(0);
}

function compileArray(messageParts: string[], fillers: b.IBobrilChild[]): b.IBobrilChild[] {
    let tmp = messageParts.length - 1;
    let arr = [];
    for (let i = 0; i < tmp; i++) {
        arr.push(messageParts[i]);
        arr.push(fillers[i]);
    }
    arr.push(messageParts[tmp]);
    return arr;
}

function compileString(messageParts: string[], fillers: string[]): string {
    return compileArray(messageParts, fillers).join("");
}

export function splice(input: string, start: number, removed: number, insertion?: string): string {
    let charArray = input.split("");
    charArray.splice(start, removed, insertion!);
    return charArray.join("");
}

export function formatUser(user: User | undefined): string {
    if (user && user.name) return user.name;
    if (user && user.id === 0) return g.t("Everyone");
    return g.t("Unknown User");
}

export function idToRawTag(id: number): string {
    return `@{${id}}`;
}

function isRawTag(tag: string): boolean {
    return tag.startsWith("@{") && tag.endsWith("}");
}

function tagToId(tag: string): number {
    return parseInt(tag.slice(2, -1));
}

function repeat(char: string, count: number) {
    let output = "";
    for (let i = 0; i < count; i++) {
        output += char;
    }
    return output;
}
