import * as b from "bobril";
import { Textarea, IData as ITexarea, ICustomTheme } from "bobwai--textarea";
import * as s from "./style";
import { SuggestionList } from "./suggestionBox";
import { everyoneId, User, keys, removeDiacritics, includes, prevent } from "./utils";
import { State, sanitizeString, idToRawTag, splice, formatUser } from "./state";
import { Diff, diffStrings } from "./diff";
import { PositionedOverlay, VerticalAlignment, HorizontalAlignment } from "./overlay";

export * from "./utils";

export interface IData extends ITexarea {
    userList: User[];
}

const maxVisibleItems = 6;

export default class TaggedTextarea extends b.Component<IData> {
    node?: HTMLElement | null;
    textareaStyle?: ICustomTheme;
    textareaNode?: HTMLTextAreaElement | null;
    scrollbarWidth = 0;
    state?: State;
    // absolute pixel position of suggestion box
    // index of arrow-up/arrow-down controlled selection in suggestion box.
    selectedIndex: number = 0;
    // location of tag, starting with @
    tagStartIndex: number = 0;
    tagLength: number = 0;

    suggestionOverlay?: PositionedOverlay;

    posCalcRef?: b.IBobrilCacheNode;

    init() {
        this.onExternalDataChange(this.data.value);
        if (this.data.customTheme) {
            this.textareaStyle = Object.assign({}, s.textareaDefaultStyle, this.data.customTheme);
        } else {
            this.textareaStyle = Object.assign({}, s.textareaDefaultStyle);
        }
    }

    postInitDom() {
        this.node = b.getDomNode(this.me) as HTMLElement;
        this.textareaNode = this.node.querySelector("textarea") as HTMLTextAreaElement;
        this.textareaNode.style.color = "rgba(0,0,0,0)";
        this.textareaNode.style.caretColor = "#000";
        this.textareaNode.addEventListener("keydown", this.onTextAreaKeyDown);
        this.textareaNode.addEventListener("blur", this.onTextAreaBlur);
        this.textareaNode.addEventListener("click", this.onTextAreaClick);
        this.textareaNode.addEventListener("scroll", this.onTextAreaScroll);
        window.addEventListener("resize", this.updateScrolbarWidth);
        this.updateScrolbarWidth();
        this.suggestionOverlay = new PositionedOverlay({
            ctx: this,
            offsetX: -4,
            offsetY: 4,
            alignX: HorizontalAlignment.RightFromLeftEdge,
            alignY: VerticalAlignment.Bottom,
            render: this.renderOverlay
        });
    }

    destroy() {
        this.textareaNode!.removeEventListener("blur", this.onTextAreaBlur);
        this.textareaNode!.removeEventListener("click", this.onTextAreaClick);
        this.textareaNode!.removeEventListener("scroll", this.onTextAreaScroll);
        window.removeEventListener("resize", this.updateScrolbarWidth);
        this.suggestionOverlay!.destroy();
    }

    render(): b.IBobrilChildren {
        if (this.suggestionOverlay) {
            this.suggestionOverlay.update();
        }
        if (this.data.value !== this.state!.rawString) {
            // the data was updated externally and we have to recreate this.state from it.
            this.onExternalDataChange(this.data.value);
        }
        return (
            <div style={[s.wrapperStyle, this.heightStyle]}>
                <div style={[s.containerStyle, this.heightStyle]}>
                    <Textarea
                        {...this.data}
                        value={this.state!.translatedString}
                        onChange={this.onChange}
                        customTheme={this.textareaStyle}
                        onVerticalScroolVisibilityChange={scrollbarWidth => {
                            this.scrollbarWidth = scrollbarWidth;
                            b.invalidate(this);
                        }}
                    ></Textarea>
                    <div style={this.shadowStyle}>{this.state!.shadowContent}</div>
                    <div style={[this.shadowStyle, s.hiddenStyle]} ref={node => (this.posCalcRef = node)}></div>
                </div>
            </div>
        );
    }

    @b.bind renderOverlay(): b.IBobrilChildren {
        return (
            <SuggestionList
                totalUserCount={this.data.userList.length}
                userList={this.filteredUserList}
                maxVisibleItems={maxVisibleItems}
                selectedIndex={this.selectedIndex}
                onSelect={this.onListItemSelected}
            />
        );
    }

    get heightStyle(): b.IBobrilStyles {
        return this.data.autoHeight && { height: "100%" };
    }

    @b.bind updateScrolbarWidth(): void {
        let node = this.textareaNode!;
        let style = window.getComputedStyle(node);
        let borderLeft = parseFloat(style.borderLeftWidth || "0");
        let borderRight = parseFloat(style.borderRightWidth || "0");
        this.scrollbarWidth = node.offsetWidth - node.clientWidth - borderLeft - borderRight;
        b.invalidate(this);
    }

    @b.bind onTextAreaScroll() {
        b.invalidate(this);
    }

    get shadowStyle(): b.IBobrilStyles {
        let scrollX = this.textareaNode ? this.textareaNode.scrollLeft : 0;
        let scrollY = this.textareaNode ? this.textareaNode.scrollTop : 0;
        return [
            s.textareaDefaultStyle as b.IBobrilStyle,
            s.shadowStyle,
            {
                marginRight: this.scrollbarWidth,
                transform: `translate(${-scrollX}px, ${-scrollY}px)` // TOOD: remove
            }
        ];
    }
    // TAG TYPING & TRIGGERING SUGGESTION BOX WITH @

    // content of the tag thats currently being written, minus the @
    get slugRaw(): string {
        return this.state!.translatedString!.substr(this.slugStart, this.slugLength);
    }

    // Sanitized and lowercase variant, safe for filtering.
    get slug(): string {
        return removeDiacritics(this.slugRaw).toLowerCase();
    }

    // Index of the start of the tag text after @
    get slugStart(): number {
        return this.tagStartIndex + 1;
    }

    // Length of the start of the tag text after @
    get slugLength(): number {
        return this.tagLength - 1;
    }

    tagMatches(text: string): boolean {
        return includes(text, this.slug);
    }

    get filteredUserList(): User[] {
        let userList = [...this.data.userList];
        if (this.slug.length > 0) {
            userList = userList.filter(user => {
                let safeName = removeDiacritics(user.name!.toLowerCase());
                return this.tagMatches(safeName);
            });
        }
        let printedIds = this.state!.insets.map(inset => inset.id);
        if (printedIds.length > 0) {
            userList = userList.filter(user => !includes(printedIds, user.id));
        }
        if (!includes(printedIds, everyoneId)) {
            if (this.slugLength === 0 || this.tagMatches("everyone") || this.tagMatches("all")) {
                userList.unshift({ id: everyoneId });
            }
        }
        return userList;
    }

    createStateFromData(rawString: string | undefined = "") {
        rawString = sanitizeString(rawString);
        this.state = State.fromRawString(rawString, this.data.userList);
    }

    @b.bind onChange(newTranslatedString: string) {
        let diff = this.updateState(newTranslatedString);
        if (this.state!.removedLastCharOfTag) {
            this.cursorOffset = diff.start - this.state!.removedInset!.text.length + 1;
        }
    }

    updateState(newTranslatedString: string): Diff {
        let lastState = this.state!;
        let diff = diffStrings(lastState.translatedString!, newTranslatedString);
        this.state = State.fromStateAndDiff(lastState, diff, this.data.userList);
        if (diff.insertion === "@") {
            this.tagStartIndex = diff.start;
            this.tagLength = 1; // 1 accounts for the @
            this.showSuggestionList();
        } else if (this.suggestionOverlay!.visible) {
            this.tagLength += diff.added;
            this.tagLength -= diff.removed;
            this.selectedIndex = this.clampUserListIndex(this.selectedIndex);
        }
        this.data.onChange && this.data.onChange(this.state!.rawString!);
        b.invalidate(this);
        return diff;
    }

    showSuggestionList() {
        if (this.suggestionOverlay!.visible === false) {
            this.selectedIndex = 0;
            let container = b.getDomNode(this.posCalcRef) as HTMLElement;
            container.textContent = this.state!.translatedString!.substr(0, this.cursorOffset - 1);
            const anchor = document.createElement("span");
            anchor.textContent = "@";
            container.appendChild(anchor);
            this.suggestionOverlay!.show(anchor, {
                width: s.suggestionBoxWidth,
                height: s.suggestionItemHeight * this.visibleListItemsCount
            });
        }
    }

    hideSuggestionList() {
        this.suggestionOverlay!.hide();
    }

    onExternalDataChange(rawString: string | undefined) {
        this.createStateFromData(rawString);
    }

    @b.bind onTextAreaBlur() {
        // WARNING: blur triggers before click when clicking on item in suggest box.
        // We have to wait a tick and give the item.onClick a chance to be handled before hiding the suggestion box.
        setTimeout(() => {
            this.hideSuggestionList();
            b.invalidate(this);
        }, 300);
    }

    @b.bind onTextAreaClick() {
        this.hideSuggestionList();
        b.invalidate(this);
    }

    // handles & steals keydown events from bobwai--textarea's <textarea> DOM element.
    // important for stopping cursor from moving or any other unwanted action while suggestion box is opened.
    @b.bind onTextAreaKeyDown(e: KeyboardEvent) {
        if (this.suggestionOverlay!.visible) {
            switch (e.keyCode) {
                case keys.ARROW_UP:
                    prevent(e);
                    this.selectedIndex = this.clampUserListIndex(this.selectedIndex - 1);
                    b.invalidate(this);
                    break;
                case keys.ARROW_DOWN:
                    prevent(e);
                    this.selectedIndex = this.clampUserListIndex(this.selectedIndex + 1);
                    b.invalidate(this);
                    break;
                case keys.ENTER:
                    prevent(e);
                    this.onListItemSelected(this.selectedIndex);
                    this.hideSuggestionList();
                    b.invalidate(this);
                    break;
                case keys.ESC:
                    prevent(e);
                    this.hideSuggestionList();
                    b.invalidate(this);
                    break;
                case keys.BACKSPACE:
                    if (this.slugLength <= 0) {
                        this.hideSuggestionList();
                    }
                    break;
                case keys.HOME:
                    prevent(e);
                    this.cursorOffset = this.slugStart;
                    break;
                case keys.END:
                    prevent(e);
                    this.cursorOffset = this.slugStart + this.slugLength;
                    break;
                case keys.PAGE_UP:
                case keys.PAGE_DOWN:
                case keys.ARROW_LEFT:
                case keys.ARROW_RIGHT:
                    this.hideSuggestionList();
                    b.invalidate(this);
            }
        }
    }

    // ITEM LIST

    get visibleListItemsCount() {
        return Math.min(maxVisibleItems, this.filteredUserList.length);
    }

    clampUserListIndex(newIndex: number) {
        // subtracting -1 becase we're dealing with array lengths and expect indexes
        return Math.max(Math.min(newIndex, maxVisibleItems - 1, this.filteredUserList.length - 1), 0);
    }

    @b.bind onListItemSelected(index: number) {
        let user = this.filteredUserList[index];
        if (user) {
            this.insertUserTag(user);
        }
    }

    insertUserTag(selectedUser: User): void {
        let translatedTag = formatUser(selectedUser);
        let rawTag = idToRawTag(selectedUser.id);
        let newTranslatedString = splice(this.state!.translatedString!, this.tagStartIndex, this.tagLength, rawTag);
        this.hideSuggestionList();
        this.updateState(newTranslatedString);
        let newCursorPos = this.tagStartIndex + translatedTag.length;
        this.textareaNode!.focus();
        this.cursorOffset = newCursorPos;
    }

    // CURSOR & TAG POSITION

    get cursorOffset(): number {
        return this.textareaNode!.selectionStart;
    }

    set cursorOffset(offset: number) {
        // move the cursor immediately in case we don't need to wait for dom re-render.
        this.applyCursorOffset(offset);
        // need to wait before DOM is rendered.
        setTimeout(() => this.applyCursorOffset(offset));
        // IE needs to wait little longer
        setTimeout(() => this.applyCursorOffset(offset), 100);
    }

    applyCursorOffset(offset: number) {
        let textarea = this.textareaNode!;
        textarea.selectionStart = textarea.selectionEnd = offset;
    }
}

export var create = b.component(TaggedTextarea, "bobwai--textarea-tagged");

export function translateTaggedTextToString(rawString: string, userList: User[] = []): string {
    let state = new State(userList);
    state.parseRawString(rawString);
    state.createTranslatedString();
    return state.translatedString!;
}

export function translateTaggedTextToNodes(rawString: string, userList: User[] = []): b.IBobrilChildren {
    let state = new State(userList);
    state.parseRawString(rawString);
    state.createShadowContent();
    return state.shadowContent!;
}

interface TaggedTextTranslation {
    text: string;
    nodes: b.IBobrilChildren;
}

export function translateTaggedText(rawString: string, userList: User[] = []): TaggedTextTranslation {
    let state = new State(userList);
    state.parseRawString(rawString);
    state.createTranslatedString();
    state.createShadowContent();
    return {
        text: state.translatedString!,
        nodes: state.shadowContent!
    };
}
