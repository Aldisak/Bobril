import * as b from "bobril";
import * as Color from "bobwai--color";
import { Inset } from "./state";
import { User } from "./utils";
import { PositionedOverlay, VerticalAlignment, HorizontalAlignment } from "./overlay";
import { UserInfoBox } from "./suggestionBox";
import * as s from "./style";

interface ITag {
    inset: Inset;
}

//const tagHoverDelay = 500;
const tagHoverDelay = 0;

// each board covered in separate span tag to be able to handle line breaks properly
function eachWordAsSpan(text: string): b.IBobrilChildren {
    let spans = text.split(" ").map(word => <span>{word}</span>);
    let output: b.IBobrilChildren = [spans[0]];
    for (let i = 1; i < spans.length; i++) {
        output.push(" ", spans[i]);
    }
    return output;
}

export class Tag extends b.Component<ITag> {
    render() {
        return <span style={[this.tagLook]}>{eachWordAsSpan(this.data.inset.text)}</span>;
    }

    node?: HTMLElement;
    //taggedTextarea?: TaggedTextarea;
    overlay?: PositionedOverlay;
    hoverDelay?: number;

    postInitDom() {
        this.node = b.getDomNode(this.me) as HTMLElement;
        this.overlay = new PositionedOverlay({
            ctx: this,
            width: s.suggestionBoxWidth,
            height: s.suggestionItemHeight,
            offsetX: -s.suggestionBoxWidth / 2,
            offsetY: 4,
            alignX: HorizontalAlignment.Center,
            alignY: VerticalAlignment.Bottom,
            render: this.renderOverlay
        });
    }

    @b.bind renderOverlay(): b.IBobrilChildren {
        return <UserInfoBox user={this.user!} />;
    }

    get user(): User {
        return this.data.inset.user!;
    }

    destroy() {
        this.overlay!.destroy();
    }

    get tagLook(): b.IBobrilStyle {
        return {
            pointerEvents: "all",
            cursor: "pointer",
            userSelect: "none",
            borderRadius: 3,
            color: Color.Chart_Purple500
        };
    }

    onMouseEnter(e: b.IBobrilMouseEvent): void {
        this.hoverDelay = setTimeout(() => {
            let user = this.data.inset.user!;
            if (user.name) {
                let coord = this.unwrapWordNode((e.target.element as HTMLElement) || this.node);
                this.overlay!.show(coord);
            }
        }, tagHoverDelay);
    }

    unwrapWordNode(anchor: HTMLElement): HTMLElement {
        // each board covered in separate span tag.
        // but we only want to hover user box around the single word span if the tag is line-broken.
        if (anchor !== this.node && this.node!.offsetHeight === anchor.offsetHeight) {
            // use the whole tag if we're not in line break
            anchor = this.node!;
        }
        return anchor;
    }

    onMouseLeave(): void {
        clearTimeout(this.hoverDelay);
        this.overlay!.hide();
    }
}
