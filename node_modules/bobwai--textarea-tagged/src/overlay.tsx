import * as b from "bobril";
import { Coord, clamp } from "./utils";
import * as s from "./style";

const htmlNode = document.documentElement;
const bodyNode = document.body;

interface Size {
    width?: number;
    height?: number;
}

export enum VerticalAlignment {
    Top,
    Center,
    Bottom
}

export enum HorizontalAlignment {
    Left,
    RightFromLeftEdge,
    Center,
    LeftFromRightEdge,
    Right
}

interface OverlayData extends Size {
    ctx?: b.IBobrilCtx;
    offsetX?: number;
    offsetY?: number;
    alignX?: HorizontalAlignment;
    alignY?: VerticalAlignment;
    render: () => b.IBobrilChildren;
}

export class PositionedOverlay {
    coord?: Coord;
    overlayId?: string;
    visible = false;
    watchingScroll = false;
    data: OverlayData;
    alignX?: HorizontalAlignment;
    alignY?: VerticalAlignment;
    x = 0;
    y = 0;

    constructor(data: OverlayData) {
        this.data = data;
    }

    destroy() {
        this.hide();
    }

    // to be implemented by inheritor
    @b.bind renderRoot(): b.IBobrilChildren {
        return <div style={this.positionStyle}>{this.data.render()}</div>;
    }

    calculateCoord(anchor: HTMLElement, newSize?: Size): void {
        // WARNING: Edge counts scroll on <body>, other browsers do it on <html>
        let anchorBbox = anchor!.getBoundingClientRect();
        let bodyScrollX = htmlNode.scrollLeft || bodyNode.scrollLeft;
        let bodyScrollY = htmlNode.scrollTop || bodyNode.scrollTop;
        let offsetX = this.data.offsetX || 0;
        let offsetY = this.data.offsetY || 0;
        this.alignX = this.data.alignX;
        this.alignY = this.data.alignY;
        this.x = 0;
        this.y = 0;
        let width = (newSize && newSize.width) || this.data.width || 0;
        let height = (newSize && newSize.height) || this.data.height || 0;

        if (this.alignX === HorizontalAlignment.Center) {
            this.x = anchorBbox.left + anchorBbox.width / 2 - width / 2 + bodyScrollX;
        } else if (this.alignX === HorizontalAlignment.Left) {
            this.x = window.innerWidth - (anchorBbox.left + bodyScrollX + offsetX);
        } else if (this.alignX === HorizontalAlignment.RightFromLeftEdge) {
            this.x = anchorBbox.left + bodyScrollX + offsetX;
        }

        if (this.alignY === VerticalAlignment.Top || (height > 0 && anchorBbox.bottom + height > window.innerHeight)) {
            this.alignY = VerticalAlignment.Top;
            this.y = window.innerHeight - (anchorBbox.top + bodyScrollY - offsetY);
        } else if (this.alignY === VerticalAlignment.Center) {
            this.y = anchorBbox.top + anchorBbox.height / 2 - height / 2 + bodyScrollY;
        } else if (this.alignY === VerticalAlignment.Bottom) {
            this.y = anchorBbox.bottom + offsetY + bodyScrollY;
        }

        if (this.alignY === VerticalAlignment.Top || this.alignY === VerticalAlignment.Bottom) {
            let min = s.offsetFromViewportEdge;
            let max = window.innerWidth - width - s.offsetFromViewportEdge;
            this.x = clamp(min, this.x, max);
        }
        if (this.alignX === HorizontalAlignment.Left || this.alignX === HorizontalAlignment.Right) {
            let min = s.offsetFromViewportEdge;
            let max = window.innerHeight - height - s.offsetFromViewportEdge;
            this.y = clamp(min, this.y, max);
        }
    }

    get positionStyle(): b.IBobrilStyle {
        let left, right, top, bottom;
        if (this.alignX === HorizontalAlignment.Left) {
            right = this.x;
        } else {
            left = this.x;
        }
        if (this.alignY === VerticalAlignment.Top) {
            bottom = this.y;
        } else {
            top = this.y;
        }
        return {
            position: "absolute",
            left,
            right,
            top,
            bottom
        };
    }

    show(anchor: HTMLElement, newSize?: Size): void {
        this.calculateCoord(anchor, newSize);
        this.visible = true;
        this.startWatchingScroll();
        this.overlayId = b.addRoot(this.renderRoot);
        b.invalidate(this.data.ctx);
    }

    update() {
        if (this.overlayId) {
            b.updateRoot(this.overlayId);
        }
    }

    hide(): void {
        this.visible = false;
        this.stopWatchingScroll();
        if (this.overlayId) {
            b.removeRoot(this.overlayId);
            this.overlayId = undefined;
        }
        b.invalidate(this.data.ctx);
    }

    startWatchingScroll(): void {
        if (!this.watchingScroll) {
            this.watchingScroll = true;
            // third argument (capture) is neede to catch all bubling events from any element, not just window
            window.addEventListener("scroll", this.onAnyScroll, true);
        }
    }

    stopWatchingScroll(): void {
        if (this.watchingScroll) {
            this.watchingScroll = false;
            window.removeEventListener("scroll", this.onAnyScroll, true);
        }
    }

    @b.bind onAnyScroll(): void {
        this.hide();
        b.invalidate(this.data.ctx);
    }
}
