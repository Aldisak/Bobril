import { User } from "../src/utils";
import { State } from "../src/state";

let userList: User[] = [
    {
        id: 111,
        name: "Michal Kovařík"
    },
    {
        id: 222,
        name: "Tomáš Pospíšil"
    },
    {
        id: 333,
        name: "Adam Obrtel"
    },
    {
        id: 444,
        name: "Tomáš Sychra"
    }
];

describe("Basic translation", () => {
    it("should translate simple single tag", () => {
        let input = "Hello @{111}";
        let output = "Hello Michal Kovařík";
        let state = State.fromRawString(input, userList);
        expect(state.rawString).toBe(input);
        expect(state.translatedString).toBe(output);
    });

    it("should translate simple two tags", () => {
        let input = "Hello @{111} @{222}";
        let output = "Hello Michal Kovařík Tomáš Pospíšil";
        let state = State.fromRawString(input, userList);
        expect(state.rawString).toBe(input);
        expect(state.translatedString).toBe(output);
    });

    it("should translate adjacent tags", () => {
        let input = "@{111}@{222}@{333}";
        let output = "Michal KovaříkTomáš PospíšilAdam Obrtel";
        let state = State.fromRawString(input, userList);
        expect(state.rawString).toBe(input);
        expect(state.translatedString).toBe(output);
    });

    it("should retain spaces tags", () => {
        let input = "@{111}   @{222}";
        let output = "Michal Kovařík   Tomáš Pospíšil";
        let state = State.fromRawString(input, userList);
        expect(state.rawString).toBe(input);
        expect(state.translatedString).toBe(output);
    });

    it("should handle additional @", () => {
        let input = "@@{111}   @@@{222}@";
        let output = "@Michal Kovařík   @@Tomáš Pospíšil@";
        let state = State.fromRawString(input, userList);
        expect(state.rawString).toBe(input);
        expect(state.translatedString).toBe(output);
    });

    it("should retain special character", () => {
        let input = "-*/@{111};+ěš@{222}¨)=";
        let output = "-*/Michal Kovařík;+ěšTomáš Pospíšil¨)=";
        let state = State.fromRawString(input, userList);
        expect(state.rawString).toBe(input);
        expect(state.translatedString).toBe(output);
    });

    it("handles 16 tags bare", () => {
        let rawString = "@{111} @{222} @{333} @{444} ".repeat(4);
        let translatedString = "Michal Kovařík Tomáš Pospíšil Adam Obrtel Tomáš Sychra ".repeat(4);
        let state = State.fromRawString(rawString, userList);
        expect(state.insets.length).toBe(16);
        expect(state.rawString).toBe(rawString);
        expect(state.translatedString).toBe(translatedString);
    });

    it("handles 16 tags surrounded", () => {
        let rawString = "lorem @{111} ipsum @{222} dolor @{333} sit @{444} amet, ".repeat(4);
        let translatedString = "lorem Michal Kovařík ipsum Tomáš Pospíšil dolor Adam Obrtel sit Tomáš Sychra amet, ".repeat(4);
        let state = State.fromRawString(rawString, userList);
        expect(state.insets.length).toBe(16);
        expect(state.rawString).toBe(rawString);
        expect(state.translatedString).toBe(translatedString);
    });
});

describe("internal properties", () => {
    describe("retaining integrity of State properties", () => {
        it(".rawString should be string", () => {
            let input = "Hello @{111}";
            let state = State.fromRawString(input, userList);
            expect(state.rawString).toEqual(jasmine.any(String));
        });

        it(".translatedString should be string", () => {
            let input = "Hello @{111}";
            let state = State.fromRawString(input, userList);
            expect(state.translatedString).toEqual(jasmine.any(String));
        });

        it(".shadowContent should be array", () => {
            let input = "Hello @{111}";
            let state = State.fromRawString(input, userList);
            expect(state.shadowContent).toEqual(jasmine.any(Array));
        });

        it(".shadowContent should contain bobril nodes", () => {
            let input = "Hello @{111}";
            let state = State.fromRawString(input, userList);
            expect(state.shadowContent![1]).toEqual(jasmine.any(Object));
        });
    });

    describe("retaining integrity after several splices", () => {
        it(".rawString should be string", () => {
            let rawString = "abc@{111}@{222}@{333} def"; // "abcMichal KovaříkTomáš PospíšilAdam Obrtel def";
            let diff1 = { start: 31, removed: 0, added: 1, insertion: "-" };
            let diff2 = { start: 17, removed: 0, added: 1, insertion: "-" };
            let initState = State.fromRawString(rawString, userList);
            let midState = State.fromStateAndDiff(initState, diff1, userList);
            let endState = State.fromStateAndDiff(midState, diff2, userList);
            expect(endState.rawString).toEqual(jasmine.any(String));
        });

        it(".translatedString should be string", () => {
            let rawString = "abc@{111}@{222}@{333} def"; // "abcMichal KovaříkTomáš PospíšilAdam Obrtel def";
            let diff1 = { start: 31, removed: 0, added: 1, insertion: "-" };
            let diff2 = { start: 17, removed: 0, added: 1, insertion: "-" };
            let initState = State.fromRawString(rawString, userList);
            let midState = State.fromStateAndDiff(initState, diff1, userList);
            let endState = State.fromStateAndDiff(midState, diff2, userList);
            expect(endState.translatedString).toEqual(jasmine.any(String));
        });

        it(".shadowContent should be array 1", () => {
            let rawString = "abc@{111}@{222}@{333} def"; // "abcMichal KovaříkTomáš PospíšilAdam Obrtel def";
            let diff1 = { start: 31, removed: 0, added: 1, insertion: "-" };
            let diff2 = { start: 17, removed: 0, added: 1, insertion: "-" };
            let initState = State.fromRawString(rawString, userList);
            let midState = State.fromStateAndDiff(initState, diff1, userList);
            let endState = State.fromStateAndDiff(midState, diff2, userList);
            expect(endState.shadowContent).toEqual(jasmine.any(Array));
        });

        it(".shadowContent should be array 2", () => {
            let rawString = "abc@{111}@{222}@{333} def"; // "abcMichal KovaříkTomáš PospíšilAdam Obrtel def";
            let diff = { start: 22, removed: 1, added: 1, insertion: "-" };
            let initState = State.fromRawString(rawString, userList);
            let midState = State.fromStateAndDiff(initState, diff, userList);
            let endState = State.fromStateAndDiff(midState, diff, userList);
            expect(endState.shadowContent).toEqual(jasmine.any(Array));
        });

        it(".shadowContent should contain bobril nodes", () => {
            let rawString = "abc@{111}@{222}@{333} def"; // "abcMichal KovaříkTomáš PospíšilAdam Obrtel def";
            let diff1 = { start: 31, removed: 0, added: 1, insertion: "-" };
            let diff2 = { start: 17, removed: 0, added: 1, insertion: "-" };
            let initState = State.fromRawString(rawString, userList);
            let midState = State.fromStateAndDiff(initState, diff1, userList);
            let endState = State.fromStateAndDiff(midState, diff2, userList);
            expect(endState.shadowContent![1]).toEqual(jasmine.any(Object));
            expect(endState.shadowContent![3]).toEqual(jasmine.any(Object));
            expect(endState.shadowContent![5]).toEqual(jasmine.any(Object));
        });
    });
});

/*
describe("finding ", () => {

    it("should translate adjacent tags", () => {
        let input = "@{111}@{222}@{333}";
        let state = State.fromRawString(input, userList);
        expect(state.rawString).toBe(input);
        expect(state.translatedString).toBe(output);
    });

});
*/
