import * as b from "bobril";
import * as font from "bobwai--font";
import * as MockHeaderText from "./mockComponents/header";
import * as MockMessage from "./mockComponents/message";
import * as MockLabel from "./mockComponents/label";
import * as MockLink from "./mockComponents/link";
import * as MockColor from "./mockComponents/color";

import * as styles from "./styles";

font.init();

const eventTypeMessage: string = "message";
const allStringValue: string = "All";

export let create = b.createComponent<IData>({
    id: "bobwai--viewer-container",
    init(ctx: IContext) {
        ctx.viewState = getDefaultViewState();
        if (ctx.data.messageListeningDisabled) {
            return;
        }
        const paramTypical = getUrlParameter("typical");
        if (paramTypical !== undefined && paramTypical.length > 0) {
            ctx.viewState.typicalOnly = paramTypical === "1";
        }
        const paramId = getUrlParameter("id");
        if (paramId !== undefined && paramId.length > 0) {
            ctx.viewState.filteredIds = paramId.split("|");
        }
        const paramPure = getUrlParameter("pure");
        if (paramPure !== undefined && paramPure.length > 0) {
            ctx.viewState.isPure = paramPure === "1";
        }
        ctx.receiveMessageCallback = (event: MessageEvent) => {
            const myOrigin = window.location.port
                ? `${window.location.protocol}//${window.location.hostname}:${window.location.port}`
                : `${window.location.protocol}//${window.location.hostname}`;
            if (event.origin !== myOrigin) {
                return; // Event origin is not on same-origin discard message
            }
            const message: IContainerViewState = event.data;
            if (message.graphicType === undefined || message.withTest === undefined) {
                return; // Message format does not match
            }
            ctx.viewState.graphicType = message.graphicType;
            ctx.viewState.withTest = message.withTest;
            ctx.viewState.typicalOnly = message.typicalOnly;
            b.invalidate(ctx);
        };
        window.addEventListener(eventTypeMessage, <(event: Event) => void>ctx.receiveMessageCallback, false);
    },
    render(ctx: IContext, me: b.IBobrilNode): void {
        if (ctx.viewState.typicalOnly && ctx.data.type !== Type.typical) {
            return;
        }
        if (
            ctx.viewState.filteredIds &&
            ctx.viewState.filteredIds.length > 0 &&
            (!ctx.data.id || ctx.viewState.filteredIds.indexOf(ctx.data.id) === -1)
        ) {
            return;
        }
        if (!ctx.viewState.withTest && (ctx.data.isTest || ctx.data.isForConstantOverride)) {
            return;
        }
        if (ctx.viewState.graphicType !== "All") {
            if (ctx.data.type === undefined && ctx.viewState.graphicType !== Type[Type.default]) {
                return;
            } else if (ctx.data.type !== undefined && ctx.viewState.graphicType !== Type[ctx.data.type]) {
                return;
            }
        }
        const isDecorated = !ctx.viewState.isPure;
        b.style(me, styles.containerStyle);
        me.children = [
            isDecorated && getHeader(ctx),
            isDecorated &&
                ctx.data.description &&
                MockLabel.create({
                    content: ctx.data.description
                }),
            isDecorated &&
                (ctx.data.highlightedDescription || ctx.data.isForConstantOverride) &&
                b.styledDiv(
                    MockLabel.create({
                        content: ctx.data.isForConstantOverride ? "Affects all examples above/below" : ctx.data.highlightedDescription,
                        isBolder: true,
                        validationState: MockLabel.ValidationState.Error
                    })
                ),
            getExampleContent(ctx),
            isDecorated &&
                ctx.data.model && [b.styledDiv("Model:", styles.subtitleStyle), { tag: "div", children: JSON.stringify(ctx.data.model) }]
        ];
    },
    destroy(ctx: IContext) {
        window.removeEventListener(eventTypeMessage, <(event: Event) => void>ctx.receiveMessageCallback, false);
    }
});

export interface IData {
    header?: string;
    /** Preferred way - default for tsx */
    children?: b.IBobrilChildren;
    /** OBSOLETE - use children property */
    content?: b.IBobrilChildren;
    description?: string;
    highlightedDescription?: string;
    model?: any;
    withoutPadding?: boolean;
    size?: Size;
    hasRelativePosition?: boolean;
    type?: Type;
    /** Just for testing some configurations which shouldn't occur. */
    isTest?: boolean;
    /** Specific case of container. Sets header, highlightedDescription and isTest=true. */
    isForConstantOverride?: boolean;
    messageListeningDisabled?: boolean;
    background?: Background;
    id?: string;
}

export interface IContainerViewState {
    typicalOnly?: boolean;
    filteredIds?: string[];
    isPure?: boolean;
    withTest: boolean;
    graphicType: string;
}

export enum Size {
    default,
    small,
    medium
}

/** Sets the type of view */
export enum Type {
    /** Normal view */
    default,
    /** Unofficial variant which should be used in "experimental" application only. Confirmation by UX needed. */
    experimental,
    /** Obsolete behavior of some component functionality */
    deprecated,
    /** typical example which is aimed also for non-technical users of BG */
    typical
}

export enum Background {
    /* Default */
    Light,
    Dark
}

interface IContext extends b.IBobrilCtx {
    data: IData;
    receiveMessageCallback: (event: MessageEvent) => void;
    viewState: IContainerViewState;
}

function getUrlParameter(name: string): string {
    name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
    const regex = new RegExp("[\\?&]" + name + "=([^&#]*)");
    const results = regex.exec(location.search);
    return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
}

function getHeight(data: IData): any {
    switch (data.size) {
        case Size.default:
            return 800;
        case Size.small:
            return 400;
        case Size.medium:
            return 1200;
    }
    return "auto";
}

function getExampleContent(ctx: IContext) {
    let content = b.styledDiv(ctx.data.content || ctx.data.children, [
        styles.plainExampleStyle,
        ctx.data.background === Background.Dark && styles.plainExampleDarkStyle,
        !ctx.data.withoutPadding && styles.paddingExampleStyle,
        ctx.data.hasRelativePosition && styles.containerRelativePositionStyle
    ]);
    content.style = {
        height: getHeight(ctx.data)
    };
    return content;
}

function getHeader(ctx: IContext): b.IBobrilNode {
    let useNotification = false;
    let backgroundColor = "none";
    let notificationType = MockMessage.Type.Error;
    let notificationMessage = "";

    switch (ctx.data.type) {
        case Type.experimental: {
            useNotification = true;
            notificationMessage = "Experimental. Ask UX for using.";
            backgroundColor = MockColor.warning30Color;
            notificationType = MockMessage.Type.Warning;
            break;
        }
        case Type.deprecated: {
            useNotification = true;
            notificationMessage = "Deprecated behavior";
            backgroundColor = MockColor.black20Color;
            notificationType = MockMessage.Type.Error;
            break;
        }
        case Type.typical:
            if (ctx.viewState && !ctx.viewState.typicalOnly) {
                useNotification = true;
                notificationMessage = "Typical usage.";
                backgroundColor = MockColor.info30Color;
                notificationType = MockMessage.Type.Info;
            }
            break;
        case Type.default:
        case undefined: {
            if (ctx.data.isTest || ctx.data.isForConstantOverride) {
                useNotification = true;
                notificationMessage = "For testing purposes only.";
                backgroundColor = MockColor.error30Color;
            }
            break;
        }
        default: {
            assertNever(ctx.data.type);
        }
    }

    return b.styledDiv(
        [
            MockHeaderText.create({
                content: ctx.data.isForConstantOverride ? "Constant override" : ctx.data.header,
                actionContent: b.styledDiv([
                    useNotification &&
                        MockMessage.create({
                            message: notificationMessage,
                            type: notificationType
                        }),
                    ctx.data.id &&
                        (!ctx.viewState.filteredIds || ctx.viewState.filteredIds.length === 0) &&
                        MockLink.create({
                            text: "",
                            param: `id=${ctx.data.id}&toolbar=1&pure=0`,
                            shouldOpenInNewWindow: true,
                            isPermalink: true
                        })
                ])
            })
        ],
        useNotification && { backgroundColor: backgroundColor }
    );
}

function getDefaultViewState(): IContainerViewState {
    return {
        withTest: true,
        graphicType: allStringValue
    };
}

function assertNever(x: never): never {
    throw new Error("Unexpected object: " + x);
}

// added by script - BEGIN
export const ViewerContainer = create;
// added by script - END
