import * as b from "bobril";
import * as styles from "./styles";
import * as ScrollContent from "./scrollContent";
import * as ScrollSize from "helpers--scrollbar-size";
import { isIE, isEdge } from "helpers--browser-identifier";
export { IScrollInfo, IVerticalScrollInfo } from "./scrollContent";

export const create = b.createComponent<IData>({
    id: "bobwai--scroll-shadow",
    init(ctx: IContext, _me: b.IBobrilNode): void {
        if (ctx.data.scrollbarOffset !== undefined || ctx.data.hasBottomBorderWhenScrollable || ctx.data.isShadowFullWidth === false) {
            ctx.verticalScrollbarWidth = ScrollSize.getScrollbarSize().vertical;
        }
    },
    render(ctx: IContext, me: b.IBobrilNode): void {
        const d = ctx.data;
        const contentHeightSettings: IContentHeightSettings = {
            hasContentHeight: d.contentHeight !== undefined,
            hasContentMaxHeight: d.contentMaxHeight !== undefined,
            hasContentMinHeight: d.contentMinHeight !== undefined,
            hasWrapperBeforeHeight: d.wrapperBeforeHeight !== undefined,
        };

        if (ctx.data.scrollbarOffset) {
            // add extra wrap for offset scrollbar
            me.children = b.styledDiv(
                getScrollShadowChildren(ctx, contentHeightSettings),
                getScrollShadowStyles(ctx, contentHeightSettings)
            );
            b.style(me, [
                getScrollShadowWithOffsetWrapperStyle(ctx),
                isBottomBorderActive(ctx) && styles.scrollShadowWithBottomBorderStyle,
            ]);
        } else {
            me.children = getScrollShadowChildren(ctx, contentHeightSettings);
            b.style(me, [
                getScrollShadowStyles(ctx, contentHeightSettings),
                isBottomBorderActive(ctx) && styles.scrollShadowWithBottomBorderStyle,
            ]);
        }
    },
    postInitDom(ctx: IContext, _: b.IBobrilCacheNode, element: HTMLElement): void {
        const contentElement = <HTMLElement>element.getElementsByClassName(styles.contentStyle)[0];
        updateShadowOpacity(contentElement, ctx);

        ctx.onScroll = () => {
            updateShadowOpacity(contentElement, ctx);
        };
        b.addOnScroll(ctx.onScroll);
    },
    postUpdateDomEverytime(ctx: IContext, _: b.IBobrilCacheNode, element: HTMLElement): void {
        const contentElement: HTMLElement = <HTMLElement>element.getElementsByClassName(styles.contentStyle)[0];
        if (ctx.data.scrollbarOffset !== undefined && ctx.verticalScrollbarWidth) {
            if (contentElement.scrollHeight - contentElement.offsetHeight > 1) {
                if (!ctx.isScrollbarActive) {
                    element.style.overflow = "visible";
                    ctx.isScrollbarActive = true;
                    ctx.data.onScrollbarVisibilityChanged && ctx.data.onScrollbarVisibilityChanged(!!ctx.isScrollbarActive);
                }
            } else {
                if (ctx.isScrollbarActive || ctx.isScrollbarActive === undefined) {
                    element.style.overflow = "hidden";
                    ctx.isScrollbarActive = false;
                    ctx.data.onScrollbarVisibilityChanged && ctx.data.onScrollbarVisibilityChanged(!!ctx.isScrollbarActive);
                }
            }
            const actualScrollbarWidth = ScrollSize.getScrollbarSize().vertical;
            if (actualScrollbarWidth !== ctx.verticalScrollbarWidth) {
                ctx.verticalScrollbarWidth = actualScrollbarWidth;
                b.invalidate(ctx);
            }
        }

        updateShadowOpacity(contentElement, ctx);
    },

    destroy(ctx: IContext): void {
        b.removeOnScroll(ctx.onScroll);
    },
});

interface IContentHeightSettings {
    hasContentHeight: boolean;
    hasContentMaxHeight: boolean;
    hasContentMinHeight: boolean;
    hasWrapperBeforeHeight: boolean;
}

function getScrollShadowWithOffsetWrapperStyle(ctx: IContext): b.IBobrilStyle | undefined {
    if (ctx.data.contentHeight !== undefined || ctx.data.contentMinHeight !== undefined || ctx.data.contentMaxHeight !== undefined) {
        return styles.scrollShadowWithOffsetWrapperStyle;
    }
    return styles.scrollShadowWithOffsetWrapperFullSizeStyle;
}

function getScrollShadowChildren(ctx: IContext, contentHeightSettings: IContentHeightSettings): b.IBobrilChildren[] {
    const d = ctx.data;
    return [
        b.style(
            ScrollContent.create({
                content: d.content,
                scrollTop: getAndEraseScrollTop(d),
                elementId: d.scrollContentElementId,
                handleMouseWheelScroll: d.handleMouseWheelScroll,
                scrollbarOffset: d.scrollbarOffset,
                onScrollPositionChanged: d.onScrollPositionChanged,
                onVerticalScrollPositionChanged: d.onVerticalScrollPositionChanged,
                onVisibleContentWidthChanged: d.onVisibleContentWidthChanged,
            }),
            [
                styles.contentStyle,
                d.hasScrollContentRelativePosition && styles.contentRelativeStyle,
                d.isWithSidePadding && styles.contentSidePaddingStyle,
                d.isWithSidePaddingForAsterisks && styles.contentSidePaddingForAsterisksStyle,
                contentHeightSettings.hasContentHeight && { height: d.contentHeight },
                contentHeightSettings.hasContentMaxHeight && { maxHeight: d.contentMaxHeight },
                contentHeightSettings.hasContentMinHeight && { minHeight: d.contentMinHeight },
                !contentHeightSettings.hasContentHeight && styles.fullHeightStyle,
                d.scrollbarOffset &&
                    ctx.verticalScrollbarWidth && {
                        overflowY: "scroll",
                        paddingRight: d.scrollbarOffset - ctx.verticalScrollbarWidth,
                    },
                d.scrollbarOffset && ctx.verticalScrollbarWidth && (isIE() || isEdge()) && styles.scrollShadowOffsetIECorrection,
            ]
        ),
        b.styledDiv(null, [
            getCommonShadowStyles(ctx),
            styles.topShadowStyle,
            { opacity: ctx.topShadowOpacity },
            contentHeightSettings.hasWrapperBeforeHeight && { top: d.wrapperBeforeHeight },
        ]),
        b.styledDiv(null, [getCommonShadowStyles(ctx), styles.bottomShadowStyle, { opacity: ctx.bottomShadowOpacity }]),
        isBottomBorderActive(ctx) && b.styledDiv("", styles.scrollShadowBottomBorderStyle),
    ];
}

function getCommonShadowStyles(ctx: IContext): b.IBobrilStyles {
    const hasShadowSidePadding = ctx.data.isWithSidePadding && !ctx.data.isWithSidePaddingForAsterisks;
    let shadowRightSidePadding = ctx.data.scrollbarOffset && ctx.data.isShadowFullWidth === false ? ctx.data.scrollbarOffset : 0;

    if (hasShadowSidePadding && ctx.data.isShadowFullWidth === false) {
        if (ctx.data.scrollbarOffset) {
            // if offset is active -> right side padding does not make sense
            shadowRightSidePadding += styles.sidePadding;
        } else {
            shadowRightSidePadding += 2 * styles.sidePadding;
        }
    }

    if (ctx.verticalScrollbarWidth && ctx.data.isShadowFullWidth === false && hasShadowSidePadding && !ctx.data.scrollbarOffset) {
        shadowRightSidePadding += ctx.verticalScrollbarWidth;
    }

    return [
        styles.shadowStyle,
        hasShadowSidePadding && ctx.data.isShadowFullWidth === false && styles.shadowLeftSidePaddingStyle,
        { width: `calc(100% - ${2 * styles.shadowBoundary + shadowRightSidePadding}px)` },
    ];
}

function getScrollShadowStyles(ctx: IContext, contentHeightSettings: IContentHeightSettings): b.IBobrilStyles {
    return [
        [
            styles.wrapperStyle,
            ctx.data.hasScrollWrapperOverflowHidden && styles.overflowHiddenStyle,
            !contentHeightSettings.hasContentHeight &&
                contentHeightSettings.hasWrapperBeforeHeight && { height: `calc(100% - ${ctx.data.wrapperBeforeHeight}px)` },
            !contentHeightSettings.hasContentHeight && !contentHeightSettings.hasWrapperBeforeHeight && styles.fullHeightStyle,
            contentHeightSettings.hasWrapperBeforeHeight && { paddingTop: ctx.data.wrapperBeforeHeight },
            ctx.data.wrapperBeforeColor && { background: ctx.data.wrapperBeforeColor },
            ctx.data.scrollbarOffset && ctx.verticalScrollbarWidth && { marginRight: -ctx.data.scrollbarOffset },
        ],
    ];
}

function isBottomBorderActive(ctx: IContext): boolean {
    if (ctx.data.hasBottomBorderWhenScrollable && ctx.isScrollbarActive) {
        return true;
    }
    return false;
}

export interface IData {
    content: b.IBobrilChildren;
    contentHeight?: number;
    contentMaxHeight?: number;
    contentMinHeight?: number;
    wrapperBeforeHeight?: number;
    wrapperBeforeColor?: string;
    isWithSidePadding?: boolean;
    isWithSidePaddingForAsterisks?: boolean;
    scrollTop?: number;
    /** save value across browsers is at least 20 */
    scrollbarOffset?: number;
    // handles scroll to prevent scrolling on next parent scrollable element
    handleMouseWheelScroll?: boolean;
    hasBottomBorderWhenScrollable?: boolean;
    // default is true
    isShadowFullWidth?: boolean;
    /** typical use is for children renderer */
    scrollContentElementId?: string;
    hasScrollContentRelativePosition?: boolean;
    /** typical use is for moving header content in case of horizontal scrollbar of body */
    hasScrollWrapperOverflowHidden?: boolean;
    /** horizontal scroll info */
    onScrollPositionChanged?: (info: ScrollContent.IScrollInfo) => void;
    /** vertical scroll info */
    onVerticalScrollPositionChanged?: (info: ScrollContent.IVerticalScrollInfo) => void;
    onScrollbarVisibilityChanged?: (isVisible: boolean) => void;
    onVisibleContentWidthChanged?: (width: number) => void;
}

interface IContext extends b.IBobrilCtx {
    data: IData;
    topShadowOpacity: number;
    bottomShadowOpacity: number;
    onScroll: () => void;
    verticalScrollbarWidth?: number;
    isScrollbarActive?: boolean;
}

function updateShadowOpacity(contentElement: HTMLElement, ctx: IContext): void {
    if (contentElement) {
        const size = contentElement.offsetHeight,
            realSize = contentElement.scrollHeight,
            scroll = contentElement.scrollTop,
            topShadowOpacity = scroll / 100,
            bottomShadowOpacity = (realSize - (size + scroll)) / 100;

        if (topShadowOpacity !== ctx.topShadowOpacity || bottomShadowOpacity !== ctx.bottomShadowOpacity) {
            ctx.topShadowOpacity = scroll / 100;
            ctx.bottomShadowOpacity = (realSize - (size + scroll)) / 100;
            b.invalidate(ctx);
        }
    }
}

function getAndEraseScrollTop(data: IData): number | undefined {
    const scrollTop = data.scrollTop;
    data.scrollTop = undefined;
    return scrollTop;
}

export * from "./publicConstants";

// added by script - BEGIN
export const ScrollShadow = create;
// added by script - END
