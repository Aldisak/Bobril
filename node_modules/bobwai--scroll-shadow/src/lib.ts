import * as b from "bobril";
import * as styles from "./styles";
import * as ScrollContent from "./scrollContent";
import * as ScrollSize from "helpers--scrollbar-size";
import { isIE, isEdge } from "helpers--browser-identifier";
export { IScrollInfo, IVerticalScrollInfo } from "./scrollContent";

export const create = b.createComponent<IData>({
    id: "bobwai--scroll-shadow",
    init(ctx: IContext, _me: b.IBobrilNode): void {
        if (ctx.data.scrollbarOffset !== undefined || ctx.data.hasBottomBorderWhenScrollable || ctx.data.isShadowFullWidth === false) {
            ctx.verticalScrollbarWidth = ScrollSize.getScrollbarSize().vertical;
        }
    },
    render(ctx: IContext, me: b.IBobrilNode): void {
        const d = ctx.data;
        const contentHeightSettings: IContentSizeSettings = {
            hasContentHeight: d.contentHeight !== undefined,
            hasContentMaxHeight: d.contentMaxHeight !== undefined,
            hasContentMinHeight: d.contentMinHeight !== undefined,
            hasWrapperBeforeHeight: d.wrapperBeforeHeight !== undefined,
        };

        if (ctx.data.scrollbarOffset) {
            // add extra wrap for offset scrollbar
            me.children = b.styledDiv(
                getScrollShadowChildren(ctx, contentHeightSettings),
                getScrollShadowStyles(ctx, contentHeightSettings)
            );
            b.style(me, [
                getScrollShadowWithOffsetWrapperStyle(ctx),
                isBottomBorderActive(ctx) && styles.scrollShadowWithBottomBorderStyle,
            ]);
        } else {
            me.children = getScrollShadowChildren(ctx, contentHeightSettings);
            b.style(me, [
                getScrollShadowStyles(ctx, contentHeightSettings),
                isBottomBorderActive(ctx) && styles.scrollShadowWithBottomBorderStyle,
            ]);
        }
    },
    postInitDom(ctx: IContext, _: b.IBobrilCacheNode, element: HTMLElement): void {
        const contentElement = <HTMLElement>element.getElementsByClassName(styles.contentStyle)[0];
        updateShadowOpacity(contentElement, ctx);

        ctx.onScroll = () => {
            updateShadowOpacity(contentElement, ctx);
        };
        b.addOnScroll(ctx.onScroll);
    },
    postUpdateDomEverytime(ctx: IContext, _: b.IBobrilCacheNode, element: HTMLElement): void {
        const contentElement: HTMLElement = <HTMLElement>element.getElementsByClassName(styles.contentStyle)[0];

        if ((ctx.data.scrollbarOffset !== undefined && ctx.verticalScrollbarWidth) || ctx.data.scrollShadowType === ScrollShadowType.Both) {
            if (contentElement.scrollHeight - contentElement.offsetHeight + getShadowOffset(ctx, true) > 1) {
                if (!ctx.isScrollbarActive) {
                    element.style.overflow = "visible";
                    ctx.isScrollbarActive = true;
                    ctx.data.onScrollbarVisibilityChanged && ctx.data.onScrollbarVisibilityChanged(!!ctx.isScrollbarActive);
                }
            } else {
                if (ctx.isScrollbarActive || ctx.isScrollbarActive === undefined) {
                    element.style.overflow = "hidden";
                    ctx.isScrollbarActive = false;
                    ctx.data.onScrollbarVisibilityChanged && ctx.data.onScrollbarVisibilityChanged(!!ctx.isScrollbarActive);
                }
            }

            if (contentElement.scrollWidth - contentElement.offsetWidth + getShadowOffset(ctx, false) > 1) {
                if (!ctx.isHorizontalScrollbarActive) {
                    ctx.isHorizontalScrollbarActive = true;
                    ctx.data.onHorizontalScrollbarVisibilityChanged &&
                        ctx.data.onHorizontalScrollbarVisibilityChanged(!!ctx.isHorizontalScrollbarActive);
                }
            } else {
                if (ctx.isHorizontalScrollbarActive || ctx.isHorizontalScrollbarActive === undefined) {
                    ctx.isHorizontalScrollbarActive = false;
                    ctx.data.onHorizontalScrollbarVisibilityChanged &&
                        ctx.data.onHorizontalScrollbarVisibilityChanged(!!ctx.isHorizontalScrollbarActive);
                }
            }

            const actualScrollbarWidth = ScrollSize.getScrollbarSize().vertical;
            if (actualScrollbarWidth !== ctx.verticalScrollbarWidth) {
                ctx.verticalScrollbarWidth = actualScrollbarWidth;
                b.invalidate(ctx);
            }
            const actualScrollbarHeight = ScrollSize.getScrollbarSize().horizontal;
            if (actualScrollbarHeight !== ctx.horizontalScrollbarHeight) {
                ctx.horizontalScrollbarHeight = actualScrollbarHeight;
                b.invalidate(ctx);
            }
        }

        updateShadowOpacity(contentElement, ctx);
    },

    destroy(ctx: IContext): void {
        b.removeOnScroll(ctx.onScroll);
    },
});

interface IContentSizeSettings {
    hasContentHeight: boolean;
    hasContentMaxHeight: boolean;
    hasContentMinHeight: boolean;
    hasWrapperBeforeHeight: boolean;
}

function getScrollShadowWithOffsetWrapperStyle(ctx: IContext): b.IBobrilStyle | undefined {
    if (ctx.data.contentHeight !== undefined || ctx.data.contentMinHeight !== undefined || ctx.data.contentMaxHeight !== undefined) {
        return styles.scrollShadowWithOffsetWrapperStyle;
    }
    return styles.scrollShadowWithOffsetWrapperFullSizeStyle;
}

function getScrollShadowChildren(ctx: IContext, contentHeightSettings: IContentSizeSettings): b.IBobrilChildren[] {
    const d = ctx.data;
    return [
        b.style(
            ScrollContent.create({
                content: d.content,
                scrollTop: getAndEraseScrollTop(d),
                elementId: d.scrollContentElementId,
                handleMouseWheelScroll: d.handleMouseWheelScroll,
                scrollbarOffset: d.scrollbarOffset,
                onScrollPositionChanged: d.onScrollPositionChanged,
                onVerticalScrollPositionChanged: d.onVerticalScrollPositionChanged,
                onVisibleContentWidthChanged: d.onVisibleContentWidthChanged,
            }),
            [
                styles.contentStyle,
                d.hasScrollContentRelativePosition && styles.contentRelativeStyle,
                d.isWithSidePadding && styles.contentSidePaddingStyle,
                d.isWithSidePaddingForAsterisks && styles.contentSidePaddingForAsterisksStyle,
                contentHeightSettings.hasContentHeight && { height: d.contentHeight },
                contentHeightSettings.hasContentMaxHeight && { maxHeight: d.contentMaxHeight },
                contentHeightSettings.hasContentMinHeight && { minHeight: d.contentMinHeight },
                !contentHeightSettings.hasContentHeight && styles.fullHeightStyle,
                d.scrollbarOffset &&
                    ctx.verticalScrollbarWidth && {
                        overflowY: "scroll",
                        paddingRight: d.scrollbarOffset - ctx.verticalScrollbarWidth,
                    },
                d.scrollbarOffset && ctx.verticalScrollbarWidth && (isIE() || isEdge()) && styles.scrollShadowOffsetIECorrection,
            ]
        ),
        isVerticalShadowEnabled(ctx) && [
            b.styledDiv(null, [
                getCommonShadowStyles(ctx),
                styles.topShadowStyle,
                { opacity: ctx.topShadowOpacity },
                contentHeightSettings.hasWrapperBeforeHeight && { top: d.wrapperBeforeHeight },
            ]),
            b.styledDiv(null, [
                getCommonShadowStyles(ctx),
                styles.bottomShadowStyle,
                { opacity: ctx.bottomShadowOpacity, bottom: getShadowOffset(ctx, true) },
            ]),
        ],
        isHorizontalShadowEnabled(ctx) && [
            b.styledDiv(null, [
                getCommonShadowStyles(ctx, true),
                styles.shadowVerticalStyle,
                styles.leftShadowStyle,
                { opacity: ctx.leftShadowOpacity, left: ctx.data.leftShadowOffset },
            ]),
            b.styledDiv(null, [
                getCommonShadowStyles(ctx, true),
                styles.shadowVerticalStyle,
                styles.rightShadowStyle,
                { opacity: ctx.rightShadowOpacity, right: getShadowOffset(ctx) },
            ]),
        ],
        isBottomBorderActive(ctx) && b.styledDiv("", styles.scrollShadowBottomBorderStyle),
    ];
}

function getCommonShadowStyles(ctx: IContext, isHorizontal = false): b.IBobrilStyles {
    const hasShadowSidePadding = ctx.data.isWithSidePadding && !ctx.data.isWithSidePaddingForAsterisks;
    let shadowRightSidePadding = ctx.data.scrollbarOffset && ctx.data.isShadowFullWidth === false ? ctx.data.scrollbarOffset : 0;

    if (hasShadowSidePadding && ctx.data.isShadowFullWidth === false) {
        if (ctx.data.scrollbarOffset) {
            // if offset is active -> right side padding does not make sense
            shadowRightSidePadding += styles.sidePadding;
        } else {
            shadowRightSidePadding += 2 * styles.sidePadding;
        }
    }

    if (ctx.verticalScrollbarWidth && ctx.data.isShadowFullWidth === false && hasShadowSidePadding && !ctx.data.scrollbarOffset) {
        shadowRightSidePadding += ctx.verticalScrollbarWidth;
    }

    return [
        styles.shadowStyle,
        !isHorizontal && hasShadowSidePadding && ctx.data.isShadowFullWidth === false && styles.shadowLeftSidePaddingStyle,
        !isHorizontal && {
            width: `calc(100% - ${2 * styles.shadowBoundary + shadowRightSidePadding + getShadowOffset(ctx, false)}px)`,
        },
        isHorizontal && {
            height: `calc(100% - ${2 * styles.shadowBoundary + shadowRightSidePadding + getShadowOffset(ctx, true)}px)`,
        },
    ];
}

function getShadowOffset(ctx: IContext, isHorizontal = false): number {
    let offset = 0;
    if (!isHorizontal) {
        offset = ctx.isScrollbarActive ? ctx.verticalScrollbarWidth || 0 : 0;
    } else {
        offset = ctx.isHorizontalScrollbarActive ? ctx.horizontalScrollbarHeight || 0 : 0;
    }
    return offset;
}

function getScrollShadowStyles(ctx: IContext, contentHeightSettings: IContentSizeSettings): b.IBobrilStyles {
    return [
        [
            styles.wrapperStyle,
            ctx.data.shouldResetZIndex && styles.wrapperZIndexResetStyle,
            ctx.data.hasScrollWrapperOverflowHidden && styles.overflowHiddenStyle,
            !contentHeightSettings.hasContentHeight &&
                contentHeightSettings.hasWrapperBeforeHeight && { height: `calc(100% - ${ctx.data.wrapperBeforeHeight}px)` },
            !contentHeightSettings.hasContentHeight && !contentHeightSettings.hasWrapperBeforeHeight && styles.fullHeightStyle,
            contentHeightSettings.hasWrapperBeforeHeight && { paddingTop: ctx.data.wrapperBeforeHeight },
            ctx.data.wrapperBeforeColor && { background: ctx.data.wrapperBeforeColor },
            ctx.data.scrollbarOffset && ctx.verticalScrollbarWidth && { marginRight: -ctx.data.scrollbarOffset },
        ],
    ];
}

function isBottomBorderActive(ctx: IContext): boolean {
    if (ctx.data.hasBottomBorderWhenScrollable && ctx.isScrollbarActive) {
        return true;
    }
    return false;
}

export interface IData {
    content: b.IBobrilChildren;
    contentHeight?: number;
    contentMaxHeight?: number;
    contentMinHeight?: number;
    wrapperBeforeHeight?: number;
    wrapperBeforeColor?: string;
    isWithSidePadding?: boolean;
    isWithSidePaddingForAsterisks?: boolean;
    scrollTop?: number;
    /** save value across browsers is at least 20 */
    scrollbarOffset?: number;
    // handles scroll to prevent scrolling on next parent scrollable element
    handleMouseWheelScroll?: boolean;
    hasBottomBorderWhenScrollable?: boolean;
    // default is true
    isShadowFullWidth?: boolean;
    /** typical use is for children renderer */
    scrollContentElementId?: string;
    hasScrollContentRelativePosition?: boolean;
    /** typical use is for moving header content in case of horizontal scrollbar of body */
    hasScrollWrapperOverflowHidden?: boolean;
    /** defines type of scrollbar shadow (default = vertical only) */
    scrollShadowType?: ScrollShadowType;
    /** in some rare cases (like in table with fixed columns) you need to reset z-index to 0 */
    shouldResetZIndex?: boolean;
    leftShadowOffset?: number;
    /** horizontal scroll info */
    onScrollPositionChanged?: (info: ScrollContent.IScrollInfo) => void;
    /** vertical scroll info */
    onVerticalScrollPositionChanged?: (info: ScrollContent.IVerticalScrollInfo) => void;
    onScrollbarVisibilityChanged?: (isVisible: boolean) => void;
    onHorizontalScrollbarVisibilityChanged?: (isVisible: boolean) => void;
    onVisibleContentWidthChanged?: (width: number) => void;
}

export enum ScrollShadowType {
    /** Shadow for vertical scroll only. Default. */
    Vertical,
    /** Shadow for horizontal scroll only. */
    Horizontal,
    /** Shadow for both scrollbars. */
    Both,
}
interface IContext extends b.IBobrilCtx {
    data: IData;
    topShadowOpacity: number;
    bottomShadowOpacity: number;
    leftShadowOpacity: number;
    rightShadowOpacity: number;
    onScroll: () => void;
    verticalScrollbarWidth?: number;
    horizontalScrollbarHeight?: number;
    isScrollbarActive?: boolean;
    isHorizontalScrollbarActive?: boolean;
}

export function isHorizontalShadowEnabled(ctx: IContext): boolean {
    return ctx.data.scrollShadowType === ScrollShadowType.Horizontal || ctx.data.scrollShadowType === ScrollShadowType.Both;
}

export function isVerticalShadowEnabled(ctx: IContext): boolean {
    return ctx.data.scrollShadowType !== ScrollShadowType.Horizontal;
}

function updateShadowOpacity(contentElement: HTMLElement, ctx: IContext): void {
    if (contentElement) {
        if (isVerticalShadowEnabled(ctx)) {
            const height = contentElement.offsetHeight,
                realHeight = contentElement.scrollHeight,
                scrollTop = contentElement.scrollTop,
                topShadowOpacity = scrollTop / 100,
                bottomShadowOpacity = (realHeight - (height + scrollTop)) / 100;

            if (topShadowOpacity !== ctx.topShadowOpacity || bottomShadowOpacity !== ctx.bottomShadowOpacity) {
                ctx.topShadowOpacity = scrollTop / 100;
                ctx.bottomShadowOpacity = (realHeight - (height + scrollTop)) / 100;
                b.invalidate(ctx);
            }
        }
        if (isHorizontalShadowEnabled(ctx)) {
            const width = contentElement.offsetWidth,
                realWidth = contentElement.scrollWidth,
                scrollLeft = contentElement.scrollLeft,
                leftShadowOpacity = scrollLeft / 100,
                rightShadowOpacity = (realWidth - (width + scrollLeft)) / 100;

            if (leftShadowOpacity !== ctx.leftShadowOpacity || rightShadowOpacity !== ctx.rightShadowOpacity) {
                ctx.leftShadowOpacity = scrollLeft / 100;
                ctx.rightShadowOpacity = (realWidth - (width + scrollLeft)) / 100;
                b.invalidate(ctx);
            }
        }
    }
}

function getAndEraseScrollTop(data: IData): number | undefined {
    const scrollTop = data.scrollTop;
    data.scrollTop = undefined;
    return scrollTop;
}

export * from "./publicConstants";

// added by script - BEGIN
export const ScrollShadow = create;
// added by script - END
