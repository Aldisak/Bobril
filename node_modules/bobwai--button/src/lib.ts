import * as b from "bobril";
import * as Color from "bobwai--color";
import * as ColorOperations from "bobwai--color-operations";
import * as styles from "./styles";
import * as Focus from "bobwai--focus";
import * as FormElements from "bobwai--form-elements";
import * as TooltipEllipsis from "bobwai--tooltip-ellipsis";
import * as StyleMixins from "bobwai--style-mixins";
import { KeyCode } from "helpers--key-codes";

export * from "./publicConstants";

export const create = b.createVirtualComponent<IData>({
    id: "bobwai--button",
    onClick(ctx: IContext, event: b.IBobrilMouseEvent): boolean {
        if (!ctx.data.isDisabled && event.button === 1) {
            ctx.data.onClick();
            return ctx.data.propagateClick ? false : true;
        }
        return false;
    },
    onMouseLeave(ctx: IContext): boolean {
        ctx.isHover = false;
        b.invalidate(ctx);
        return true;
    },
    onMouseEnter(ctx: IContext): boolean {
        if (!ctx.data.isDisabled) {
            ctx.isHover = true;
            b.invalidate(ctx);
        }
        return true;
    },
    render(ctx: IContext, me: b.IBobrilNode): void {
        me.children = Focus.create({
            webContentAccessibility: b.assign(
                {
                    role: Focus.ContentAccessibilityRole.Button,
                    isDisabled: ctx.data.isDisabled,
                },
                ctx.data.webContentAccessibility
            ),
            content: getButton(ctx),
            //  isDisabled: ctx.data.isDisabled,
            isTabIndexDisabled: ctx.data.isTabIndexDisabled,
            displayAs: ctx.data.displayAs === DisplayAs.Block ? Focus.DisplayAs.Block : Focus.DisplayAs.Default,
            onFocusCommand: () => {
                if (!ctx.data.isDisabled) {
                    ctx.data.onClick();
                }
            },
            offsetTop: getFocusOffsetTopBottom(ctx.data),
            offsetLeft: getFocusOffsetLeft(ctx.data),
            offsetRight: getFocusOffsetRight(ctx.data),
            offsetBottom: getFocusOffsetTopBottom(ctx.data),
            color: getFocusColor(ctx.data),
            focusCommandKeys: [KeyCode.Enter, KeyCode.Space], // Enter or Space
            isFontSizeInheritedFromParent: ctx.data.isFontSizeInheritedFromParent,
        });
    },
});

const disabledOpacity = 0.3;
const focusOffset = 6;
const focusOffsetExtraSmall = 4;
const focusOffsetExtraSmallForThemeNone = 1;
const focusOffsetThemeNone = 0;
// const focusOffsetThemeNoneWithIcon = -1;

function getButton(ctx: IContext): b.IBobrilNode {
    const theme = getTheme(ctx);
    return b.styledDiv(
        createButtonContent(ctx.data, ctx.isHover),
        getStyle(ctx, theme),
        getInlineStyle(ctx, theme),
        ctx.data.displayAs === DisplayAs.Block && styles.buttonWithBlockStyle
    );
}

function getFocusOffsetLeft(data: IData): number {
    if (data.color === Theme.None) {
        return focusOffsetThemeNone;
    }
    if (data.size === Size.ExtraSmall) {
        return focusOffsetExtraSmall;
    }
    return focusOffset;
}

function getFocusOffsetRight(data: IData): number {
    if (data.color === Theme.None) {
        return focusOffsetThemeNone;
    }
    if (data.size === Size.ExtraSmall) {
        return focusOffsetExtraSmall;
    }
    return focusOffset;
}

function getFocusOffsetTopBottom(data: IData): number {
    if (data.size === Size.ExtraSmall) {
        return data.color === Theme.None ? focusOffsetExtraSmallForThemeNone : focusOffsetExtraSmall;
    }
    return focusOffset;
}

function getFocusColor(data: IData): Color.IColor {
    if (data.customTheme && data.customTheme.color) {
        return data.customTheme.color;
    }
    if (data.color === Theme.None) {
        return Color.Application;
    }
    return Color.White;
}

function getStyle(ctx: IContext, theme: styles.IColorTheme): b.IBobrilStyles {
    return [
        styles.baseStyle,
        ctx.data.color === Theme.None && !ctx.data.leftIcon && styles.baseThemeNoneWithoutLeftIconStyle,
        ctx.data.color === Theme.None && !ctx.data.rightIcon && styles.baseThemeNoneWithoutRightIconStyle,
        ctx.data.displayAs === DisplayAs.Block &&
            ctx.data.blockTitleTextAlign === FormElements.TextAlign.Left &&
            styles.leftAlignButtonStyle,
        ctx.data.displayAs === DisplayAs.Block &&
            ctx.data.blockTitleTextAlign !== undefined &&
            ctx.data.color !== Theme.None &&
            getLeftRightPadding(ctx.data),
        ctx.data.leftIcon && ctx.data.color !== Theme.None && !ctx.data.displayAs && getLeftRightPadding(ctx.data),
        theme.baseStyle,
        ctx.data.color !== Theme.None && ctx.data.size === Size.ExtraSmall && styles.extraSmallButtonStyle,
        getSizeStyle(ctx.data),
        (ctx.data.leftIcon || ctx.data.rightIcon) && styles.buttonWithIconStyle,
        ctx.data.isDisabled && styles.disabledStyle,
    ];
}

function getInlineStyle(ctx: IContext, theme: styles.IColorTheme): b.IBobrilStyle {
    const customBackgroundColor = ctx.data.customTheme && ctx.data.customTheme.backgroundColor;
    const customForegroundColor = ctx.data.customTheme && ctx.data.customTheme.color;

    if (ctx.data.isDisabled) {
        const customBackgroundColorDisabled = customBackgroundColor && ColorOperations.hexToRgba(customBackgroundColor, disabledOpacity);
        const customForegroundColorDisabled = customForegroundColor && ColorOperations.hexToRgba(customForegroundColor, disabledOpacity);

        return {
            color: customForegroundColorDisabled || theme.foregroundColorDisabled,
            backgroundColor: customBackgroundColorDisabled || theme.backgroundColorDisabled,
        };
    } else {
        if (ctx.isHover) {
            const customBackgroundColorHover = customBackgroundColor && ColorOperations.changeShade(customBackgroundColor, -0.08);
            const customForegroundColorHover = customForegroundColor && ColorOperations.changeShade(customForegroundColor, -0.08);

            return {
                color: customForegroundColorHover, // || theme.foregroundColor, //NOTE: hover color is set by pseudo selectors
                backgroundColor: customBackgroundColorHover, // || theme.backgroundColor
            };

            // buttonCustomTheme.color = ctx.data.color === Theme.None && ctx.data.customTheme.color && !buttonCustomTheme.backgroundColor
            //     && ColorOperations.changeShade(ctx.data.customTheme.color, -0.08);
        } else {
            return {
                color: customForegroundColor || theme.foregroundColor,
                backgroundColor: customBackgroundColor || theme.backgroundColor,
            };
        }
    }
}

export interface IData {
    rightIcon?: b.IBobrilNode;
    rightIconWithoutIndent?: boolean;
    rightIconHover?: b.IBobrilNode;
    leftIcon?: b.IBobrilNode;
    leftIconHover?: b.IBobrilNode;
    isDisabled?: boolean;
    isTabIndexDisabled?: boolean;
    propagateClick?: boolean;
    size?: Size;
    color?: Theme;
    customTheme?: IButtonTheme;
    label: string;
    displayAs?: DisplayAs;
    isFontSizeInheritedFromParent?: boolean;
    blockTitleTextAlign?: FormElements.TextAlign;
    webContentAccessibility?: WebContentAccessibility;
    onClick(): void;
}

/**
 * isExpanded: should be used only if button is used as collapsible button for some section - e.g. in bobwai--chat component
 * descriptionNodeId: is automatically used via form-item component to add corresponding label id
 **/
export type WebContentAccessibility = Pick<Focus.IWebContentAccessibility, "isExpanded" | "descriptionNodeId">;

export enum DisplayAs {
    Default,
    Block,
}

export enum Size {
    ExtraSmall,
    Small,
    Medium,
    Large,
}

export enum Theme {
    None,
    Light,
    Info,
    Warning,
    Error,
    Success,
    App,
}

export interface IButtonTheme {
    backgroundColor?: Color.IColor;
    color?: Color.IColor;
    fontSize?: string;
    fontWeight?: number;
}

interface IIconContent {
    icon: b.IBobrilNode;
    iconHover: b.IBobrilNode;
}

interface IContext extends b.IBobrilCtx {
    data: IData;
    isHover: boolean;
    customTheme?: styles.IColorTheme;
    leftIcon: IIconContent;
    rightIcon: IIconContent;
}

function getTheme(ctx: IContext): styles.IColorTheme {
    switch (ctx.data.color) {
        case Theme.None:
            return styles.textTheme;
        case Theme.Info:
            return styles.infoTheme;
        case Theme.Warning:
            return styles.warningTheme;
        case Theme.Success:
            return styles.successTheme;
        case Theme.Error:
            return styles.errorTheme;
        case Theme.Light:
            return styles.lightTheme;
        case Theme.App:
            return styles.appTheme;
        default:
            return styles.basicTheme;
    }
}

function getSizeStyle(data: IData): b.IBobrilStyle {
    switch (data.size) {
        case Size.ExtraSmall:
            return data.color === Theme.None ? styles.sizeExtraSmallThemeNoneStyle : styles.sizeExtraSmallStyle;
        case Size.Small:
            return styles.sizeSmallStyle;
        case Size.Medium:
            return styles.sizeMediumStyle;
        case Size.Large:
            return styles.sizeLargeStyle;
        default:
            return null;
    }
}

function createButtonContent(data: IData, isHover: boolean): b.IBobrilChildren {
    const leftIcon = data.leftIcon;
    const leftIconHover = data.leftIconHover;
    const rightIcon = data.rightIcon;
    const rightIconHover = data.rightIconHover;

    if (leftIcon || rightIcon) {
        return [
            leftIcon &&
                b.style(!isHover ? b.cloneNode(leftIcon) : b.cloneNode(leftIconHover || leftIcon), [
                    data.isDisabled && { opacity: disabledOpacity },
                    { verticalAlign: "middle" },
                    data.displayAs === DisplayAs.Block &&
                        data.blockTitleTextAlign !== undefined &&
                        data.color !== Theme.None &&
                        getBlockButtonIconStyle(data),
                    data.leftIcon && data.color !== Theme.None && !data.displayAs && getBlockButtonIconStyle(data),
                ]),
            getLabel(data),
            rightIcon &&
                b.style(
                    !isHover ? b.cloneNode(rightIcon) : b.cloneNode(rightIconHover || rightIcon),
                    data.isDisabled && { opacity: disabledOpacity }
                ),
        ];
    } else {
        return data.displayAs === DisplayAs.Block
            ? TooltipEllipsis.create({
                  content: b.styledDiv(data.label, StyleMixins.lineEllipsis()),
                  tooltipMessage: data.label,
              })
            : data.label;
    }
}

function getLabel(data: IData) {
    if (!data.label) {
        return undefined;
    } else {
        if (data.displayAs === DisplayAs.Block) {
            return TooltipEllipsis.create({
                content: getLabelContent(data),
                tooltipMessage: data.label,
            });
        } else {
            return getLabelContent(data);
        }
    }
}

function getLabelContent(data: IData) {
    return b.styledDiv(
        data.label,
        getLabelWithIconStyle(data),
        data.leftIcon && isIconPositionedLeft(data) && styles.labelWithLeftIconStyle,
        data.rightIcon && [styles.labelWithRightIconStyle, data.rightIconWithoutIndent && styles.labelWithRightIconWithoutIndentStyle],
        data.customTheme && data.customTheme.fontSize && { fontSize: data.customTheme.fontSize },
        data.customTheme && data.customTheme.fontWeight && { fontWeight: data.customTheme.fontWeight },
        data.displayAs === DisplayAs.Block && StyleMixins.lineEllipsis(),
        data.displayAs === DisplayAs.Block && styles.maxWidthStyle,
        isBlockTextButtonWithIcon(data) && data.color === Theme.None && styles.maxWidthLabelWithIconStyle,
        isBlockTextButtonWithIcon(data) && data.blockTitleTextAlign === undefined && styles.maxWidthLabelWithIconStyle
    );
}

function isBlockTextButtonWithIcon(data: IData): boolean {
    return !!(data.displayAs === DisplayAs.Block && data.leftIcon);
}

function getLabelWithIconStyle(data: IData): b.IBobrilStyles {
    return [
        styles.labelWithIconStyle,
        (data.size === Size.Small || data.size === undefined) && styles.labelWithIconSmallStyle,
        data.size === Size.ExtraSmall &&
            (data.color === Theme.None ? styles.labelWithIconExtraSmallThemeNoneStyle : styles.labelWithIconExtraSmallStyle),
        data.size === Size.Medium && styles.labelWithIconMediumStyle,
        data.size === Size.Large && styles.labelWithIconLargeStyle,
    ];
}

function getBlockButtonIconStyle(data: IData): b.IBobrilStyles {
    return [styles.absoluteIconStyle, getIconPositionStyle(data)];
}

function getIconPositionStyle(data: IData): b.IBobrilStyle {
    switch (data.size) {
        case Size.ExtraSmall:
            return styles.blockButtonIconStyleExtraSmall;
        case Size.Medium:
            return styles.blockButtonIconStyleMedium;
        case Size.Large:
            return styles.blockButtonIconStyleLarge;
        default:
            return styles.blockButtonIconStyleSmall;
    }
}

function getLeftRightPadding(data: IData): b.IBobrilStyle {
    switch (data.size) {
        case Size.ExtraSmall:
            return { paddingLeft: 31, paddingRight: 10 }; // 8px (icon indentation) + 20px (icon width) + 3px (space between icon and text)
        case Size.Medium:
            return { paddingLeft: 39, paddingRight: 15 };
        case Size.Large:
            return { paddingLeft: 46, paddingRight: 20 };
        default:
            return { paddingLeft: 36, paddingRight: 13 };
    }
}

function isIconPositionedLeft(data: IData): boolean {
    return (data.displayAs === DisplayAs.Block && data.blockTitleTextAlign === undefined) || data.color === Theme.None ? true : false;
}

// added by script - BEGIN
export const Button = create;
// added by script - END
