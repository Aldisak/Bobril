import * as b from "bobril";
import * as constants from "./publicConstants";
import * as Color from "bobwai--color";
import * as FormElements from "bobwai--form-elements";
import * as rtlTextHelper from "helpers--rtl-text";
import * as s from "./styles";
import * as d from "./data";

export * from "./data";

export let create = b.createComponent<d.IData>({
    id: "bobwai--tooltip-message",
    render(ctx: IContext, me: b.IBobrilNode): void {
        ctx.variantStyle = s.getStyleForVariant(ctx.data.variant);

        me.children = [getHeader(ctx.data), getMessage(ctx.data), ctx.data.hasBorder && getArrow(ctx, true), getArrow(ctx, false)];
        b.style(me, [
            s.baseStyle,
            ctx.variantStyle.style,
            getSummaryLengthOfHeaderAndMessage(ctx.data) > constants.DoubleWidthMinMessageLength && s.extendedWidthStyle,
            hasValidationError(ctx.data) && s.errorStyle,
            hasValidationWarning(ctx.data) && s.warningStyle,
            hasCustomBackground(ctx.data) && { background: ctx.data.customTheme && ctx.data.customTheme.background },
            ctx.data.hasBorder && s.borderStyle,
            getZoomStyle(
                ctx.data.zoomRatio,
                ctx.data.placement,
                ctx.data.variant === d.Variant.Satellite ? s.localVariables.satelliteVariables : s.localVariables.defaultVariables
            ),
            getEllipsisWidthStyle(ctx.data.ellipsisWidth)
        ]);
    }
});

export * from "./publicConstants";

interface IContext extends b.IBobrilCtx {
    data: d.IData;
    variantStyle: s.IVariantStyle;
}

function getPlacement(data: d.IData) {
    return data.placement === undefined ? d.Placement.topCenter : data.placement;
}

function getHeader(data: d.IData): b.IBobrilChildren {
    if (Array.isArray(data.header)) {
        let rows = (<string[]>data.header).map(item => createContent(item, true, data.ellipsisWidth));
        return hasEllipsis(data.ellipsisWidth) ? rows[0] : rows;
    }
    return hasHeader(data) && createContent(data.header, true, data.ellipsisWidth);
}

function hasHeader(data: d.IData): boolean {
    if (Array.isArray(data.header)) {
        return data.header.length > 0;
    }
    return data.header !== undefined && data.header !== null && (<string>data.header).length > 0;
}

function getMessage(data: d.IData): b.IBobrilChildren {
    if (hasHeader(data) && hasEllipsis(data.ellipsisWidth)) {
        return undefined;
    }

    let isHeaderDefined = hasHeader(data);

    if (Array.isArray(data.message)) {
        let rows = (<string[]>data.message).map(item => createContent(item, !isHeaderDefined, data.ellipsisWidth));
        return hasEllipsis(data.ellipsisWidth) ? rows[0] : rows;
    }
    return createContent(data.message, !isHeaderDefined, data.ellipsisWidth);
}

function createContent(text?: string, useHeaderStyle?: boolean, ellipsisMode?: d.EllipsisWidth) {
    if (!text) return undefined;

    return b.styledDiv(
        text,
        useHeaderStyle && s.headerStyle,
        rtlTextHelper.getRtlTextStyles({
            enableRTL: constants.EnableRTL,
            text: text
        }),
        getEllipsisStyle(ellipsisMode)
    );
}

function getArrow(ctx: IContext, isForBorder: boolean): b.IBobrilNode {
    let arrowColor = getArrowColor(ctx.data, isForBorder);
    let placement = getPlacement(ctx.data);
    return b.styledDiv("", [
        s.arrowBaseStyle,
        placement === d.Placement.bottomCenter && [
            isForBorder ? ctx.variantStyle.arrowUpBorderStyle : ctx.variantStyle.arrowUpStyle,
            arrowColor && { borderBottomColor: arrowColor }
        ],
        placement === d.Placement.bottomLeft && [
            isForBorder ? ctx.variantStyle.arrowUpBorderStyle : ctx.variantStyle.arrowUpStyle,
            isForBorder ? ctx.variantStyle.arrowHorizontalRightBorderStyle : ctx.variantStyle.arrowHorizontalRightStyle,
            arrowColor && { borderBottomColor: arrowColor }
        ],
        placement === d.Placement.bottomRight && [
            isForBorder ? ctx.variantStyle.arrowUpBorderStyle : ctx.variantStyle.arrowUpStyle,
            isForBorder ? ctx.variantStyle.arrowHorizontalLeftBorderStyle : ctx.variantStyle.arrowHorizontalLeftStyle,
            arrowColor && { borderBottomColor: arrowColor }
        ],
        placement === d.Placement.topCenter && [
            isForBorder ? ctx.variantStyle.arrowDownBorderStyle : ctx.variantStyle.arrowDownStyle,
            arrowColor && { borderTopColor: arrowColor }
        ],
        placement === d.Placement.topLeft && [
            isForBorder ? ctx.variantStyle.arrowDownBorderStyle : ctx.variantStyle.arrowDownStyle,
            isForBorder ? ctx.variantStyle.arrowHorizontalRightBorderStyle : ctx.variantStyle.arrowHorizontalRightStyle,
            arrowColor && { borderTopColor: arrowColor }
        ],
        placement === d.Placement.topRight && [
            isForBorder ? ctx.variantStyle.arrowDownBorderStyle : ctx.variantStyle.arrowDownStyle,
            isForBorder ? ctx.variantStyle.arrowHorizontalLeftBorderStyle : ctx.variantStyle.arrowHorizontalLeftStyle,
            arrowColor && { borderTopColor: arrowColor }
        ],
        placement === d.Placement.right && [
            isForBorder ? ctx.variantStyle.arrowLeftBorderStyle : ctx.variantStyle.arrowLeftStyle,
            arrowColor && { borderRightColor: arrowColor }
        ],
        placement === d.Placement.left && [
            isForBorder ? ctx.variantStyle.arrowRightBorderStyle : ctx.variantStyle.arrowRightStyle,
            arrowColor && { borderLeftColor: arrowColor }
        ]
    ]);
}

function getArrowColor(data: d.IData, isForBorder: boolean) {
    if (isForBorder) return s.localVariables.borderColor;
    if (hasValidationError(data)) return Color.Error;
    if (hasValidationWarning(data)) return Color.Warning;
    if (hasCustomBackground(data)) return data.customTheme && data.customTheme.background;
    return undefined;
}

function getSummaryLengthOfHeaderAndMessage(data: d.IData): number {
    return getSummaryLength(data.header) + getSummaryLength(data.message);
}

function getSummaryLength(text: undefined | string | string[]): number {
    if (text === undefined) {
        return 0;
    } else if (b.isArray(text)) {
        return text.reduce((sum, currentValue) => sum + currentValue.length, 0);
    } else {
        return text.length;
    }
}

function getZoomStyle(
    zoomRatio: number | undefined,
    placement: d.Placement | undefined,
    variantVariables: s.IVariantVariables
): b.IBobrilStyle {
    if (zoomRatio === undefined || zoomRatio === 1) {
        return undefined;
    }
    let xOrigin: string;
    let yOrigin: string;
    let preShift = "";

    switch (placement) {
        case d.Placement.left:
        case d.Placement.right:
            yOrigin = "50%";
            break;
        case d.Placement.bottomLeft:
        case d.Placement.bottomCenter:
        case d.Placement.bottomRight:
            // IE11 doesn't support calc in transform-origin so we will help ourselves with preshift
            //yOrigin = `calc(0% - ${localVariables.transformationOriginArrowSize}px)`;
            yOrigin = `0`;
            preShift += `translateY(${variantVariables.transformationOriginArrowSize * (zoomRatio - 1)}px) `;
            break;
        default:
            // IE11 doesn't support calc in transform-origin so we will help ourselves with preshift
            //yOrigin = `calc(100% + ${localVariables.transformationOriginArrowSize}px)`;
            yOrigin = `100%`;
            preShift += `translateY(${-variantVariables.transformationOriginArrowSize * (zoomRatio - 1)}px) `;
            break;
    }

    switch (placement) {
        case d.Placement.bottomLeft:
        case d.Placement.topLeft:
            // IE11 doesn't support calc in transform-origin so we will help ourselves with preshift
            //xOrigin = `calc(100% - ${localVariables.transformationOriginArrowOffset}px)`;
            xOrigin = `100%`;
            preShift += `translateX(${variantVariables.transformationOriginArrowOffset * (zoomRatio - 1)}px) `;
            break;
        case d.Placement.bottomRight:
        case d.Placement.topRight:
            xOrigin = `${variantVariables.transformationOriginArrowOffset}px`;
            break;
        case d.Placement.left:
            // IE11 doesn't support calc in transform-origin so we will help ourselves with preshift
            //xOrigin = `calc(100% + ${localVariables.transformationOriginArrowSize}px)`;
            xOrigin = `100%`;
            preShift += `translateX(${-variantVariables.transformationOriginArrowSize * (zoomRatio - 1)}px) `;
            break;
        case d.Placement.right:
            xOrigin = `-${variantVariables.transformationOriginArrowSize}px`;
            break;
        default:
            xOrigin = "50%";
    }

    return {
        transform: `${preShift} scale(${zoomRatio})`,
        transformOrigin: `${xOrigin} ${yOrigin}`
    };
}

let hasValidationError = (data: d.IData): boolean => {
    return !!data.validationState && data.validationState === FormElements.ValidationState.Error;
};

let hasValidationWarning = (data: d.IData): boolean => {
    return !!data.validationState && data.validationState === FormElements.ValidationState.Warning;
};

let hasCustomBackground = (data: d.IData): boolean => {
    return !!data.customTheme && !!data.customTheme.background && data.validationState !== FormElements.ValidationState.Error;
};

function hasEllipsis(ellipsisMode?: d.EllipsisWidth): boolean {
    return ellipsisMode !== undefined && ellipsisMode !== d.EllipsisWidth.None;
}

function getEllipsisWidthStyle(ellipsisMode?: d.EllipsisWidth): b.IBobrilStyle {
    switch (ellipsisMode) {
        case d.EllipsisWidth.Normal:
            return s.ellipsisWidthNormalStyle;
        default:
            return undefined;
    }
}

function getEllipsisStyle(ellipsisMode?: d.EllipsisWidth): b.IBobrilStyle {
    return hasEllipsis(ellipsisMode) && s.ellipsisStyle;
}

// added by script - BEGIN
export const TooltipMessage = create;
// added by script - END