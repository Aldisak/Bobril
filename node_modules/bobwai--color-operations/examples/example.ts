import * as b from "bobril";
import * as Example from "bobwai--example";
import * as ViewerContainer from "bobwai--viewer-container";
import * as ColorPreview from "bobwai--color-preview";
import * as ColorPickerAdvanced from "bobwai--color-picker-advanced";
import * as Container from "bobwai--viewer-container";
import * as LGridLine from "bobwai--l-grid-line";
import * as Panel from "bobwai--panel";
import * as Counter from "bobwai--counter";
import * as Color from "bobwai--color";
import * as colorOperations from "../src/lib";
import * as bobwai__color_operations from "../src/assets";

let renderCounter = 0;
let colorInput1 = <ColorPickerAdvanced.IColorInModels>{
    rgb: { r: 0, g: 0, b: 0 },
    mainColorModel: ColorPickerAdvanced.ColorModel.RGB
};
let colorInput2 = <ColorPickerAdvanced.IColorInModels>{
    rgb: { r: 255, g: 255, b: 255 },
    mainColorModel: ColorPickerAdvanced.ColorModel.RGB
};
let ratioColor = Color.Error;
let contrastRatio = 0;

Example.init({}, () => {
    if (colorInput1.rgb && colorInput2.rgb) {
        contrastRatio = colorOperations.getContrastRatio(colorInput1.rgb, colorInput2.rgb);
    }

    switch (true) {
        // WCAG 2.1 for AAA level of any text size
        case contrastRatio >= 7:
            ratioColor = Color.Success;
            break;
        // WCAG 2.1 for AA level of any text size or AAA level of large text size
        case colorOperations.isContrastRatioSafe(contrastRatio):
            ratioColor = Color.Info;
            break;
        // WCAG 2.1 for AA level of large text size
        case contrastRatio >= 3:
            ratioColor = Color.Warning;
            break;
        default:
            ratioColor = Color.Error;
    }

    return [
        // note: container component not used intentionally, because it makes dependency cycle
        "Available functions",
        info("Computes HEX color model from HSV", "hsvToHex(h: number, s: number, v: number): string"),
        info("Computes HSV color model from HEX", "hexToHsv(hex: string): any"),
        info("Computes darker/lighter color shade", "changeShade(hex: IColor, lum: number): IColor"),
        info('Computes color with opacity in "rgba(r,g,b,a)" format', "hexToRgba(hex: IColor, alpha: number): IColor"),
        info("Computes combination of two colors", "mixColors(hex1: IColor, hex2: IColor, ratio: number): IColor"),
        info(
            "Computes contrast ratio (according to WCAG 2.1) of two RGB colors",
            "getContrastRatio(color1: IRGBColor, color2: IRGBColor): number"
        ),
        info(
            "Is contrast ratio large enough (default >4.5) for text to be well readable (according to WCAG 2.1) - threshold can be changed with enum set",
            "isContrastRatioSafe(ratio: number, safetyThreshold?: ContrastRatioSafetyThreshold): boolean"
        ),
        info(
            "Is color combination safe (combines getContrastRatio and isContrastRatioSafe)",
            "isColorCombinationSafe(color1: IRGBColor, color2: IRGBColor, safetyThreshold?: ContrastRatioSafetyThreshold): boolean"
        ),
        info("Converts RGB to Hex", "rgbToHex(red: number, green: number, blue: number): string"),
        info("Converts HEX to RGB", "hexToRgb(hex: string): number[]"),
        info("Converts HEX to CMYK", "hexToCmyk(hex: string, outputInPercent?: boolean): number[]"),
        info("Converts CMYK to RGB", "cmykToRgb(c: number, m: number, y: number, k: number, inputInPercent?: boolean): number[]"),
        ViewerContainer.create({
            isTest: true,
            header: "Dynamic sprites",
            description: "render counter (should not be changing by itself): " + renderCounter++,
            content: [
                dynamicSpriteTest("#1", dynamicColor1),
                dynamicSpriteTest("#2", dynamicColor2),
                dynamicSpriteTest("#1 - secondary", dynamicColor1),
                b.styledDiv("", { clear: "both" })
            ]
        }),
        ViewerContainer.create({
            isTest: true,
            header: "changeShade",
            content: [
                getChangeShadePreview("#ff0000"),
                getChangeShadePreview("#aaff00"),
                getChangeShadePreview("#00ffff"),
                getChangeShadePreview("#552299"),
                getChangeShadePreview("#226611"),
                getChangeShadePreview(() => "#226611")
            ]
        }),
        ViewerContainer.create({
            isTest: true,
            header: "mixColors",
            content: [
                getMixColorPreview("#ff0000", "#0000ff"),
                getMixColorPreview("#ffff00", "#00ffff"),
                getMixColorPreview("#ff00ff", "#ffffff"),
                getMixColorPreview("#aaff00", "#552299"),
                getMixColorPreview("#00ffff", "#000000"),
                getMixColorPreview(() => "#00ffff", () => "#000000")
            ]
        }),
        Container.create({
            header: "Contrast ratio according to WCAG 2.1",
            content: b.styledDiv(
                [
                    b.styledDiv(
                        ColorPickerAdvanced.create({
                            value: colorInput1,
                            onChange: (value: ColorPickerAdvanced.IColorInModels | undefined) => {
                                if (value) {
                                    colorInput1 = value;
                                    b.invalidate();
                                }
                            }
                        }),
                        { border: "1px solid #cccccc" }
                    ),
                    b.styledDiv(
                        Panel.create({
                            headerTitle: "Contrast ratio",
                            contentTheme: Panel.ContentTheme.White,
                            content: colorInput1.rgb &&
                                colorInput2.rgb && [
                                    b.styledDiv(
                                        [
                                            b.styledDiv(
                                                "RGB: R:" + colorInput1.rgb.r + " G:" + colorInput1.rgb.g + " B:" + colorInput1.rgb.b
                                            ),
                                            b.styledDiv(
                                                "RGB: R:" + colorInput2.rgb.r + " G:" + colorInput2.rgb.g + " B:" + colorInput2.rgb.b
                                            ),
                                            b.styledDiv("isContrastRatioSafe: " + colorOperations.isContrastRatioSafe(contrastRatio))
                                        ],
                                        colorInput1.rgb &&
                                            colorInput2.rgb && {
                                                textAlign: "center",
                                                paddingTop: 20,
                                                paddingBottom: 25,
                                                paddingLeft: 12,
                                                paddingRight: 12,
                                                color: colorOperations.rgbToHex(colorInput1.rgb.r, colorInput1.rgb.g, colorInput1.rgb.b),
                                                background: colorOperations.rgbToHex(
                                                    colorInput2.rgb.r,
                                                    colorInput2.rgb.g,
                                                    colorInput2.rgb.b
                                                )
                                            }
                                    ),
                                    LGridLine.create({
                                        height: 60,
                                        showBorder: LGridLine.Border.Top,
                                        children: [
                                            Counter.create({
                                                value: contrastRatio.toString(),
                                                label: "ratio",
                                                customHeight: "100%",
                                                isHoverEnabled: true,
                                                customTheme: { color: ratioColor }
                                            })
                                        ]
                                    })
                                ]
                        })
                    ),
                    b.styledDiv(
                        ColorPickerAdvanced.create({
                            value: colorInput2,
                            onChange: (value: ColorPickerAdvanced.IColorInModels | undefined) => {
                                if (value) {
                                    colorInput2 = value;
                                    b.invalidate();
                                }
                            }
                        }),
                        { border: "1px solid #cccccc" }
                    )
                ],
                { display: "flex", justifyContent: "space-between", alignItems: "center" }
            )
        })
    ];
});

function info(name: string, description: string): b.IBobrilChildren {
    return [b.styledDiv(name, { color: "grey", fontStyle: "italic" }), b.styledDiv(description, { paddingBottom: "15px" })];
}

const spriteImage = b.asset(bobwai__color_operations.testOnly_png);
function dynamicSpriteTest(colorId: string, dynamicColor: colorOperations.IColor): b.IBobrilNode {
    return b.styledDiv(
        [
            b.styledDiv(`dynamic color ${colorId} used on sprite`, labelStyle),
            b.styledDiv("", b.sprite(spriteImage, dynamicColor)),

            b.styledDiv("opacity 0.5", { color: colorOperations.hexToRgba(dynamicColor, 0.5) }, labelStyle),
            b.styledDiv("", b.sprite(spriteImage, colorOperations.hexToRgba(dynamicColor, 0.5))),

            b.styledDiv("changeShade -0.25", { color: colorOperations.changeShade(dynamicColor, -0.25) }, labelStyle),
            b.styledDiv("", b.sprite(spriteImage, colorOperations.changeShade(dynamicColor, -0.25)))
        ],
        testStyle
    );
}

let dynColor1 = "#aa00aa";
function dynamicColor1(): string {
    return dynColor1;
}

let dynColor2 = "#00aa00";
function dynamicColor2(): string {
    return dynColor2;
}

function getChangeShadePreview(color: colorOperations.IColor): b.IBobrilNode {
    return b.styledDiv([
        getColorPreviewText(color),
        [-0.5, -0.25, 0, 0.25, 0.5].map((value: number) => {
            return getColorPreview(colorOperations.changeShade(color, value), value);
        })
    ]);
}

function getMixColorPreview(color1: colorOperations.IColor, color2: colorOperations.IColor): b.IBobrilNode {
    return b.styledDiv([
        getColorPreviewText(color1),
        [1, 0.75, 0.5, 0.25, 0].map((value: number) => {
            return getColorPreview(colorOperations.mixColors(color1, color2, value), value);
        }),
        getColorPreviewText(color2)
    ]);
}

function getColorPreview(color: colorOperations.IColor, value: number): b.IBobrilNode {
    return b.styledDiv([value, b.styledDiv(ColorPreview.create({ color: color }), { padding: "0 10px" })], {
        width: 40,
        height: 40,
        display: "inline-block",
        textAlign: "center"
    });
}

function getColorPreviewText(color: colorOperations.IColor): b.IBobrilNode {
    let t = color.toString();
    let isFunction = t.length > 7;
    return b.styledDiv(
        isFunction ? t : t.toUpperCase(),
        { width: "70px", display: "inline-block", position: "relative", top: 20 },
        isFunction && { fontSize: "70%" }
    );
}

const labelStyle = b.styleDef({
    background: "#ffffff"
});
const testStyle = b.styleDef({
    cssFloat: "left",
    width: 200,
    marginLeft: 10,
    background:
        "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAL0lEQVQ4y2PcvXv3fwY8wMXFBZ80AxMDhWDUgMFgAOP////xpoM9e/aMBuLwNwAAjZgKS7KwDDwAAAAASUVORK5CYII=)"
});
