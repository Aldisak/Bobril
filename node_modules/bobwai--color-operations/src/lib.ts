export type IColor = string | IColorFunc;
export type IColorFunc = (() => string);
type IColorFuncMap = { [key: string]: IColor };

export interface IRGBColor {
    r: number;
    g: number;
    b: number;
}

/**
 * Contrast ratio safety threshold
 * @description https://www.w3.org/TR/WCAG21/#contrast-minimum
 */
export enum ContrastRatioSafetyThreshold {
    /** Enhanced minimum for usual font size */
    largeDelta = 7,
    /** Minimum for usual font size or enhanced minimum for large-scale text */
    default = 4.5,
    /** Minimum for large-scale text */
    smallDelta = 3
}

/**
 * Computes HEX color model from HSV.
 * @param h - Hue in HSV.
 * @param s - Saturation in HSV.
 * @param v - Value (sometimes called brightness) in HSV.
 */
export function hsvToHex(h: number, s: number, v: number): string {
    let r, g, b, i, f, p, q, t;
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0:
            (r = v), (g = t), (b = p);
            break;
        case 1:
            (r = q), (g = v), (b = p);
            break;
        case 2:
            (r = p), (g = v), (b = t);
            break;
        case 3:
            (r = p), (g = q), (b = v);
            break;
        case 4:
            (r = t), (g = p), (b = v);
            break;
        case 5:
            (r = v), (g = p), (b = q);
            break;
        default: {
            (r = v), (g = t), (b = p);
        }
    }
    return rgbToHex(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255));
}

/**
 * Computes HSV color model from HEX.
 * @param hex - Color in hex string.
 */
export function hexToHsv(hex: string): any {
    let rbg = hexToRgb(hex);
    let r = rbg[0],
        g = rbg[1],
        b = rbg[2],
        max = Math.max(r, g, b),
        min = Math.min(r, g, b),
        d = max - min,
        h,
        s = max === 0 ? 0 : d / max,
        v = max / 255;

    switch (max) {
        case min:
            h = 0;
            break;
        case r:
            h = g - b + d * (g < b ? 6 : 0);
            h /= 6 * d;
            break;
        case g:
            h = b - r + d * 2;
            h /= 6 * d;
            break;
        case b:
            h = r - g + d * 4;
            h /= 6 * d;
            break;
    }
    return {
        h: h,
        s: s,
        v: v
    };
}

/**
 * Computes darker/lighter color shade
 * @param hexColor - Color as hex string or hex returning function.
 * @param lum - Number from -1 to 1 to set shade, -1 for the darkest, 1 for the lightest.
 */
export function changeShade(hexColor: IColor, lum: number): IColor {
    return typeof hexColor === "function" ? getChangeShadeFunction(hexColor, lum) : changeShadeInternal(hexColor, lum);
}

function changeShadeInternal(hex: string, lum: number): string {
    let hsv = hexToHsv(hex);
    hsv.v = hsv.v + lum;
    if (hsv.v < 0) {
        hsv.v = 0;
    }
    if (hsv.v > 1) {
        hsv.v = 1;
    }
    return hsvToHex(hsv.h, hsv.s, hsv.v);
}

function getChangeShadeFunction(colorFunc: IColorFuncMap | IColorFunc, lum: number): IColorFunc {
    return getColorOperationFunction(<IColorFuncMap>colorFunc, "changeShade" + lum, () => {
        return () => {
            return changeShadeInternal((<IColorFunc>colorFunc)(), lum);
        };
    });
}

/**
 * Makes a dynamic color to become fixed (no color changes will be applied)
 * !Warning: Use only for special cases, keep dynamic value as much as possible
 */
export function makeFixedValue(color: IColor): string {
    return typeof color === "function" ? color() : color;
}

/**
 * Computes color with opacity in [r,g,b,a] format
 * @param hexColor - accepts color in hex string - short #aef and long #aaeeff
 * @param alpha - accepts number from 0 to 1
 */
export function hexToRgba(hexColor: IColor, alpha: number): IColor {
    return typeof hexColor === "function" ? getHexToRgbaFunction(hexColor, alpha) : `rgba(${hexToRgbaInternal(hexColor, alpha)})`;
}

function hexToRgbaInternal(hex: string, alpha: number): number[] {
    return hexToRgb(hex).concat([alpha]);
}

function getHexToRgbaFunction(colorFunc: IColorFuncMap | IColorFunc, alpha: number): IColorFunc {
    return getColorOperationFunction(<IColorFuncMap>colorFunc, "hexToRgba" + alpha, () => {
        return () => {
            return `rgba(${hexToRgbaInternal((<IColorFunc>colorFunc)(), alpha)})`;
        };
    });
}

/**
 * Converts RGB to Hex
 */
export function rgbToHex(red: number, green: number, blue: number): string {
    let rgb = blue | (green << 8) | (red << 16);
    return "#" + (0x1000000 + rgb).toString(16).slice(1);
}

/**
 * Converts HEX to RGB
 */
export function hexToRgb(hex: string): number[] {
    hex = hex.replace(/[^0-9a-f]/gi, "");
    if (hex.length < 6) {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    let regx = /^([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return regx ? regx.slice(1).map((cs: string) => parseInt(cs, 16)) : [];
}

// TODO: use this from shared library of validation functions -  or move it there.
const hexaColorValidationRegex = "^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$";

function validHexaColor(color: string): boolean {
    let reg = new RegExp(hexaColorValidationRegex);
    return reg.test(color);
}

/**
 * Converts HEX to CMYK
 * @param hex - color in hexa format e.g. #1234AB (with or without '#')
 * @param outputInPercent - you can set returned value in percentage value by 'true' or in float by 'false'
 * @return color in CMYK format
 */
export function hexToCmyk(hex: string, outputInPercent?: boolean): number[] {
    let c = 0;
    let m = 0;
    let y = 0;
    let k = outputInPercent ? 100 : 1;
    let r = 0;
    let g = 0;
    let b = 0;

    if (!validHexaColor(hex)) {
        return [];
    }

    if (hex.length === 7) {
        r = parseInt(hex.substring(1, 3), 16);
        g = parseInt(hex.substring(3, 5), 16);
        b = parseInt(hex.substring(5, 7), 16);
    } else {
        r = parseInt(hex.substring(1, 2), 16);
        g = parseInt(hex.substring(2, 3), 16);
        b = parseInt(hex.substring(3, 4), 16);
    }

    if (r === 0 && g === 0 && b === 0) {
        return [c, m, y, k];
    } // if black

    c = 1 - r / 255;
    m = 1 - g / 255;
    y = 1 - b / 255;

    let minCMY = Math.min(c, Math.min(m, y));

    c = (c - minCMY) / (1 - minCMY);
    m = (m - minCMY) / (1 - minCMY);
    y = (y - minCMY) / (1 - minCMY);
    k = minCMY;

    if (outputInPercent) {
        c = Math.round(c * 100);
        m = Math.round(m * 100);
        y = Math.round(y * 100);
        k = Math.round(k * 100);
    }

    return [c, m, y, k];
}

/**
 * Converts CMYK to RGB
 * @param c, m, y, k - simple color from CMYK format
 * @param inputInPercent - you can set input value format in percentage value by 'true' or in float by 'false'
 * @return color in RGB format
 */
export function cmykToRgb(c: number, m: number, y: number, k: number, inputInPercent?: boolean): number[] {
    let r = 0;
    let g = 0;
    let b = 0;

    if (inputInPercent) {
        c = c / 100;
        m = m / 100;
        y = y / 100;
        k = k / 100;
    }

    r = 1 - Math.min(1, c * (1 - k) + k);
    g = 1 - Math.min(1, m * (1 - k) + k);
    b = 1 - Math.min(1, y * (1 - k) + k);

    r = Math.round(r * 255);
    g = Math.round(g * 255);
    b = Math.round(b * 255);

    return [r, g, b];
}

/**
 * calculates combination of two specified colors
 * @param hexColor1 first color
 * @param hexColor2 second color
 * @param ratio (1 means full hexColor1, 0 means full hexColor2)
 */
export function mixColors(hexColor1: IColor, hexColor2: IColor, ratio: number): IColor {
    let c1: string = getColorString(hexColor1);
    let c2: string = getColorString(hexColor2);

    if (!validHexaColor(c1) && !validHexaColor(c2)) {
        return "";
    }

    ratio = Math.min(1, Math.max(0, ratio));

    let s: string = "#";
    for (let channelNr: number = 0; channelNr <= 2; channelNr++) {
        s += mixColorChannel(c1, c2, ratio, channelNr);
    }

    return s;
}

function getColorString(hexColor: IColor): string {
    return typeof hexColor === "function" ? hexColor() : hexColor;
}

// combines one channel from specified hex colors with defined ratio
function mixColorChannel(hexColor1: string, hexColor2: string, ratio: number, channelNr: number): string {
    let mixedValue: number = mixColorChannelValues(
        getColorChannelValue(hexColor1, channelNr),
        getColorChannelValue(hexColor2, channelNr),
        ratio
    );
    return ("0" + mixedValue.toString(16)).slice(-2);
}

// combines two values of color channel with specified ratio
function mixColorChannelValues(colorChannelValue1: number, colorChannelValue2: number, ratio: number) {
    let channel1: number = colorChannelValue1 * ratio;
    let channel2: number = colorChannelValue2 * (1 - ratio);
    let res = Math.min(Math.round(channel1 + channel2), 255);
    return res;
}

// returns numeric value of specified color channel
function getColorChannelValue(hexColor: string, channelNr: number): number {
    let channelLength = (hexColor.length - 1) / 3;
    let channelHexValue = hexColor.substr(channelNr * channelLength + 1, channelLength);
    return parseInt(channelHexValue, 16);
}

// helper function to create color operations for dynamic colors

let lastFuncId = 0;
const funcIdName = "bobwai--color-operations@funcId";
interface IFuncMap {
    [colorOperationFuncId: string]: IColorFunc;
}
let colorOperationFuncs: IFuncMap = {};

function getColorOperationFunction(
    colorFunc: IColorFuncMap,
    colorOperationFuncSuffix: string,
    colorOperationFuncBuilder: () => IColorFunc
): IColorFunc {
    let colorId = colorFunc[funcIdName];
    if (!colorId) {
        colorId = "" + lastFuncId++;
        colorFunc[funcIdName] = colorId;
    }

    let colorOperationFuncId = `${colorId}:${colorOperationFuncSuffix}`;
    let colorOperationFunc = colorOperationFuncs[colorOperationFuncId];
    if (!colorOperationFunc) {
        colorOperationFunc = colorOperationFuncBuilder();
        colorOperationFuncs[colorOperationFuncId] = colorOperationFunc;
    }
    return colorOperationFunc;
}

/**
 * Get contrast ratio
 * @description Source: https://www.w3.org/TR/WCAG21/#dfn-relative-luminance
 * @param {IRGBColor} color1
 * @param {IRGBColor} color2
 * @return {number} <1, 21>
 */
export function getContrastRatio(color1: IRGBColor, color2: IRGBColor): number {
    let ratio, luminance1, luminance2;

    luminance1 = getRelativeLuminance(color1);
    luminance2 = getRelativeLuminance(color2);

    ratio = (luminance1 + 0.05) / (luminance2 + 0.05);

    if (luminance1 < luminance2) {
        ratio = 1 / ratio;
    }

    return Math.floor(ratio * 100) / 100;
}

/**
 * Is contrast ratio large enough for text to be well readable
 * @description Source: https://www.w3.org/TR/WCAG21/#contrast-minimum
 * @param ratio
 * @param safetyThreshold
 * @return {boolean}
 */
export function isContrastRatioSafe(ratio: number, safetyThreshold?: ContrastRatioSafetyThreshold): boolean {
    let minimalRatio = ContrastRatioSafetyThreshold.default;

    if (safetyThreshold !== undefined) {
        minimalRatio = safetyThreshold;
    }

    return ratio >= minimalRatio;
}

/**
 * Get relative luminance
 * @param {IRGBColor} rgb
 * @return {number}
 */
function getRelativeLuminance(rgb: IRGBColor): number {
    return 0.2126 * luminance(rgb.r) + 0.7152 * luminance(rgb.g) + 0.0722 * luminance(rgb.b);
}

/**
 * Luminance
 * @param {number} baseColor
 * @return {number}
 */
function luminance(baseColor: number): number {
    baseColor /= 255;

    if (baseColor <= 0.03928) {
        return baseColor / 12.92;
    }
    return Math.pow((baseColor + 0.055) / 1.055, 2.4);
}

/**
 * Is color combination safe
 * @param {IRGBColor} color1
 * @param {IRGBColor} color2
 * @param {ContrastRatioSafetyThreshold=} safetyThreshold
 * @return {boolean}
 */
export function isColorCombinationSafe(color1: IRGBColor, color2: IRGBColor, safetyThreshold?: ContrastRatioSafetyThreshold): boolean {
    let contrastRatio = getContrastRatio(color1, color2);

    return isContrastRatioSafe(contrastRatio, safetyThreshold);
}

export enum GradientTypes {
    Linear,
    Circle,
    Ellipsis
}

export interface IGradientPoint {
    //in percent
    position: number;
    hexColor: IColor;
    opacity: number;
}

export function getGradientBackground(points: IGradientPoint[], gradientType?: GradientTypes, angle?: number): string {
    let sortedPoints: IGradientPoint[] = [...points];

    if (sortedPoints.length === 1) {
        sortedPoints.push(sortedPoints[0]);
    }

    sortedPoints.sort((a: IGradientPoint, b: IGradientPoint) => {
        return a.position - b.position;
    });

    let background =
        gradientType === undefined || gradientType === GradientTypes.Linear
            ? `linear-gradient(${angle ? angle + "deg" : "to right"}, `
            : `radial-gradient(${gradientType === GradientTypes.Circle ? "circle, " : ""}`;
    sortedPoints.forEach(marker => {
        background += `${hexToRgba(marker.hexColor, marker.opacity)} ${marker.position}%,`;
    });
    background = background.substr(0, background.length - 1);
    background += ")";

    return background;
}
