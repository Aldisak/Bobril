import * as b from "bobril";
import * as Color from "bobwai--color";
import * as Button from "./button";
import * as ColorPicker from "./colorPicker";
import { availableColors } from "./defaultColors";
import { activeButtonBackground, groupDarkColor, groupDarkHoverColor } from "./localVariables";

export interface IFieldParams<T> {
    fieldFactory?: (data: any) => b.IBobrilNode;
    label?: string;
    labelWidth?: number;
    value?: T;
    isDisabled?: boolean;
    onChange?: (value: T) => void;
    fieldType?: FieldType;
    displayAs?: FieldDisplayAs;
    customValueContent?: b.IBobrilChildren;
    minValue?: number;
    maxValue?: number;
    step?: number;
    availableValues?: number[];
    obsoleteMessage?: string;
    note?: string;
}

export enum FieldDisplayAs {
    Block,
    InlineBlock,
}

export enum FieldType {
    Textbox,
    Checkbox,
    Note,
    IColor,
    Spinner,
    Switch,
}

interface IControlPanelParams {
    children?: b.IBobrilChildren[];
    /**
     * @deprecated - use children instead of
     */
    items?: b.IBobrilChildren[];
    columns?: IExampleColumnParams[];
    theme?: ControlPanelTheme;
}

export enum ControlPanelTheme {
    Default,
    Light,
}

export function createControlPanel(params: IControlPanelParams): b.IBobrilNode {
    const isMobile = b.getMedia().deviceCategory === b.BobrilDeviceCategory.Mobile;

    return b.styledDiv(
        b.style(
            {
                tag: "div",
                component: {
                    render(ctx: IContext, me: b.IBobrilNode) {
                        const items = params.items || params.children;
                        me.children = [
                            !ctx.isCollapsed && items && b.flatten(items).map((item) => b.styledDiv(item, exampleItemStyle)),
                            !ctx.isCollapsed &&
                                params.columns &&
                                params.columns.map((column: IExampleColumnParams) =>
                                    b.styledDiv(
                                        column.items.map((item) => b.styledDiv(item, exampleItemStyle)),
                                        [exampleColumnStyle, column.hasSeparator && exampleColumnSeparatorStyle]
                                    )
                                ),
                        ];
                    },
                },
            },

            [controlPanelStyle, isMobile && controlPanelMobileStyle]
        ),
        controlPanelWrapperStyle,
        params.theme === ControlPanelTheme.Light && controlPanelWrapperLightStyle
    );
}

const exceptionMessage = b.styledDiv("Invalid configuration : missing field factory");

export type FieldParam = number | string | boolean | Color.IColor;

export function createField<T extends FieldParam>(params: IFieldParams<T>): b.IBobrilNode {
    function getContent(): b.IBobrilNode | undefined {
        if (params.fieldType === FieldType.Textbox) {
            return params.fieldFactory
                ? params.fieldFactory({
                      size: 1,
                      isDisabled: params.isDisabled,
                      value: <string>params.value,
                      onChange: (v: string) => {
                          if (params.onChange !== undefined) {
                              params.onChange(<T>v);
                          }
                      },
                  })
                : exceptionMessage;
        }
        if (params.fieldType === FieldType.Spinner) {
            return params.fieldFactory
                ? params.fieldFactory({
                      size: 1,
                      variant: 1,
                      value: <number>params.value,
                      onChange: (v: number) => {
                          if (params.onChange !== undefined) {
                              params.onChange(<T>v);
                          }
                      },
                      isDisabled: params.isDisabled,
                      minValue: params.minValue,
                      maxValue: params.maxValue,
                      step: params.step,
                      availableValues: params.availableValues,
                  })
                : exceptionMessage;
        }
        if (params.fieldType === FieldType.Checkbox) {
            return params.fieldFactory
                ? params.fieldFactory({
                      value: <boolean>params.value,
                      onChange: (v: boolean) => {
                          if (params.onChange !== undefined) {
                              params.onChange(<T>v);
                          }
                      },
                      isDisabled: params.isDisabled,
                  })
                : exceptionMessage;
        }

        if (params.fieldType === FieldType.IColor) {
            return b.styledDiv([
                ColorPicker.create({
                    availableValues: availableColors.map((c) => c.colorValue),
                    onChange: (v: string) => {
                        if (params.onChange !== undefined) {
                            params.onChange(<T>v);
                        }
                    },
                }),

                b.styledDiv(
                    [
                        Button.create({
                            label: "App",
                            isSmall: true,
                            background: Color.Application(),
                            onClick: () => {
                                if (params.onChange !== undefined) {
                                    params.onChange(<T>Color.Application);
                                }
                            },
                        }),
                        Button.create({
                            background: Color.Chart_Violet500,
                            isSmall: true,
                            label: "App color to violet",
                            onClick: () => {
                                Color.setApplicationColor(Color.Chart_Violet500);
                                b.invalidateStyles();
                            },
                        }),
                        Button.create({
                            background: Color.Black,
                            isSmall: true,
                            label: "Restore App color",
                            onClick: () => {
                                Color.restoreDefaultApplicationColor();
                                b.invalidateStyles();
                            },
                        }),
                    ].map((item) => {
                        return b.styledDiv(item, exampleInlineItemStyle);
                    }),
                    exampleInlineItemsStyle
                ),
            ]);
        }
        if (params.fieldType === FieldType.Switch) {
            return params.fieldFactory
                ? params.fieldFactory({
                      value: <boolean>params.value,
                      onChange: (v: boolean) => {
                          if (params.onChange !== undefined) {
                              params.onChange(<T>v);
                          }
                      },
                      onLabel: "On",
                      offLabel: "Off",
                      //  offColor: 1,
                      onColor: 2,
                      isDisabled: params.isDisabled,
                  })
                : exceptionMessage;
        }
        if (params.fieldType === FieldType.Note) {
            return b.styledDiv(<string>params.value, exampleNoteStyle);
        }
        return undefined;
    }
    return b.styledDiv(
        [
            b.styledDiv(params.label + ":", [
                exampleFieldLabelStyle,
                isInlineField(params.fieldType, params.displayAs) && exampleFieldInlineLabelStyle,
                params.labelWidth && { width: params.labelWidth },
            ]),
            b.styledDiv(params.customValueContent !== undefined ? params.customValueContent : getContent(), [
                exampleFieldStyle,
                isInlineField(params.fieldType, params.displayAs) && exampleInlineFieldStyle,
                params.labelWidth && { width: `calc(100% - ${params.labelWidth}px` },
            ]),
            params.obsoleteMessage && b.styledDiv(params.obsoleteMessage, exampleObsoleteTextStyle),
            params.note && b.styledDiv(params.note, exampleNoteStyle),
        ],
        [params.obsoleteMessage && exampleObsoleteBackgroundStyle, params.note && exampleNoteBackgroundStyle]
    );
}

function isInlineField(fieldType?: FieldType, fieldDisplayAs?: FieldDisplayAs): boolean {
    if (fieldDisplayAs === FieldDisplayAs.InlineBlock) {
        return true;
    }
    switch (fieldType) {
        case FieldType.Switch:
        case FieldType.Spinner:
        case FieldType.Checkbox:
            return true;
    }
    return false;
}

export function createSeparator(): b.IBobrilNode {
    return b.styledDiv("", { height: 1, margin: 10, background: "#d4d4d4" });
}

export interface IEnumComboParams<T extends string | number> {
    comboboxFactory: (data: any) => b.IBobrilNode;
    enum: { [e: number]: string };
    value: T | undefined;
    onChange: (v: T) => void;
    allowedEnumValues?: T[];
    isDisabled?: boolean;
}

export function createComboEnum<T extends string | number>(params: IEnumComboParams<T>): b.IBobrilNode {
    return params.comboboxFactory(<any>{
        size: 1,
        value: params.value,
        onChange: params.onChange,
        items: enumToComboItems(params.enum, params.allowedEnumValues),
        isDisabled: params.isDisabled,
        displayAs: 1,
    });
}

function enumToComboItems(s: { [d: string]: string }, allowedValues?: (number | string)[]): { label: string; value: any }[] {
    const items: { label: string; value: any }[] = [];
    Object.keys(s).forEach((key) => {
        if (typeof s[key] === "string") {
            let value: number | string = parseInt(key);
            if (isNaN(value)) {
                value = s[key];
            }
            if (allowedValues && allowedValues.length) {
                if (allowedValues.indexOf(value) === -1) {
                    return;
                }
            }
            items.push({ label: s[key], value: value });
        }
    });
    return items;
}

export interface IExampleGroupParams {
    children?: b.IBobrilChild[];
    /**
     * @deprecated - use children instead of
     */
    items?: b.IBobrilChild[];
    name: string;
    theme?: ExampleGroupTheme;
    radio?: IExampleGroupRadio;
}

export interface IExampleGroupRadio {
    radioFactory: (data: any) => b.IBobrilNode;
    value: boolean | undefined;
    onChange: (v: boolean) => void;
    groupName: string;
}

export enum ExampleGroupTheme {
    Default,
    Dark,
}

interface IContext extends b.IBobrilCtx {
    isCollapsed: boolean;
    areAdvancedParametersVisible: boolean;
}
export function createGroup(params: IExampleGroupParams): b.IBobrilNode {
    return b.style({
        tag: "div",
        component: {
            render(ctx: IContext, me: b.IBobrilNode) {
                const items = params.children || params.items;
                me.children = [
                    b.style(
                        {
                            tag: "div",
                            children: [
                                params.radio &&
                                    b.styledDiv(
                                        params.radio.radioFactory({
                                            value: params.radio.value,
                                            onChange: (v: boolean) => {
                                                if (v && ctx.isCollapsed) {
                                                    ctx.isCollapsed = false;
                                                }
                                                params.radio!.onChange(v);
                                            },
                                            groupName: params.radio.groupName,
                                        }),
                                        exampleGroupRadioWrapperStyle
                                    ),
                                b.styledDiv(params.name, { flexShrink: 0 }),
                                b.style(
                                    {
                                        tag: "div",
                                        children: ctx.isCollapsed ? "▼" : "▲",
                                        component: {
                                            onClick(_ctx: b.IBobrilCtx, _e: b.IBobrilMouseEvent): boolean {
                                                ctx.isCollapsed = !ctx.isCollapsed;
                                                b.invalidate(ctx);
                                                return true;
                                            },
                                        },
                                    },
                                    [exampleGroupCollapsedStyle, params.theme === ExampleGroupTheme.Dark && exampleGroupCollapsedDarkStyle]
                                ),
                            ],
                            component: {
                                onClick(_ctx: b.IBobrilCtx, _e: b.IBobrilMouseEvent): boolean {
                                    if (params.radio) {
                                        if (!params.radio.value) {
                                            if (ctx.isCollapsed) {
                                                ctx.isCollapsed = false;
                                            }
                                            params.radio.onChange(true);
                                        }
                                    } else {
                                        ctx.isCollapsed = !ctx.isCollapsed;
                                    }
                                    b.invalidate(ctx);
                                    return true;
                                },
                            },
                        },
                        [exampleGroupLabelStyle, params.theme === ExampleGroupTheme.Dark && exampleGroupLabelDarkStyle]
                    ),
                    items &&
                        b.styledDiv(
                            [
                                ...items!.map((i) => {
                                    return b.styledDiv(i, exampleGroupItemStyle);
                                }),
                            ],
                            ctx.isCollapsed && { visibility: "collapse", height: 0 },
                            params.radio?.value === false && exampleGroupItemsDisabledStyle
                        ),
                ];
            },
        },
    });
}

export interface IExampleColumnParams {
    items: b.IBobrilNode[];
    hasSeparator?: boolean;
}

const exampleGroupItemStyle = b.styleDef({ paddingLeft: 7 });

const exampleGroupItemsDisabledStyle = b.styleDef(
    {
        position: "relative",
        opacity: 0.4,
    },
    { ":after": { content: "''", position: "absolute", left: 0, top: 0, right: 0, bottom: 0, background: "rgba(0,0,0,0)" } }
);
const exampleGroupLabelStyle = b.styleDef(
    {
        fontWeight: "bold",
        padding: 7,
        display: "flex",
        cursor: "pointer",
        alignItems: "center",
        marginLeft: -20,
        marginRight: -20,
        paddingLeft: 25,
        paddingRight: 25,
        color: activeButtonBackground,
    },
    {
        hover: {
            backgroundColor: groupDarkHoverColor,
        },
    }
);

const exampleGroupLabelDarkStyle = b.styleDefEx(exampleGroupLabelStyle, {
    color: groupDarkColor,
});

const exampleGroupCollapsedStyle = b.styleDef({
    fontSize: 14,
    textAlign: "right",
    paddingLeft: 10,
    width: "100%",
    fontWeight: "bold",
    color: activeButtonBackground,
});

const exampleGroupCollapsedDarkStyle = b.styleDefEx(exampleGroupCollapsedStyle, {
    color: groupDarkColor,
});

const exampleGroupRadioWrapperStyle = b.styleDef({
    marginTop: 1,
});

const exampleObsoleteTextStyle = b.styleDef({ color: "red", fontWeight: "bold" });

const exampleColumnStyle = b.styleDef({
    maxWidth: 400,
    display: "inline-block",
    verticalAlign: "top",
    padding: "10px 20px",
});

const exampleItemStyle = b.styleDef({
    paddingTop: 7,
});

const exampleColumnSeparatorStyle = b.styleDef({
    borderRight: "1px solid #d4d4d4",
});

const exampleObsoleteBackgroundStyle = b.styleDef({ padding: 2, background: "rgba(255,0,0,.25)" });
const exampleNoteBackgroundStyle = b.styleDef({ padding: 2, background: "#d9f1fd" });

const exampleNoteStyle = b.styleDef({
    color: Color.Info,
});

const exampleFieldStyle = b.styleDef({
    paddingBottom: 5,
    boxSizing: "border-box",
    verticalAlign: "middle",
});
const exampleInlineFieldStyle = b.styleDef({
    display: "inline-block",
    width: "calc(100% - 150px)",
    textAlign: "right",
});

const exampleFieldLabelStyle = b.styleDef({
    fontSize: 13,

    marginBottom: 2,
    verticalAlign: "middle",

    fontWeight: 500,
});

const exampleFieldInlineLabelStyle = b.styleDef({
    display: "inline-block",
    width: 150,
});

const exampleInlineItemStyle = b.styleDef({
    marginRight: 5,
    display: "inline-block",
    verticalAlign: "middle",
});

const exampleInlineItemsStyle = b.styleDef({
    whiteSpace: "nowrap",
});

const controlPanelStyle = b.styleDef({});

const controlPanelWrapperStyle = b.styleDef({
    background: Color.Grey200,
    padding: 20,
    display: "inline-block",
    minWidth: 300,
});

const controlPanelWrapperLightStyle = b.styleDefEx(controlPanelWrapperStyle, {
    background: Color.White,
});

const controlPanelMobileStyle = b.styleDefEx(controlPanelStyle, {
    minWidth: "auto",
});
