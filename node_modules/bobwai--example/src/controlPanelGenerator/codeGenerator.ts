import * as b from "bobril";
import { ICodeGeneratorContext, IInternalCodeGeneratorAdditionalSettings } from "./contexts";
import { availableColors } from "../defaultColors";
import { getComponentNameCamelCase } from "./utils";
import { ICodeGeneratorComponentDefinition } from "./data";
import { getImportsToString, addNewImport } from "./importStrings";
// import {format} from "prettier/standalone";
// import * as PrettierTypescriptParserPlugin from "prettier/parser-typescript";
// import { Options } from "prettier";

export enum CodeType {
    TSX,
    TS,
    IData,
}

export function getCode(params: {
    ctx: ICodeGeneratorContext;
    fullComponentName: string;
    componentName: string;
    data: any;
    codeType: CodeType;
    substituteValues?: IInternalCodeGeneratorAdditionalSettings[];
}): string {
    params.ctx.imports = [];

    if (isTSX(params.codeType)) {
        // TSX need bobril import for proper functioning
        params.ctx.imports.push({ fullComponentName: "bobril", importAll: { alias: "b" } });
    }
    params.ctx.imports.push({
        fullComponentName: params.fullComponentName,
        importParts: [{ name: params.componentName }],
    });

    const isPairedTag = params.data.hasOwnProperty("children");

    // begin the code
    let code = createStartPointOfTheCode({
        componentName: params.componentName,
        codeType: params.codeType,
        isPairedTag,
    });
    // Add space if there is paired tag and there are also other properties
    if (isTSX(params.codeType) && isPairedTag && Object.keys(params.data).length > 1) {
        code += "\n";
    }

    for (const key in params.data) {
        if (params.data.hasOwnProperty(key)) {
            // in TSX children property is as a content so it is not a property
            if (isTSX(params.codeType) && key === "children") {
                continue;
            }
            code += getPropertyValue(
                params.fullComponentName,
                params.ctx,
                params.componentName,
                key,
                params.data[key],
                params.codeType,
                params.substituteValues,
                undefined,
                1
            );
        }
    }

    code += isTSX(params.codeType) && isPairedTag ? ">" : "";

    // end of the code or generate children for tsx
    if (isTSX(params.codeType)) {
        code += isPairedTag
            ? generateChildrenForPairedTSXTag({
                  ctx: params.ctx,
                  fullComponentName: params.fullComponentName,
                  componentName: params.componentName,
                  data: params.data,
                  codeType: params.codeType,
                  level: 0,
                  substituteValues: params.substituteValues,
              })
            : `/>`;
        // in case of tsx first import string is bobril
        //  params.ctx.importStrings[1] = `import {${mainImportName.v}} from "${params.fullComponentName}"; \n`;
    }
    if (isTS(params.codeType)) {
        code += `})`;
        // params.ctx.importStrings[0] = `import {${mainImportName.v}} from "${params.fullComponentName}"; \n`;
    }
    if (isIData(params.codeType)) {
        code += `}`;
    }

    const imports = !isIData(params.codeType) ? getImportsToString(params.ctx.imports) + "\n" : "";

    return imports + code;
}

const tabSize = "\t";

function createStartPointOfTheCode(params: { codeType: CodeType; componentName: string; isPairedTag: boolean }): string {
    let codeBegin = "";
    if (isTSX(params.codeType)) {
        if (params.isPairedTag) {
            codeBegin = `<${params.componentName}`;
        } else {
            codeBegin = `<${params.componentName}\n`;
        }
    }
    if (isTS(params.codeType)) {
        codeBegin = `${params.componentName}({\n`;
    }
    if (isIData(params.codeType)) {
        codeBegin = `{\n`;
    }
    return codeBegin;
}

function getPropertyValue(
    fullComponentName: string,
    ctx: ICodeGeneratorContext,
    prefix: string,
    propertyName: string,
    value: any,
    codeType: CodeType,
    additionalSettings?: IInternalCodeGeneratorAdditionalSettings[],
    parentPropertyName?: string,
    level: number = 0
): string {
    let actualItemAdditionalSettings: IInternalCodeGeneratorAdditionalSettings | undefined;

    if (additionalSettings && additionalSettings.length) {
        for (let i = 0; i < additionalSettings.length; i++) {
            if (additionalSettings[i].propertyPath === (parentPropertyName ? `${parentPropertyName}.${propertyName}` : `${propertyName}`)) {
                actualItemAdditionalSettings = additionalSettings[i];
                break;
            }
        }
    }

    let assigningSymbol = !propertyName ? "" : parentPropertyName || codeType === CodeType.TS || codeType === CodeType.IData ? ":" : "=";
    const bracketStartSymbol = parentPropertyName || codeType === CodeType.TS || codeType === CodeType.IData ? " " : "{";
    const bracketEndSymbol = parentPropertyName || codeType === CodeType.TS || codeType === CodeType.IData ? "," : "}";
    const arrayStartSymbol = parentPropertyName || codeType === CodeType.TS || codeType === CodeType.IData ? "[" : "{[";
    const arrayEndSymbol = parentPropertyName || codeType === CodeType.TS || codeType === CodeType.IData ? "]" : "]}";

    if (isTSX(codeType) && propertyName === "children") {
        // in tsx, children are rendered directly as tag content not attribute so property name and assigned symbol is not needed
        assigningSymbol = "";
        propertyName = "";
    }

    // READ code generator additional settings
    if (actualItemAdditionalSettings) {
        // COLOR
        if (actualItemAdditionalSettings.isIColor) {
            let colorValue = value;
            if (b.isFunction(colorValue)) {
                colorValue = `Color.${colorValue.name}`;
            } else {
                for (let i = 0; i < availableColors.length; i++) {
                    const color = availableColors[i];
                    if (color.colorValue === value) {
                        colorValue = `Color.${color.colorName}`;
                    }
                }
            }

            // add import for color
            addNewImport(ctx.imports, {
                fullComponentName: "bobwai--color",
                importAll: { alias: "Color" },
            });

            return `${getTabs(level)}${propertyName}${assigningSymbol}${bracketStartSymbol}${colorValue}${bracketEndSymbol}\n`;
        }
        // ENUM
        if (actualItemAdditionalSettings.enumSettings) {
            const enumPrefix = actualItemAdditionalSettings.enumSettings.exportedComponentName ? "" : prefix;
            const enumName = `${enumPrefix}${actualItemAdditionalSettings.enumSettings.enumPropertyName}`;

            if (actualItemAdditionalSettings.enumSettings.exportedComponentName) {
                addNewImport(ctx.imports, {
                    fullComponentName: actualItemAdditionalSettings.enumSettings.exportedComponentName,
                    importParts: [{ name: actualItemAdditionalSettings.enumSettings.enumPropertyName }],
                });

                return `${getTabs(level)}${propertyName}${assigningSymbol}${bracketStartSymbol}${enumName}.${
                    actualItemAdditionalSettings.enumSettings.enum[value]
                }${bracketEndSymbol}\n`;
            }

            addNewImport(ctx.imports, {
                fullComponentName: fullComponentName,
                importParts: [{ name: actualItemAdditionalSettings.enumSettings.enumPropertyName, alias: enumName }],
            });

            return `${getTabs(level)}${propertyName}${assigningSymbol}${bracketStartSymbol}${enumName}.${
                actualItemAdditionalSettings.enumSettings.enum[value]
            }${bracketEndSymbol}\n`;
        }
        // ICON CONTENT
        if (actualItemAdditionalSettings.shouldHaveIconAsContent) {
            if (isTSX(codeType)) {
                return `${getTabs(
                    level
                )}${propertyName}${assigningSymbol}${bracketStartSymbol}\n${tabSize}${tabSize}// TODO ADD ICON\n${tabSize}${bracketEndSymbol}\n`;
            }
            return `${getTabs(level)}${propertyName}${assigningSymbol}${bracketStartSymbol} {}, // TODO ADD ICON\n`;
        }

        // SUBSTITUTE VALUE
        if (actualItemAdditionalSettings.substituteValue) {
            return `${getTabs(level)}${propertyName}${assigningSymbol}${bracketStartSymbol}${
                actualItemAdditionalSettings.substituteValue
            }${bracketEndSymbol}\n`;
        }

        // INNER COMPONENT
        if (actualItemAdditionalSettings.component) {
            let innerComponentCode = "";

            // inner component start code
            if (isTSX(codeType)) {
                innerComponentCode = `${getTabs(level)}${propertyName}${assigningSymbol}{`;
            } else {
                innerComponentCode = `${getTabs(level)}${propertyName}${assigningSymbol} `;
            }

            // if inner component is array of component
            if (b.isArray(actualItemAdditionalSettings.component)) {
                innerComponentCode += `[\n${getTabs(level + 1)}`;
                for (let i = 0; i < actualItemAdditionalSettings.component.length; i++) {
                    const actualComponent = actualItemAdditionalSettings.component[i];
                    innerComponentCode += `${getCodeForInnerComponent({
                        value: value[i],
                        level: level,
                        codeType,
                        propertyName,
                        ctx,
                        component: actualComponent,
                        assigningSymbol,
                    })}${i < actualItemAdditionalSettings.component.length - 1 ? ",\n" + getTabs(level + 1) : ""}`;
                }
                innerComponentCode += `\n${getTabs(level)}]${isTSX(codeType) ? "}\n" : `,\n`}`;
                return innerComponentCode;
            }
            // if value is array but definition for array is missing there should be error about missing array configuration
            else if (b.isArray(value) && !b.isArray(actualItemAdditionalSettings.component)) {
                throw `Property name: ${propertyName} has as content array of component, but additional code generator settings has only single component definition. Add array definition.`;
            }
            // inner component is single component
            else {
                if (isTSX(codeType)) {
                    innerComponentCode += `\n${getTabs(level + 1)}`;
                }
                return (
                    innerComponentCode +
                    getCodeForInnerComponent({
                        value,
                        level,
                        codeType,
                        propertyName,
                        ctx,
                        component: actualItemAdditionalSettings.component,
                        assigningSymbol,
                    }) +
                    `${isTSX(codeType) ? `\n${getTabs(level)}}\n` : ",\n"}`
                );
            }
        }
        // array of the same objects
        if (actualItemAdditionalSettings.arrayOfSameObjects !== undefined) {
            let arrayOfPropertiesCode = "";
            // inner component start code
            if (!(isTSX(codeType) && propertyName === "children")) {
                arrayOfPropertiesCode += `${propertyName}${assigningSymbol} `;
            }

            arrayOfPropertiesCode += `${arrayStartSymbol}\n`;
            for (const key in value) {
                if (value.hasOwnProperty(key)) {
                    arrayOfPropertiesCode += `${getPropertyValue(
                        fullComponentName,
                        ctx,
                        prefix,
                        "",
                        value[key],
                        // it is inner object, so generate code only for object
                        CodeType.IData,
                        actualItemAdditionalSettings.arrayOfSameObjects.properties,
                        ``,
                        level + 1
                    )}`;
                }
            }
            arrayOfPropertiesCode += `${arrayEndSymbol}`;
            if (!isTSX(codeType)) {
                arrayOfPropertiesCode += ",";
            }
            return arrayOfPropertiesCode;
        }
    }

    // BOOLEAN value
    if (b.isBoolean(value)) {
        if (value) {
            if (isTSX(codeType)) {
                return `${getTabs(level)}${propertyName}\n`;
            }
            return `${getTabs(level)}${propertyName}${assigningSymbol} ${value}${bracketEndSymbol}\n`;
        }
        return `${getTabs(level)}${propertyName}${assigningSymbol}${bracketStartSymbol}false${bracketEndSymbol}\n`;
    }

    // STRING value
    if (b.isString(value)) {
        let stringValue = `"${value}"`;
        // add translate
        if (
            (!actualItemAdditionalSettings ||
                (actualItemAdditionalSettings && actualItemAdditionalSettings.isStringValueTranslated !== false)) &&
            codeType !== CodeType.IData
        ) {
            // add import for translate g11n
            addNewImport(ctx.imports, { fullComponentName: "bobril-g11n", importParts: [{ name: "t" }] });
            stringValue = `t(${stringValue})`;
        }
        return `${getTabs(level)}${propertyName}${assigningSymbol}${bracketStartSymbol}${stringValue}${bracketEndSymbol}\n`;
    }

    // NUMBER value
    if (b.isNumber(value)) {
        return `${getTabs(level)}${propertyName}${assigningSymbol}${bracketStartSymbol}${value}${bracketEndSymbol}\n`;
    }

    // FUNCTION value
    if (b.isFunction(value)) {
        if (isTSX(codeType)) {
            return `${getTabs(level)}${propertyName}${assigningSymbol}${bracketStartSymbol}() => {\n ${getTabs(
                level + 1
            )}// TODO: Implement\n${getTabs(level)}${bracketEndSymbol}${bracketEndSymbol}\n`;
        }
        return `${getTabs(level)}${propertyName}${assigningSymbol}${bracketStartSymbol} () => {\n${getTabs(
            level + 1
        )}// TODO: Implement \n${getTabs(level)}},\n`;
    }

    // ARRAY value
    if (b.isArray(value)) {
        let innerObjectCode = "";
        innerObjectCode += `${getTabs(level)}${propertyName}${assigningSymbol}${arrayStartSymbol}\n`;
        for (let i = 0; i < value.length; i++) {
            const v = value[i];
            innerObjectCode += `${getPropertyValue(
                fullComponentName,
                ctx,
                prefix,
                "",
                v,
                codeType,
                additionalSettings,
                `${propertyName}`,
                level + 1
            )}`;
        }
        innerObjectCode += `${getTabs(level)}${arrayEndSymbol},\n`;
        return innerObjectCode;
    }

    // ANY OBJECT VALUE
    else if (b.isObject(value)) {
        let innerObjectCode = "";
        if (isTSX(codeType)) {
            innerObjectCode = `${getTabs(level)}${propertyName}${assigningSymbol}{\n${tabSize}${tabSize}{\n`;
        } else {
            innerObjectCode = `${getTabs(level)}${propertyName}${assigningSymbol} {\n`;
        }
        for (const key in value) {
            if (value.hasOwnProperty(key)) {
                innerObjectCode += `${getPropertyValue(
                    fullComponentName,
                    ctx,
                    prefix,
                    key,
                    value[key],
                    codeType,
                    additionalSettings,
                    `${propertyName}`,
                    level + 1
                )}`;
            }
        }
        if (isTSX(codeType)) {
            innerObjectCode += `${tabSize}${tabSize}}\n${tabSize}}\n`;
        } else {
            innerObjectCode += `${tabSize}}${bracketEndSymbol}\n`;
        }
        return innerObjectCode;
    }

    return `    ${propertyName}${assigningSymbol}${bracketStartSymbol}${value}} `;
}

function getCodeForInnerComponent(params: {
    value: any;
    level: number;
    codeType: CodeType;
    propertyName: string;
    ctx: ICodeGeneratorContext;
    component: ICodeGeneratorComponentDefinition;
    assigningSymbol: string;
}): string {
    const value = params.value;
    const level = params.level;
    const codeType = params.codeType;
    const ctx = params.ctx;
    const component = params.component;
    const componentFullName = value.component.id || "";

    // standard bobril component
    const innerData = value.data;
    const componentCamelCase = value.component && value.component.id ? getComponentNameCamelCase(value.component.id) : "";

    let innerComponentCode = ``;
    const isPairedTag = !!value.data["children"];

    innerComponentCode += createStartPointOfTheCode({
        componentName: componentCamelCase,
        codeType: codeType,
        isPairedTag: isPairedTag,
    });

    // add inner component imports
    addNewImport(ctx.imports, { fullComponentName: componentFullName, importParts: [{ name: componentCamelCase }] });

    if (isTSX(params.codeType) && isPairedTag && Object.keys(innerData).length > 1) {
        innerComponentCode += "\n";
    }

    for (const key in innerData) {
        // in TSX children property is as content not has property
        if (isTSX(params.codeType) && key === "children") {
            continue;
        }
        if (innerData.hasOwnProperty(key)) {
            const propertyName = key;
            const propertyValue = innerData[key];
            innerComponentCode += getPropertyValue(
                componentFullName,
                ctx,
                componentCamelCase,
                propertyName,
                propertyValue,
                codeType,
                component.properties,
                undefined,
                level + 2
            );
        }
    }
    innerComponentCode += isTSX(params.codeType) && isPairedTag ? `${getTabs(level + 1)}>` : "";

    // end of the code or generate children for tsx
    if (isTSX(params.codeType) && isPairedTag) {
        innerComponentCode += generateChildrenForPairedTSXTag({
            ctx: params.ctx,
            fullComponentName: componentFullName,
            componentName: componentCamelCase,
            data: innerData,
            codeType: params.codeType,
            level: level + 1,
        });
    }

    let innerComponentCloseTagCode = isPairedTag ? "" : "/>";
    if (codeType === CodeType.TS) {
        innerComponentCloseTagCode = "})";
    }
    if (codeType === CodeType.IData) {
        innerComponentCloseTagCode = "}";
    }

    innerComponentCode += `${getTabs(level + 1)}${innerComponentCloseTagCode}`;

    return innerComponentCode;
}

function getTabs(count: number): string {
    const tab = "\t";
    let text = "";
    for (let i = 0; i < count; i++) {
        text += tab;
    }
    return text;
}

function isTSX(codeType: CodeType): boolean {
    return codeType === CodeType.TSX;
}
function isTS(codeType: CodeType): boolean {
    return codeType === CodeType.TS;
}
function isIData(codeType: CodeType): boolean {
    return codeType === CodeType.IData;
}

function generateChildrenForPairedTSXTag(params: {
    ctx: ICodeGeneratorContext;
    fullComponentName: string;
    componentName: string;
    data: any;
    codeType: CodeType;
    level: number;
    substituteValues?: IInternalCodeGeneratorAdditionalSettings[];
}): string {
    return `\n${getTabs(1)}${getPropertyValue(
        params.fullComponentName,
        params.ctx,
        params.componentName,
        "children",
        params.data["children"],
        params.codeType,
        params.substituteValues,
        undefined,
        params.level
    )}${getTabs(params.level)}</${params.componentName}>`;
}
