export interface IImport {
    fullComponentName: string;
    importAll?: { alias: string };
    importParts?: { name: string; alias?: string }[];
}

export interface IIportPart {
    importName: string;
    alias?: string;
}

export function addNewImport(currentImports: IImport[], newImport: IImport): void {
    if (newImport.importAll !== undefined) {
        // try to find among full imports
        const existingFullImports = currentImports.filter(
            (f) => f.fullComponentName === newImport.fullComponentName && f.importAll && f.importAll.alias === newImport.importAll!.alias
        );
        // try to find among parts imports
        const existingPartsImports = currentImports.filter(
            (f) =>
                f.fullComponentName === newImport.fullComponentName &&
                f.importParts &&
                getIndexOfImportParts(f.importParts, { name: newImport.importAll!.alias }) > -1
        );
        if (existingFullImports.length === 0 && existingPartsImports.length === 0) {
            currentImports.push(newImport);
        }
    }
    if (newImport.importParts !== undefined) {
        // if already exist import for the whole component we need to change it into parts import
        const existingWholeImports = currentImports.filter((f) => f.fullComponentName === newImport.fullComponentName && f.importAll);
        // convert 'import * as ComponentName from' to 'import {ComponentName} from'
        existingWholeImports.forEach((i) => {
            if (!i.importParts) {
                i.importParts = [];
            }
            i.importParts.push({ name: i.importAll!.alias });
            delete i.importAll;
        });

        const existingImport = currentImports.filter((f) => f.fullComponentName === newImport.fullComponentName && !f.importAll);
        if (existingImport && existingImport.length) {
            existingImport.forEach((existingImport) => {
                if (existingImport.importParts) {
                    newImport.importParts!.forEach((newImportPart) => {
                        const index = getIndexOfImportParts(existingImport.importParts!, {
                            name: newImportPart.name,
                            alias: newImportPart.alias,
                        });
                        if (index === -1) {
                            existingImport.importParts!.push(newImportPart);
                        }
                    });
                }
            });
        } else {
            currentImports.push(newImport);
        }
    }
}

export function getImportsToString(currentImports: IImport[]): string {
    let imports = "";
    currentImports.forEach((i) => {
        if (i.importAll) {
            imports += `import * as ${i.importAll.alias} from "${i.fullComponentName}";\n`;
        } else if (i.importParts) {
            let parts = "";
            i.importParts.forEach((part, index) => {
                parts += `${part.name}`;
                if (part.alias) {
                    parts += ` as ${part.alias}`;
                }
                if (index < i.importParts!.length - 1) {
                    parts += ", ";
                }
            });
            imports += `import {${parts}} from "${i.fullComponentName}";\n`;
        }
    });

    return imports;
}

function getIndexOfImportParts(importParts: { name: string; alias?: string }[], item: { name: string; alias?: string }): number {
    for (let i = 0; i < importParts.length; i++) {
        const element = importParts[i];
        if (element.alias === item.alias && item.name === element.name) {
            return i;
        }
    }
    return -1;
}
