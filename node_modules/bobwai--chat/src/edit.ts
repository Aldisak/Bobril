import * as b from "bobril";
import * as rs from "./editStyle";
import * as button from "bobwai--button";
import * as validationHelper from "helpers--validations";
import { IValidations } from "./rootComment";
import * as keyboard from "bobwai--keyboard-events";
import * as Textarea from "bobwai--textarea";
import * as s from "./styles";
import { IChatWebContentAccessibility } from "./webContentAccessibility";
import * as TextareaTagged from "bobwai--textarea-tagged";
import { User } from "bobwai--textarea-tagged";

export const createEdit = b.createComponent<IEditData>({
    id: "bobwai--chat-edit-buttons",
    render(editCtx: IEditContext, me: b.IBobrilNode) {
        b.style(me, rs.editSubmitStyle);
        me.children = [
            // DELETE
            b.styledDiv(
                button.create({
                    onClick: editCtx.data.onDelete,
                    label: editCtx.data.removeCommentLabel ? editCtx.data.removeCommentLabel : "",
                    size: button.Size.Small,
                    color: button.Theme.None
                }),
                editCtx.data.numberOfReplies !== 0 ? getTextStyle(editCtx) : rs.deleteTextStyleFull
            ),
            // EDIT
            b.styledDiv(
                button.create({
                    onClick: editCtx.data.onClickEdit,
                    label: editCtx.data.editLabel ? editCtx.data.editLabel : "",
                    size: button.Size.Small,
                    color: button.Theme.None
                }),

                rs.editTextStyle
            )
        ];
    }
});

export let createEditArea = b.createVirtualComponent<ITextarea>({
    id: "bobwai--edit-area",
    render(ctx: IContext, me: b.IBobrilNode) {
        let validations = ctx.data.validations;
        me.children = [
            keyboard.create({
                children:
                    validations && validations.validationsCursor !== undefined
                        ? ctx.data.userList && ctx.data.userList.length > 0
                            ? validationHelper.validationComponent<TextareaTagged.IData, string, {}>({
                                  builder: TextareaTagged.create,
                                  componentData: <TextareaTagged.IData>b.assign(createComponentDataForValidationHelper(ctx, validations), {
                                      userList: ctx.data.userList
                                  }),
                                  validationsCursor: validations.validationsCursor,
                                  propertyName: validations.propertyName,
                                  localizeErrorMessage: validations.localizeErrorMessage,
                                  validationTypeEnum: validations.validationTypeEnum
                              })
                            : validationHelper.validationComponent<Textarea.IData, string, {}>({
                                  builder: Textarea.create,
                                  componentData: <Textarea.IData>createComponentDataForValidationHelper(ctx, validations),
                                  validationsCursor: validations.validationsCursor,
                                  propertyName: validations.propertyName,
                                  localizeErrorMessage: validations.localizeErrorMessage,
                                  validationTypeEnum: validations.validationTypeEnum
                              })
                        : ctx.data.userList && ctx.data.userList.length > 0
                        ? TextareaTagged.create(b.assign(createTextareaData(ctx), { userList: ctx.data.userList }))
                        : Textarea.create(createTextareaData(ctx)),
                onEnterPress: () => {
                    if (!ctx.data.inputValue || !ctx.data.inputValue.trim() || isInvalid(ctx.data)) return false;
                    ctx.data.onEdit && ctx.data.onEdit();
                    return true;
                },
                onEscPress: () => {
                    ctx.data.onValueChanged("");
                    return true;
                }
            }),
            // OK
            b.styledDiv(
                button.create({
                    onClick: () => {
                        ctx.data.onSubmit();
                    },
                    label: ctx.data.okLabel ? ctx.data.okLabel : "OK",
                    size: button.Size.Small,
                    color: button.Theme.None,
                    isDisabled: !ctx.data.inputValue || !ctx.data.inputValue.trim() || isInvalid(ctx.data)
                }),
                rs.submitTextStyle
            ),
            // CANCEL, DELETE
            b.styledDiv(
                button.create({
                    onClick: ctx.data.isReply ? ctx.data.onCancel : ctx.data.onDelete,
                    label: ctx.data.isReply ? getCancelLabel(ctx) : getDeleteLabel(ctx),
                    size: button.Size.Small,
                    color: button.Theme.None
                }),
                rs.cancelDeleteTextStyle
            )
        ];
    },
    onFocusOut(ctx: IContext) {
        ctx.data.blurSave && ctx.data.onEditFocusOut && ctx.data.onEditFocusOut();
    }
});

function createComponentDataForValidationHelper(ctx: IContext, validations: IValidations | undefined): Textarea.IData {
    return {
        value: ctx.data.inputValue,
        initState: Textarea.InitState.focused,
        onChange: ctx.data.onValueChanged,
        onFocusIn: () => {
            ctx.data.onActive();
            validations && validationHelper.removeValidationError(validations.validationsCursor, validations.propertyName);
        },
        rows: s.textAreaRowsCount,
        webContentAccessibility: ctx.data.webContentAccessibility
            ? {
                  ariaLabel: ctx.data.webContentAccessibility.editCommentAriaLabel
              }
            : undefined
    };
}

function createTextareaData(ctx: IContext): Textarea.IData | undefined {
    return {
        value: ctx.data.inputValue,
        placeholder: ctx.data.placeholderText,
        initState: Textarea.InitState.focused,
        onChange: ctx.data.onValueChanged,
        onFocusIn: () => ctx.data.onActive(),
        rows: s.textAreaRowsCount,
        maxLength: ctx.data.maxLengthInput,
        webContentAccessibility: ctx.data.webContentAccessibility
            ? {
                  ariaLabel: ctx.data.webContentAccessibility.editCommentAriaLabel
              }
            : undefined
    };
}

function isInvalid(data: ISubmitData | ITextarea) {
    return data.validations && data.validations.validationsCursor && validationHelper.isInvalid(data.validations.validationsCursor);
}

function getTextStyle(editCtx: IEditContext) {
    return editCtx.data.avatarOff ? rs.deleteReplyTextStyleFull : rs.deleteButtonReplyTextStyle;
}

function getCancelLabel(ctx: IContext) {
    return ctx.data.cancelLabel ? ctx.data.cancelLabel : "Cancel";
}

function getDeleteLabel(ctx: IContext) {
    return ctx.data.removeCommentLabel ? ctx.data.removeCommentLabel : "Delete";
}

interface IEditContext extends b.IBobrilCtx {
    data: IEditData;
}

interface IContext extends b.IBobrilCtx {
    data: ITextarea;
}

export interface IEditData {
    onDelete: () => void;
    onClickEdit: () => void;
    removeCommentLabel?: string;
    editLabel?: string;
    numberOfReplies?: number;
    avatarOff?: boolean;
}

export interface ISubmitData {
    onSubmit: () => void;
    onCancel: () => void;
    cancelLabel?: string;
    okLabel?: string;
    inputValue?: string;
    validations?: IValidations;
}

export interface ITextarea {
    inputValue: string;
    webContentAccessibility?: IChatWebContentAccessibility;
    onActive: () => void;
    onEdit?: () => void;
    onValueChanged: (value: string) => void;
    validations?: IValidations;
    maxLengthInput?: number;
    blurSave?: boolean;
    onSubmit: () => void;
    onCancel: () => void;
    cancelLabel?: string;
    okLabel?: string;
    onDelete: () => void;
    removeCommentLabel?: string;
    isReply?: boolean;
    isActive?: boolean;
    onEditFocusOut?: () => void;
    userList?: User[];
    placeholderText?: string;
}
