import * as b from "bobril";
import * as flux from "bobflux";
import * as Textarea from "bobwai--textarea";
import * as keyboard from "bobwai--keyboard-events";
import * as color from "bobwai--color";
import * as rs from "./rootCommentStyle";
import * as s from "./styles";
import * as Icon from "bobwai--icon";
import * as button from "bobwai--button";
import * as cps from "./controlPanelStyle";
import * as validationHelper from "helpers--validations";
import { IChatWebContentAccessibility } from "./webContentAccessibility";
import * as TextareaTagged from "bobwai--textarea-tagged";
import { User } from "bobwai--textarea-tagged";

export const create = b.createComponent<IData>({
    id: "bobwai--chat-root-comment",
    render(ctx: IContext, me: b.IBobrilNode) {
        let ri = !!ctx.data.icon;
        let validations = ctx.data.validations;
        me.children = b.styledDiv(
            b.withKey(
                [
                    !ctx.data.headerOff && b.styledDiv(ctx.data.label, s.chatLabelStyle),
                    ctx.data.avatarOff
                        ? b.styledDiv(
                              b.withKey(
                                  [
                                      b.styledDiv(null, s.commentIconStyle, b.sprite(Icon.comment_small_png, color.Grey500)),
                                      b.styledDiv(ctx.data.newCommentLabel, s.newCommentLabelStyle)
                                  ],
                                  "avatar_off"
                              ),
                              s.newCommentHeaderStyle
                          )
                        : b.styledDiv(
                              ri ? ctx.data.icon : "",
                              s.editboxIconStyle,
                              !ri && b.sprite(Icon.user_medium_png, color.White, 30, 30)
                          ),
                    b.styledDiv(
                        b.withKey(
                            keyboard.create({
                                children:
                                    validations && validations.validationsCursor !== undefined
                                        ? ctx.data.userList && ctx.data.userList.length > 0
                                            ? validationHelper.validationComponent<TextareaTagged.IData, string, {}>({
                                                  builder: TextareaTagged.create,
                                                  componentData: <TextareaTagged.IData>b.assign(
                                                      createComponentDataForValidationHelper(ctx, validations),
                                                      {
                                                          userList: ctx.data.userList
                                                      }
                                                  ),
                                                  validationsCursor: ctx.data.isActive ? validations.validationsCursor : undefined,
                                                  propertyName: validations.propertyName,
                                                  localizeErrorMessage: validations.localizeErrorMessage,
                                                  validationTypeEnum: validations.validationTypeEnum
                                              })
                                            : validationHelper.validationComponent<Textarea.IData, string, {}>({
                                                  builder: Textarea.create,
                                                  componentData: <Textarea.IData>createComponentDataForValidationHelper(ctx, validations),
                                                  validationsCursor: ctx.data.isActive ? validations.validationsCursor : undefined,
                                                  propertyName: validations.propertyName,
                                                  localizeErrorMessage: validations.localizeErrorMessage,
                                                  validationTypeEnum: validations.validationTypeEnum
                                              })
                                        : ctx.data.userList && ctx.data.userList.length > 0
                                        ? TextareaTagged.create(b.assign(createTextareaData(ctx), { userList: ctx.data.userList }))
                                        : Textarea.create(createTextareaData(ctx)),
                                onEnterPress: () => {
                                    if (!ctx.data.inputValue || !ctx.data.inputValue.trim() || isInvalid(ctx.data)) return false;
                                    ctx.data.onSubmit();
                                    return true;
                                },
                                onEscPress: () => {
                                    ctx.data.onValueChanged("");
                                    return true;
                                }
                            }),
                            "textbox"
                        ),
                        ctx.data.avatarOff ? rs.textboxWithoutAvatarStyle : rs.textboxStyle
                    ),
                    ctx.data.submitControlPanel && b.styledDiv(ctx.data.submitControlPanel, cps.leftRootControlPanelStyle),
                    b.styledDiv(
                        b.withKey(
                            button.create({
                                onClick: ctx.data.onSubmit,
                                label: ctx.data.submitLabel,
                                size: button.Size.Small,
                                color: button.Theme.None,
                                isDisabled: !ctx.data.isActive || !ctx.data.inputValue || !ctx.data.inputValue.trim() || isInvalid(ctx.data)
                            }),
                            "button"
                        ),
                        cps.rightRootControlPanelStyle
                    )
                ],
                "root_comment"
            ),
            s.editboxWrapperStyle
        );
    }
});

interface IContext extends b.IBobrilCtx {
    data: IData;
}

function createComponentDataForValidationHelper(ctx: IContext, validations: IValidations | undefined): Textarea.IData {
    return {
        value: ctx.data.inputValue,
        onChange: ctx.data.onValueChanged,
        onFocusIn: () => {
            ctx.data.onActive();
            validations && validationHelper.removeValidationError(validations.validationsCursor, validations.propertyName);
        },
        rows: s.textAreaRowsCount,
        webContentAccessibility: ctx.data.webContentAccessibility && {
            ariaLabel: ctx.data.webContentAccessibility.addCommentAriaLabel
        }
    };
}

function createTextareaData(ctx: IContext): Textarea.IData | undefined {
    return {
        value: ctx.data.inputValue,
        placeholder: ctx.data.placeholderText,
        onChange: ctx.data.onValueChanged,
        onFocusIn: () => ctx.data.onActive(),
        rows: s.textAreaRowsCount,
        initState: ctx.data.rootFocused ? Textarea.InitState.focused : undefined,
        maxLength: ctx.data.maxLengthInput,
        webContentAccessibility: ctx.data.webContentAccessibility && {
            ariaLabel: ctx.data.webContentAccessibility.addCommentAriaLabel
        }
    };
}

function isInvalid(data: IData) {
    return data.validations && data.validations.validationsCursor && validationHelper.isInvalid(data.validations.validationsCursor);
}

export interface IData {
    headerOff?: boolean;
    isActive: boolean;
    submitLabel: string;
    webContentAccessibility?: IChatWebContentAccessibility;
    newCommentLabel?: string;
    inputValue: string;
    icon: b.IBobrilNode;
    onSubmit: () => void;
    onActive: () => void;
    onValueChanged: (value: string) => void;
    submitControlPanel?: b.IBobrilNode;
    label: string;
    validations?: IValidations;
    avatarOff?: boolean;
    rootFocused?: boolean;
    maxLengthInput?: number;
    userList?: User[];
    placeholderText?: string;
}

export interface IValidations {
    propertyName: string;
    localizeErrorMessage: (errorInfo: any) => string;
    validationTypeEnum: validationHelper.IValidationTypeEnum;
    validationsCursor: flux.ICursor<validationHelper.IValidationsState>;
}
