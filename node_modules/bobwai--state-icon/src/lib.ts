import * as b from "bobril";
import * as Mixins from "bobwai--style-mixins";
import * as Focus from "bobwai--focus";
import * as Tooltip from "bobwai--tooltip-emplacer";
import * as FormElements from "bobwai--form-elements";
import * as constants from "./publicConstants";
export { Placement } from "bobwai--tooltip-emplacer";
export { Selectors } from "./testSelectors";

export let create = b.createVirtualComponent<IData>({
    id: "bobwai--state-icon",
    render(ctx: IContext, me: b.IBobrilNode): void {
        me.children = ctx.data.tooltip
            ? Tooltip.create({
                  content: getFocusableStateIcon(ctx),
                  tooltipHeader: ctx.data.tooltip.tooltipHeader,
                  tooltipMessage: ctx.data.tooltip.tooltipMessage,
                  validationState: ctx.data.validationState,
                  preferedPlacement: ctx.data.tooltipPreferedPlacement,
                  secondaryPreferedPlacement: ctx.data.tooltipSecondaryPreferedPlacement,
                  hideOnClick: ctx.data.isTooltipHiddenOnClick
              })
            : getFocusableStateIcon(ctx);
    },
    onClick(ctx: IContext, event: b.IBobrilMouseEvent): boolean {
        return onClick(ctx, event);
    }
});

export interface IData {
    content: b.IBobrilNode;
    hoverContent: b.IBobrilNode;
    shadowContent?: b.IBobrilNode;
    disableContent?: b.IBobrilNode;
    onClick?: (event?: b.IBobrilMouseEvent) => void;
    isDisabled?: boolean;
    isFocusable?: boolean;
    validationState?: FormElements.ValidationState;
    tooltip?: FormElements.ITooltipData;
    /** this could be used in special cases when you need to have clickable/hoverable area larger than icon itself - for example in bobwai--icon-input */
    customActiveArea?: ICustomActiveArea;
    webContentAccessibility?: WebContentAccessibility;
    tooltipPreferedPlacement?: Tooltip.Placement;
    isTooltipHiddenOnClick?: boolean;
    tooltipSecondaryPreferedPlacement?: Tooltip.Placement;
}

/** role button is automatically added if there is onClick - for rare case you can add role manually
 *  it makes sense mainly in case that clickable icon is used e.g. in action-with-window automatic mode
 */
export type WebContentAccessibility = Pick<Focus.IWebContentAccessibility, "ariaLabel" | "role" | "popup">;

export interface ICustomActiveArea {
    offsetLeft?: number;
    offsetRight?: number;
    offsetTop?: number;
    offsetBottom?: number;
}

export * from "./publicConstants";

interface IContext extends b.IBobrilCtx {
    data: IData;
    isHover: boolean;
    isDrag: boolean;
}

function getFocusableStateIcon(ctx: IContext): b.IBobrilNode {
    return ctx.data.isFocusable === false
        ? getStateIcon(ctx)
        : Focus.create({
              content: getStateIcon(ctx),
              onFocusCommand: () => {
                  onClick(ctx);
              },
              isDisabled: ctx.data.isDisabled,
              offsetBottom: 0,
              offsetTop: 0,
              offsetLeft: 0,
              offsetRight: 0,
              verticalAlign: Focus.VerticalAlign.Middle,
              webContentAccessibility: b.assign(
                  <Focus.IWebContentAccessibility>{
                      tooltip: ctx.data.tooltip,
                      isDisabled: ctx.data.isDisabled,
                      role: ctx.data.onClick ? Focus.ContentAccessibilityRole.Button : undefined
                  },
                  ctx.data.webContentAccessibility
              )
          });
}

function getStateIcon(ctx: IContext): b.IBobrilNode {
    return b.createComponent({
        id: "bobwai--state-icon-clickable-element",
        render(_c: b.IBobrilCtx, me: b.IBobrilNode): void {
            me.children = [
                ctx.data.shadowContent && b.styledDiv(ctx.data.shadowContent, stateIconShadowStyle),
                !ctx.data.isDisabled &&
                    (ctx.isHover
                        ? b.styledDiv(ctx.data.hoverContent, stateIconInnerStyle)
                        : b.styledDiv(ctx.data.content, stateIconInnerStyle)),
                ctx.data.isDisabled &&
                    (ctx.data.disableContent
                        ? b.styledDiv(ctx.data.disableContent, stateIconInnerStyle)
                        : b.styledDiv(ctx.data.content, stateIconInnerStyle)),
                ctx.data.customActiveArea && createCustomActiveArea(ctx.data.customActiveArea)
            ];
            b.style(me, [
                stateIconStyle,
                !ctx.isDrag && clickableStyle,
                !ctx.isDrag && ctx.data.isDisabled && disabledStyle,
                ctx.data.isDisabled && !ctx.data.disableContent && stateIconDisabledWithoutContentStyle
            ]);
        },

        onMouseLeave(_c: b.IBobrilCtx): boolean {
            ctx.isHover = false;
            b.invalidate(ctx);
            return true;
        },
        onMouseEnter(_c: b.IBobrilCtx): boolean {
            if (!ctx.data.isDisabled) {
                ctx.isHover = true;
                b.invalidate(ctx);
            }
            return true;
        },
        onDrag(_c: IContext): boolean {
            if (ctx.isDrag) return false;
            ctx.isDrag = true;
            b.invalidate(ctx);
            return false;
        },
        onDragEnd(_c: IContext): boolean {
            ctx.isDrag = false;
            b.invalidate(ctx);
            return false;
        }
    })();
}

function onClick(ctx: IContext, event?: b.IBobrilMouseEvent): boolean {
    if (!ctx.data.isDisabled && ctx.data.onClick) {
        ctx.data.onClick(event);
        return true;
    }
    return false;
}

function createCustomActiveArea(customActiveArea: ICustomActiveArea): b.IBobrilNode {
    return b.styledDiv("", customActiveAreaStyle, {
        left: -(customActiveArea.offsetLeft || 0),
        right: -(customActiveArea.offsetRight || 0),
        top: -(customActiveArea.offsetTop || 0),
        bottom: -(customActiveArea.offsetBottom || 0)
    });
}

const stateIconStyle = b.styleDef(
    [
        {
            display: "inline-block",
            position: "relative",
            verticalAlign: "middle"
        }
    ],
    {},
    "state-icon"
);

const clickableStyle = b.styleDef(Mixins.getClickableElement(), {}, "state-icon-clickable");

const stateIconShadowStyle = b.styleDef(
    [
        {
            position: "absolute",
            top: constants.StateIconOffsetTop,
            left: constants.StateIconOffsetLeft,
            opacity: 0.75
        }
    ],
    {},
    "state-icon-shadow"
);

const stateIconInnerStyle = b.styleDef(
    [
        {
            position: "relative",
            fontSize: 0
        }
    ],
    {},
    "state-icon-content"
);

const disabledStyle = b.styleDef(Mixins.getClickableElementDisabled(), {}, "state-icon-disable");

const stateIconDisabledWithoutContentStyle = b.styleDefEx(stateIconStyle, { opacity: 0.3 }, {}, "state-icon-disable-without-content");

const customActiveAreaStyle = b.styleDef({
    position: "absolute",
    cursor: "pointer"
});

// added by script - BEGIN
export const StateIcon = create;
// added by script - END
