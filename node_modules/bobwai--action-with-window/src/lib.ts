import * as b from "bobril";
import * as overlay from "bobwai--overlay";
import * as FormElements from "bobwai--form-elements";
import * as KeyboardEvents from "bobwai--keyboard-events";
import * as Window from "./window";
import * as AnimationFrame from "bobwai--animation-frame";
import * as FocusLocker from "bobwai--focus-locker";
import * as Animation from "bobwai--animation";
import { KeyCode } from "helpers--key-codes";
import * as s from "./styles";
import { minMarginLeftRight } from "./styles";
import {
    IWebContentAccessibility,
    setWebContentAccessibilityAttributes,
    ContentAccessibilityRole,
} from "helpers--web-content-accessibility";

export { KeyCode } from "helpers--key-codes";

export const create = b.createComponent<IData>({
    id: "bobwai--action-with-window",
    init(ctx: IContext): void {
        if (ctx.data.isWindowVisible) {
            ctx.shouldBeExternallyOpenedOnFirstRender = true;
        }
        setDefaultWindowPosition(ctx);
        ctx.isWindowVisible = false;
        ctx.windowPosition = undefined;
        ctx.fixedWindowLeftPosition = undefined;

        if (ctx.data.fixPosition) {
            ctx.deviceOrientation = b.getMedia().orientation;
        }

        const onScroll = () => {
            if (ctx.isWindowVisible) {
                if (ctx.data.isVirtual) {
                    closeWindow(ctx);
                } else {
                    const elem = <Element>ctx.me.element;
                    const rectangle = elem.getBoundingClientRect();
                    if (
                        ctx.lastActionElementRect &&
                        (ctx.lastActionElementRect.left !== rectangle.left || ctx.lastActionElementRect.top !== rectangle.top)
                    ) {
                        ctx.data.keepOpenOnScroll ? updatePosition(ctx) : closeWindow(ctx);
                    }
                }
            }
        };
        b.addOnScroll(onScroll);
        b.addDisposable(ctx, () => b.removeOnScroll(onScroll));
    },

    render(ctx: IContext, me: b.IBobrilNode): void {
        if (ctx.data.isVirtual) {
            me.tag = undefined;
        }

        setDefaultWindowPosition(ctx);
        ctx.windowPosition = undefined;

        const isActionContentIRect = isIRect(ctx.data.actionContent);
        if (!isIRelatedHTMLElement(ctx.data.actionContent) && !isActionContentIRect) {
            me.children = ctx.data.actionContent;
        }

        if (ctx.overlayID && ctx.isWindowVisible) {
            b.updateRoot(ctx.overlayID);
        }

        if (isActionContentIRect) {
            b.style(me, s.actionWithWindowRectangleTypeStyle);
        } else if (!ctx.data.isVirtual) {
            b.style(
                me,
                s.actionWithWindowStyle,
                !ctx.isDrag && s.clickableStyle,
                !ctx.isDrag && ctx.data.hasActionDefaultCursor && s.actionDefaultCursorStyle,
                ctx.data.isZeroFontSize && s.actionWithWindowZeroFontSizeStyle,
                ctx.data.displayActionContentAs === FormElements.DisplayAs.Block && s.actionWithWindowBlockStyle,
                ctx.data.actionContentVerticalAlign === FormElements.VerticalAlign.Middle && s.actionWithWindowMiddleStyle,
                ctx.data.actionContentHasFullMaxWidth && s.actionContentMaxWidthStyle
            );
        }

        if (ctx.data.isWindowVisible !== undefined && ctx.isWindowVisible !== ctx.data.isWindowVisible) {
            if (ctx.data.isWindowVisible) {
                openWindow(ctx);
            } else {
                if (ctx.data.hasAnimation) {
                    closeWindow(ctx, undefined, true);
                    return;
                }
                closeWindowFinally(ctx);
            }
        }

        updatePosition(ctx);
    },

    onClick(ctx: IContext): boolean {
        triggerOpenWindow(ctx);
        return !ctx.data.enableOnClickBubble;
    },

    onMouseEnter(ctx: IContext) {
        if (ctx.data.activationType === ActivationType.Hover) {
            triggerOpenWindow(ctx);
        }
    },

    onMouseLeave(ctx: IContext) {
        if (ctx.data.activationType === ActivationType.Hover && ctx.isWindowVisible) {
            closeWindow(ctx);
        }
    },

    onDrag(ctx: IContext) {
        if (ctx.isDrag) {
            return false;
        }
        ctx.isDrag = true;
        b.invalidate(ctx);
        return false;
    },

    onDragEnd(ctx: IContext) {
        ctx.isDrag = false;
        b.invalidate(ctx);
        return false;
    },
    destroy(ctx: IContext) {
        closeWindowFinally(ctx, { destroy: true });
    },
    onKeyDown(ctx: IContext, event: b.IKeyDownUpEvent): boolean {
        const defaultKey = KeyCode.Enter;
        const isKeySupported = isSupportedKeyCode(
            (ctx.data.keyboardSettings && ctx.data.keyboardSettings.openWindowCommandKeyCodes) || [defaultKey],
            event.which
        );
        if (!ctx.isWindowVisible && isKeySupported) {
            triggerOpenWindow(ctx);
            return true;
        }
        return false;
    },
});

export interface IData {
    /** In case of IRelatedHTMLElement or IRect, no actionContent is rendered. It serves only for getting the window position */
    actionContent: b.IBobrilChildren | IRelatedHTMLElement | IRect;
    windowContent: b.IBobrilChildren;
    fixPosition?: boolean;
    isWindowVisible?: boolean;
    keyboardSettings?: {
        closeWindowOnEsc?: boolean;
        /** Enter by default */
        openWindowCommandKeyCodes?: KeyCode[];
        /** After last element lost focus, first focusable element is focused */
        useFocusLocker?: boolean | IFocusLockerAdditionalSettings;
        focusActionAfterWindowClosed?: boolean;
    };
    onOpenWindow?: () => void;
    /**
     * animationFinished is true when hasAnimation is set and animation was finished
     */
    onCloseWindow?: (animationFinished?: boolean) => void;
    positioningMode?: PositioningMode;
    preferredPlacement?: Placement;
    secondaryPreferredPlacement?: Placement;
    isResizeEnabled?: boolean;
    isScrollbarEnabled?: boolean;
    maxWindowHeight?: number;
    hasShadow?: boolean;
    hasBorder?: boolean;
    /**
     * Width of the window according will be at least as action content width
     */
    isFitWidth?: boolean;

    /** It will set min-width of the window according to the action content width
     * It it suitable for window inline content which will not be wrapped into more lines (e.g. tree-list-items)
     */
    isFitMinWidth?: boolean;

    hasArrow?: boolean;
    onUpdateSide?: (isTop: boolean, toggleWindow?: HTMLElement) => void;
    isOverflowVisible?: boolean;
    displayActionContentAs?: FormElements.DisplayAs;
    keepOpenOnScroll?: boolean;
    verticalOffset?: number;
    horizontalOffset?: number;
    actionContentVerticalAlign?: FormElements.VerticalAlign;
    enableOnClickBubble?: boolean;
    isVirtual?: boolean;
    isZeroFontSize?: boolean;
    arrowType?: ArrowType;
    activationType?: ActivationType;
    /**
     * removes pointer cursor, suitable for android mobile devices - also removes outline when click
     */
    hasActionDefaultCursor?: boolean;
    /**
     * onCloseWindow is called twice and has parameter animationFinished
     */
    hasAnimation?: boolean;
    /**
     * take effect only in combination with displayActionContentAs is set to default (inline-block)
     * it sets maxWidth of content to 100%
     */
    actionContentHasFullMaxWidth?: boolean;
    /**
     * toggleWindow width can be changed
     * set this attribute to protect overflow out of window
     */
    customToggleWindowWidth?: number;
    visibilityHidden?: boolean;
    /**
     * Supress default behavior with returning true on onClick action.
     */
    enableOnClick?: boolean;
    /**
     * Use ariaLabel for name of the dialog
     */
    windowContentWebAccessibility?: WebContentAccessibility;
    /**
     * Define parent which should be used to render item. Use only if you know what you are doing. It is used in Interactive's loginWindow.
     */
    rootParent?: HTMLElement;
}

export interface IRelatedHTMLElement {
    relatedHTMLElement: HTMLElement;
}

export interface IFocusLockerAdditionalSettings {
    /**
     * @value true - default, first focusable element get automatically focus on init
     * @value false - There is no default focus
     */
    focusContentOnInit: boolean;
}

export type WebContentAccessibility = Required<Pick<IWebContentAccessibility, "ariaLabel">>;

export * from "./publicConstants";

export enum PositioningMode {
    TopBottom,
    All,
}

export enum Placement {
    BottomCenter,
    TopCenter,
    BottomRight,
    TopRight,
    BottomLeft,
    TopLeft,
    Right,
    Left,
}

export enum ArrowType {
    Default,
    ContentWithoutHeader,
}

export enum ActivationType {
    Default,
    Hover,
}

export interface IRect {
    left: number;
    top: number;
    width: number;
    height: number;
}

interface IUpdatedPosition {
    top: number;
    left: number;
    placement: Placement;
    isExpandToUpperSide: boolean;
    maxHeight?: number;
}

interface IPossiblePositionData {
    windowRect: IRect;
    actionElementRect: IRect;
    requestedPlacement: Placement;
    hasArrow?: boolean;
    hasBorder?: boolean;
    verticalOffset: number;
    horizontalOffset: number;
    isFixedPreferredPlacement?: boolean;
    windowPositioningMode?: PositioningMode;
    scrollbarWidth: number;
    maxWindowHeight: number;
    isResizeEnabled?: boolean;
    customToggleWindowWidth?: number;
}

interface IContext extends b.IBobrilCtx {
    data: IData;
    isWindowVisible: boolean;
    overlayID: string;
    lastActionElementRect: IRect;
    lastWindowRect: IRect;
    windowPositioningMode: PositioningMode;
    windowPreferredPlacement: Placement;
    windowPosition?: IUpdatedPosition;
    fixedWindowLeftPosition?: number;
    currentWindowPreferredPlacement?: Placement;
    overlayHasOverflow?: boolean;
    deviceOrientation?: number;
    isClosingAnimationInProcess?: boolean;
    isDrag: boolean;
    /** if isWindowVisible: true is set on first render,
     * it needs one more invalidate to calculate the right position of the window
     */
    shouldBeExternallyOpenedOnFirstRender?: boolean;
}

function isIRelatedHTMLElement(o: any): o is IRelatedHTMLElement {
    return (<IRelatedHTMLElement>o).relatedHTMLElement !== undefined;
}

function setPossiblePosition(ctx: IContext, actionElementRect: IRect, windowRect: IRect, scrollbarWidth: number) {
    const possiblePlaces = getPlacementAsArray();

    let currentIndex = possiblePlaces.indexOf(ctx.windowPreferredPlacement);
    let isCheckedPreferredPlacement = false;

    if (currentIndex > -1) {
        let placesTried = 0;
        while (placesTried < possiblePlaces.length) {
            // if preferred placement was already checked then skip checking this placement
            if (isCheckedPreferredPlacement && ctx.data.preferredPlacement === currentIndex) {
                currentIndex++;
                if (currentIndex === possiblePlaces.length) {
                    currentIndex = 0;
                }
            }

            const position = tryToCountPosition({
                windowRect: windowRect,
                actionElementRect: actionElementRect,
                requestedPlacement: possiblePlaces[currentIndex],
                hasArrow: ctx.data.hasArrow,
                hasBorder: ctx.data.hasBorder,
                verticalOffset: getOffset(ctx.data.verticalOffset),
                horizontalOffset: getOffset(ctx.data.horizontalOffset),
                windowPositioningMode: ctx.windowPositioningMode,
                scrollbarWidth: scrollbarWidth,
                maxWindowHeight: ctx.data.maxWindowHeight || Number.MAX_VALUE,
                isResizeEnabled: ctx.data.isResizeEnabled,
                customToggleWindowWidth: ctx.data.customToggleWindowWidth,
            });

            if (position && position.left && position.top && position.placement !== undefined) {
                ctx.currentWindowPreferredPlacement = position.placement;
                ctx.windowPosition = position;
                break;
            } else {
                // if there is no free space for the first preferred placement then jump
                // directly to the secondary preferred placement (if defined)
                // else continue by increasing the index by one as well as there is no free place for secondary placement
                if (
                    ctx.data.secondaryPreferredPlacement !== undefined &&
                    !isCheckedPreferredPlacement &&
                    ctx.data.preferredPlacement === currentIndex
                ) {
                    currentIndex = ctx.data.secondaryPreferredPlacement;
                    isCheckedPreferredPlacement = true;
                } else {
                    currentIndex++;
                }

                placesTried++;

                if (currentIndex === possiblePlaces.length) {
                    currentIndex = 0;
                }
            }
        }
    }
}

function setFixedPosition(
    ctx: IContext,
    actionElementRect: IRect,
    windowRect: IRect,
    scrollbarWidth: number
): IUpdatedPosition | undefined {
    // If no preferred placements are not suitable, we will force get position following default windowPreferredPlacement
    const fixedPosition = tryToCountPosition({
        windowRect: windowRect,
        actionElementRect: actionElementRect,
        requestedPlacement: ctx.windowPreferredPlacement,
        hasArrow: ctx.data.hasArrow,
        hasBorder: ctx.data.hasBorder,
        verticalOffset: getOffset(ctx.data.verticalOffset),
        horizontalOffset: getOffset(ctx.data.horizontalOffset),
        windowPositioningMode: ctx.windowPositioningMode,
        isFixedPreferredPlacement: true,
        scrollbarWidth: scrollbarWidth,
        maxWindowHeight: ctx.data.maxWindowHeight || Number.MAX_VALUE,
        isResizeEnabled: ctx.data.isResizeEnabled,
        customToggleWindowWidth: ctx.data.customToggleWindowWidth,
    });

    // if no position was found, preferred position is set above and overflow on overlay is enabled
    if (!ctx.overlayHasOverflow) {
        ctx.overlayHasOverflow = true;
        b.invalidate(ctx);
    }

    if (fixedPosition) {
        // if there is more space above
        if (actionElementRect.top > getAvailableBottomSpace(actionElementRect)) {
            fixedPosition.top = actionElementRect.top - windowRect.height;
        }
        ctx.currentWindowPreferredPlacement = fixedPosition.placement;
        return fixedPosition;
    }

    return undefined;
}

function isSupportedKeyCode(keyCodes: KeyCode[], keyCode: number): boolean {
    return !!(keyCodes.indexOf(keyCode) > -1);
}

function getAvailableBottomSpace(actionElementRect: IRect): number {
    return window.innerHeight - (actionElementRect.top + actionElementRect.height);
}

function deviceOrientationWasChanged(ctx: IContext): boolean {
    return b.getMedia().orientation !== ctx.deviceOrientation;
}

function updatePosition(ctx: IContext) {
    let isWindowVisible = ctx.isWindowVisible;
    if (ctx.data.isWindowVisible !== undefined) {
        isWindowVisible = ctx.data.isWindowVisible;
    }

    if (isWindowVisible) {
        let toggleWindow;
        if (ctx.refs && ctx.refs["windowContent"]) {
            toggleWindow = <HTMLElement>b.getDomNode(<b.IBobrilCacheNode>ctx.refs["windowContent"]);
            // need to reset maxHeight for fixing resize error
            toggleWindow.style.maxHeight = "";
        }

        let actionElementRect;
        if (isIRect(ctx.data.actionContent)) {
            actionElementRect = ctx.data.actionContent;
        } else {
            const actionElement: HTMLElement = isIRelatedHTMLElement(ctx.data.actionContent)
                ? ctx.data.actionContent.relatedHTMLElement
                : <HTMLElement>b.getDomNode(ctx.me);

            if (!actionElement) {
                return;
            }

            const actionElementClientRect = actionElement.getBoundingClientRect();
            actionElementRect = getRect(actionElementClientRect);
        }

        if (!toggleWindow) {
            return;
        }

        setWidth(ctx, toggleWindow, actionElementRect);

        const windowClientRect = toggleWindow.getBoundingClientRect();
        const windowRect = getRect(windowClientRect);
        const scrollbarWidth = toggleWindow.offsetWidth - toggleWindow.clientWidth - (ctx.data.hasBorder ? 2 * s.borderSize : 0);

        if (isIRect(ctx.data.actionContent)) {
            const el = <HTMLElement>ctx.me.element;
            if (el) {
                const realActionElementClientRect = el.getBoundingClientRect();
                ctx.lastActionElementRect = getRect(realActionElementClientRect);
            }
        } else {
            ctx.lastActionElementRect = actionElementRect;
        }
        ctx.lastWindowRect = windowRect;

        let newTop = 0;
        let newLeft = 0;
        let isExpandToUpperSide = false;
        let maxHeight = undefined;

        setPossiblePosition(ctx, actionElementRect, windowRect, scrollbarWidth);

        if (!ctx.windowPosition) {
            const fixedPosition = setFixedPosition(ctx, actionElementRect, windowRect, scrollbarWidth);
            if (fixedPosition) {
                newTop = fixedPosition.top;
                newLeft = fixedPosition.left;
                isExpandToUpperSide = fixedPosition.isExpandToUpperSide;
                maxHeight = fixedPosition.maxHeight;
            }
        } else {
            newTop = ctx.windowPosition.top;
            newLeft = ctx.windowPosition.left;
            isExpandToUpperSide = ctx.windowPosition.isExpandToUpperSide;
            maxHeight = ctx.windowPosition.maxHeight;
        }

        if (ctx.data.fixPosition) {
            if (!ctx.fixedWindowLeftPosition || deviceOrientationWasChanged(ctx)) {
                ctx.fixedWindowLeftPosition = newLeft;
                ctx.deviceOrientation = b.getMedia().orientation;
            } else {
                newLeft = ctx.fixedWindowLeftPosition;
            }
        }

        const toggleWindowWidth = toggleWindow.offsetWidth;
        const actionElementRectWidth = actionElementRect.width;
        const actionElementRectLeft = actionElementRect.left;

        if (ctx.data.isFitWidth && actionElementRectWidth >= toggleWindowWidth) {
            toggleWindow.style.left = `${actionElementRectLeft}px`;
            toggleWindow.style.width = `${actionElementRectWidth}px`;
        } else {
            toggleWindow.style.left = `${newLeft}px`;
        }

        if (ctx.data.isFitMinWidth) {
            if (toggleWindow.style.minWidth !== `${actionElementRectWidth}px`) {
                toggleWindow.style.minWidth = `${actionElementRectWidth}px`;
            }
        }

        if (ctx.data.isResizeEnabled) {
            toggleWindow.style.maxHeight = `${maxHeight}px`;
        }

        toggleWindow.style.top = `${newTop}px`;

        if (isExpandToUpperSide && ctx.data.hasShadow) {
            toggleWindow.style.boxShadow = s.upperSideShadow;
        } else {
            toggleWindow.style.boxShadow = "";
        }

        ctx.data.onUpdateSide && ctx.data.onUpdateSide(isExpandToUpperSide, toggleWindow);
    }
}

function setWidth(ctx: IContext, toggleWindow: HTMLElement, actionElementRect: IRect) {
    let width;
    if (!ctx.data.customToggleWindowWidth || !document.documentElement) {
        return;
    }

    width = Math.min(ctx.data.customToggleWindowWidth, document.documentElement.clientWidth);

    if (width + 2 * minMarginLeftRight > document.documentElement.clientWidth) {
        width = width - 2 * minMarginLeftRight;
    }
    width = Math.max(width, actionElementRect.width);
    toggleWindow.style.width = `${width}px`;
}

function tryToCountPosition(data: IPossiblePositionData): IUpdatedPosition | undefined {
    if (!document.documentElement) {
        return;
    }

    const windowArrowSize = data.hasArrow ? s.arrowSize : 0;
    const windowBorderSize = data.hasBorder ? s.borderSize : 0;

    const isFixedPreferredPlacement = data.isFixedPreferredPlacement;

    const isTopBottomMode = data.windowPositioningMode === PositioningMode.TopBottom;

    const windowOffset = data.verticalOffset;
    const windowHorizontalOffset = data.horizontalOffset;

    const windowHeight = data.windowRect.height;
    let maxHeight = data.maxWindowHeight;

    const windowWidth = data.windowRect.width + data.scrollbarWidth;

    const availableLeftSpace = data.actionElementRect.left;
    const availableRightSpace = document.documentElement.clientWidth - (data.actionElementRect.left + data.actionElementRect.width);

    const availableTopSpace = data.actionElementRect.top;
    const availableBottomSpace = getAvailableBottomSpace(data.actionElementRect);

    const windowHorizontalCenterPoint = data.actionElementRect.left + data.actionElementRect.width / 2;
    const windowVerticalCenterPoint = data.actionElementRect.top + data.actionElementRect.height / 2;
    const windowHalfWidthSize = windowWidth / 2;
    const windowHalfHeightSize = windowHeight / 2 - windowBorderSize;

    const isPlacementTopAvailable = availableTopSpace - windowHeight - windowOffset > 0;
    const isPlacementBottomAvailable = availableBottomSpace - windowHeight - windowOffset > 0;

    const isPlacementCenterAvailable =
        windowHorizontalCenterPoint + windowHalfWidthSize < document.documentElement.clientWidth &&
        windowHorizontalCenterPoint - windowHalfWidthSize > 0;

    let isPlacementOffsetLeftAvailable =
        windowHorizontalCenterPoint - windowWidth + windowArrowSize + windowBorderSize - windowHorizontalOffset > 0;
    if (!isPlacementOffsetLeftAvailable && data.customToggleWindowWidth) {
        isPlacementOffsetLeftAvailable = data.customToggleWindowWidth > document.documentElement.clientWidth - data.actionElementRect.left;
    }

    const isPlacementOffsetRightAvailable =
        windowHorizontalCenterPoint + windowWidth - windowArrowSize - windowBorderSize - windowHorizontalOffset <
        document.documentElement.clientWidth;

    const isPlacementVerticalCentered =
        windowVerticalCenterPoint - windowHalfHeightSize > 0 && windowVerticalCenterPoint + windowHalfHeightSize < window.innerHeight;

    const isPlacementLeftCenterAvailable = availableLeftSpace - windowWidth > 0 && isPlacementVerticalCentered;
    const isPlacementRightCenterAvailable = availableRightSpace - windowWidth > 0 && isPlacementVerticalCentered;

    const isPlacementTopLeftAvailable = isPlacementTopAvailable && isPlacementOffsetLeftAvailable;
    const isPlacementTopRightAvailable = isPlacementTopAvailable && isPlacementOffsetRightAvailable;
    const isPlacementTopCenterAvailable = isPlacementTopAvailable && isPlacementCenterAvailable;

    const isPlacementBottomLeftAvailable = isPlacementBottomAvailable && isPlacementOffsetLeftAvailable;
    const isPlacementBottomRightAvailable = isPlacementBottomAvailable && isPlacementOffsetRightAvailable;
    const isPlacementBottomCenterAvailable = isPlacementBottomAvailable && isPlacementCenterAvailable;

    let left: number | null = null;
    let top: number | null = null;

    let isExpandToUpperSide = false;
    switch (data.requestedPlacement) {
        case Placement.Left:
            if (!isTopBottomMode && (isPlacementLeftCenterAvailable || isFixedPreferredPlacement)) {
                left = data.actionElementRect.left - windowWidth - windowArrowSize - windowHorizontalOffset;
                top = windowVerticalCenterPoint - windowHalfHeightSize - windowBorderSize;
            }
            break;

        case Placement.Right:
            if (!isTopBottomMode && (isPlacementRightCenterAvailable || isFixedPreferredPlacement)) {
                left = data.actionElementRect.left + data.actionElementRect.width + windowArrowSize + windowHorizontalOffset;
                top = windowVerticalCenterPoint - windowHalfHeightSize - windowBorderSize;
            }
            break;

        case Placement.TopLeft:
            if (isPlacementTopLeftAvailable || isFixedPreferredPlacement) {
                left = data.actionElementRect.left + data.actionElementRect.width - windowWidth + windowHorizontalOffset;
                maxHeight = Math.min(maxHeight, data.actionElementRect.top);
                const resizedWindowHeight = data.isResizeEnabled ? Math.min(maxHeight, windowHeight) : windowHeight;
                top = data.actionElementRect.top - resizedWindowHeight - windowArrowSize - windowOffset;
                isExpandToUpperSide = true;
            }
            break;

        case Placement.TopCenter:
            if (isPlacementTopCenterAvailable || isFixedPreferredPlacement) {
                left = windowHorizontalCenterPoint - windowHalfWidthSize;
                maxHeight = Math.min(maxHeight, data.actionElementRect.top);
                const resizedWindowHeight = data.isResizeEnabled ? Math.min(maxHeight, windowHeight) : windowHeight;
                top = data.actionElementRect.top - resizedWindowHeight - windowArrowSize - windowOffset;
                isExpandToUpperSide = true;
            }
            break;

        case Placement.TopRight:
            if (isPlacementTopRightAvailable || isFixedPreferredPlacement) {
                left = data.actionElementRect.left - windowHorizontalOffset;
                maxHeight = Math.min(maxHeight, data.actionElementRect.top);
                const resizedWindowHeight = data.isResizeEnabled ? Math.min(maxHeight, windowHeight) : windowHeight;
                top = data.actionElementRect.top - resizedWindowHeight - windowArrowSize - windowOffset;
                isExpandToUpperSide = true;
            }
            break;

        case Placement.BottomLeft:
            if (isPlacementBottomLeftAvailable || isFixedPreferredPlacement) {
                left = data.actionElementRect.left + data.actionElementRect.width - windowWidth + windowHorizontalOffset;
                maxHeight = Math.min(maxHeight, window.innerHeight - data.actionElementRect.top - data.actionElementRect.height);
                top = data.actionElementRect.top + data.actionElementRect.height + windowArrowSize + windowOffset;
            }
            break;

        case Placement.BottomCenter:
            if (isPlacementBottomCenterAvailable || isFixedPreferredPlacement) {
                left = windowHorizontalCenterPoint - windowHalfWidthSize;
                maxHeight = Math.min(maxHeight, window.innerHeight - data.actionElementRect.top - data.actionElementRect.height);
                top = data.actionElementRect.top + data.actionElementRect.height + windowArrowSize + windowOffset;
            }
            break;

        case Placement.BottomRight:
            if (isPlacementBottomRightAvailable || isFixedPreferredPlacement) {
                left = data.actionElementRect.left - windowHorizontalOffset;
                maxHeight = Math.min(maxHeight, window.innerHeight - data.actionElementRect.top - data.actionElementRect.height);
                top = data.actionElementRect.top + data.actionElementRect.height + windowArrowSize + windowOffset;
            }
            break;
    }

    if (left !== null && top !== null) {
        if (left < 0) {
            left = minMarginLeftRight;
        }
        if (top < 0) {
            top = minMarginLeftRight;
        }
        return {
            top: Math.round(top),
            left: Math.round(left),
            placement: data.requestedPlacement,
            isExpandToUpperSide: isExpandToUpperSide,
            maxHeight: data.isResizeEnabled ? maxHeight : undefined,
        };
    }

    return undefined;
}

function createOverlayWindow(ctx: IContext, windowContent: b.IBobrilNode): b.IBobrilNode {
    const overlayContent = overlay.create({
        hasOverflow: ctx.data.activationType !== ActivationType.Hover && ctx.overlayHasOverflow,
        content: ctx.isWindowVisible && windowContent,
        onClick: () => closeWindow(ctx),
    });

    const window = KeyboardEvents.create({
        onEscPress: () => {
            if (ctx.data.keyboardSettings && ctx.data.keyboardSettings.closeWindowOnEsc) {
                if (ctx.data.hasAnimation) {
                    closeWindow(ctx, undefined, true);
                } else {
                    closeWindow(ctx);
                }
                return true;
            }
            return false;
        },
        children: Window.create({
            content: ctx.data.activationType === ActivationType.Hover ? b.style(overlayContent, { pointerEvents: "none" }) : overlayContent,
            onPostRendered: () => {
                updatePosition(ctx);
            },
        }),
    });

    if (ctx.data.hasAnimation) {
        return AnimationFrame.create({
            content: window,
            showHideAnimation: Animation.fadeInFadeOutAnimation(),
            isHiding: ctx.isClosingAnimationInProcess,
            onHideAnimationFinished: () => {
                ctx.isClosingAnimationInProcess = false;
                closeWindow(ctx, true);
                b.invalidate(ctx);
            },
        });
    }
    return window;
}

function openWindow(ctx: IContext): void {
    if (ctx.data.hasAnimation && ctx.isClosingAnimationInProcess) {
        ctx.isClosingAnimationInProcess = false;
        b.invalidate(ctx);
        return;
    }
    ctx.isWindowVisible = true;

    if (ctx.overlayID) {
        b.removeRoot(ctx.overlayID);
    }

    ctx.overlayID = b.addRoot((): b.IBobrilNode => {
        const windowContent = b.style(
            {
                tag: "div",
                children: getWindowContent(ctx),
                component: {
                    onClick: () => !ctx.data.enableOnClick,
                    id: "bobwai--action-with-window-content",
                },
            },
            [getWindowStyle(ctx), (ctx.data.visibilityHidden || ctx.shouldBeExternallyOpenedOnFirstRender) && s.visibilityHiddenStyle]
        );
        if (ctx.shouldBeExternallyOpenedOnFirstRender) {
            ctx.shouldBeExternallyOpenedOnFirstRender = undefined;
            b.invalidate(ctx);
        }
        windowContent.ref = [ctx, "windowContent"];

        let webContentAccessibility: IWebContentAccessibility = {
            role: ContentAccessibilityRole.Dialog,
            isModal: true,
        };

        if (ctx.data.windowContentWebAccessibility) {
            webContentAccessibility = b.assign(webContentAccessibility, ctx.data.windowContentWebAccessibility);
        }

        setWebContentAccessibilityAttributes(windowContent, webContentAccessibility);

        return createOverlayWindow(ctx, windowContent);
    }, ctx.data.rootParent);
}

function getWindowContent(ctx: IContext): b.IBobrilChildren {
    if (ctx.data.keyboardSettings && ctx.data.keyboardSettings.useFocusLocker) {
        let focusContentOnInit = true;
        if (isFocusLockerSettings(ctx.data.keyboardSettings.useFocusLocker)) {
            focusContentOnInit = ctx.data.keyboardSettings.useFocusLocker.focusContentOnInit;
        }
        return FocusLocker.create({
            focusContentOnInit: focusContentOnInit,
            children: ctx.data.windowContent,
        });
    }
    return ctx.data.windowContent;
}
function closeWindow(ctx: IContext, animationFinished?: boolean, startClosingAnimation?: boolean): void {
    let waitingForCloseWindow = false;
    // manual mode
    if (ctx.data.isWindowVisible !== undefined && ctx.data.onCloseWindow && !startClosingAnimation) {
        if (ctx.data.hasAnimation) {
            ctx.data.onCloseWindow(animationFinished);
            waitingForCloseWindow = true;
            if (animationFinished) {
                closeWindowFinally(ctx);
            }
        } else {
            ctx.data.onCloseWindow(animationFinished);
        }
    }

    if (ctx.data.hasAnimation && !animationFinished && !waitingForCloseWindow) {
        ctx.isClosingAnimationInProcess = true;
        b.invalidate(ctx);
    }

    // auto mode
    if (ctx.data.isWindowVisible === undefined) {
        if (!ctx.data.hasAnimation || !ctx.isClosingAnimationInProcess) {
            closeWindowFinally(ctx);
        }
    }
}

function isFocusLockerSettings(o: boolean | IFocusLockerAdditionalSettings): o is IFocusLockerAdditionalSettings {
    if ((<IFocusLockerAdditionalSettings>o).focusContentOnInit !== undefined) {
        return true;
    }
    return false;
}

function closeWindowFinally(ctx: IContext, params?: { destroy: boolean }): void {
    b.removeRoot(ctx.overlayID);
    ctx.isWindowVisible = false;
    ctx.overlayHasOverflow = undefined;
    ctx.isClosingAnimationInProcess = undefined;

    if (!params && ctx.data.keyboardSettings && ctx.data.keyboardSettings.focusActionAfterWindowClosed) {
        b.focus(ctx.me);
    }

    b.invalidate(ctx);
}

function setDefaultWindowPosition(ctx: IContext): void {
    ctx.windowPositioningMode = ctx.data.positioningMode !== undefined ? ctx.data.positioningMode : PositioningMode.TopBottom;
    ctx.windowPreferredPlacement;
    if (ctx.data.preferredPlacement !== undefined) {
        ctx.windowPreferredPlacement = ctx.data.preferredPlacement;
    } else if (ctx.data.secondaryPreferredPlacement !== undefined) {
        ctx.windowPreferredPlacement = ctx.data.secondaryPreferredPlacement;
    } else {
        ctx.windowPreferredPlacement = Placement.BottomCenter;
    }
}

function getPlacementAsArray(): number[] {
    return Object.keys(Placement)
        .map((v) => parseInt(v, 10))
        .filter((v) => !isNaN(v));
}

function getRect(rectangle: ClientRect): IRect {
    return (
        rectangle && {
            top: rectangle.top,
            left: rectangle.left,
            height: rectangle.height,
            width: rectangle.width,
        }
    );
}

function getOffset(offset?: number): number {
    return offset || 0;
}

function getWindowStyle(ctx: IContext): b.IBobrilStyles {
    const isScrollBarDisplayed = ctx.data.isResizeEnabled && ctx.data.isScrollbarEnabled;
    return [
        s.toggleWindowStyle,
        ctx.data.rootParent && s.toggleWindowFixedStyle,
        !ctx.data.customToggleWindowWidth && s.toggleWindowMaxWidthStyle,
        ctx.data.hasShadow && s.toggleWindowWithDefaultShadowStyle,
        ctx.data.hasBorder && s.toggleWindowWithBorderStyle,
        isScrollBarDisplayed && s.toggleWindowWithScrollbarStyle,
        !isScrollBarDisplayed && !ctx.data.hasArrow && !ctx.data.isOverflowVisible && s.toggleWindowWithOverflowHiddenStyle,
        ctx.data.hasArrow && getArrowStyle(ctx),
    ];
}

function getArrowStyle(ctx: IContext): b.IBobrilStyles {
    const arrowStyle = [s.arrowBaseStyle];
    const currentWindowPreferredPlacement =
        ctx.currentWindowPreferredPlacement !== undefined ? ctx.currentWindowPreferredPlacement : ctx.windowPreferredPlacement;

    const isContentWithHeader = isContentWithHeaderArrow(ctx.data.arrowType);

    if (currentWindowPreferredPlacement === Placement.TopCenter) {
        arrowStyle.push(s.arrowDownStyle, s.arrowDownCenterStyle);
    } else if (currentWindowPreferredPlacement === Placement.TopLeft) {
        arrowStyle.push(s.arrowDownStyle, s.arrowDownRightStyle);
    } else if (currentWindowPreferredPlacement === Placement.TopRight) {
        arrowStyle.push(s.arrowDownStyle, s.arrowDownLeftStyle);
    } else if (currentWindowPreferredPlacement === Placement.BottomCenter) {
        arrowStyle.push(s.arrowUpStyle, s.arrowUpCenterStyle);
        isContentWithHeader && arrowStyle.push(s.arrowWithHeaderStyle);
    } else if (currentWindowPreferredPlacement === Placement.BottomLeft) {
        arrowStyle.push(s.arrowUpStyle, s.arrowUpRightStyle);
        isContentWithHeader && arrowStyle.push(s.arrowWithHeaderStyle);
    } else if (currentWindowPreferredPlacement === Placement.BottomRight) {
        arrowStyle.push(s.arrowUpStyle, s.arrowUpLeftStyle);
        isContentWithHeader && arrowStyle.push(s.arrowWithHeaderStyle);
    } else if (currentWindowPreferredPlacement === Placement.Left) {
        arrowStyle.push(s.arrowRightStyle, s.arrowRightCenterStyle);
    } else if (currentWindowPreferredPlacement === Placement.Right) {
        arrowStyle.push(s.arrowLeftStyle, s.arrowLeftCenterStyle);
    }

    if (ctx.data.hasShadow) {
        arrowStyle.push(s.arrowWithShadowStyle);
    }

    return arrowStyle;
}

function isContentWithHeaderArrow(arrowType?: ArrowType): boolean {
    return arrowType !== ArrowType.ContentWithoutHeader;
}

function triggerOpenWindow(ctx: IContext) {
    if (ctx.data.isWindowVisible === undefined) {
        openWindow(ctx);
    } else if (ctx.data.onOpenWindow) {
        ctx.data.onOpenWindow();
    }
}

function isIRect(obj: b.IBobrilChildren | IRelatedHTMLElement | IRect): obj is IRect {
    const objTyped = obj as IRect;
    return objTyped.top !== undefined && objTyped.left !== undefined && objTyped.width !== undefined && objTyped.height !== undefined;
}

// added by script - BEGIN
export const ActionWithWindow = create;
// added by script - END
